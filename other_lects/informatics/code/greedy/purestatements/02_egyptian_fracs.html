<head>Problem EG: египетские дроби</head> 
<body>
<p>Египетской дробью называется дробь, имеющая в числителе 1</p>
<p>Каждое число может быть разложено на египетские дроби жадным алгоритмом, который выбирает наибольшую дробь на каждом шаге</p>
<p>Например: 39/50 = 1/2 + 1/4 + 1/34 + 1/1700</p>
<p>Напишите функцию, которая берёт числитель и знаменатель и возвращает выделенный в динамической памяти массив знаменателей и его размер</p>
<pre>
struct denom_array_t { unsigned *arr; unsigned sz; };

struct denom_array_t egyptian_fractions(unsigned num, unsigned den) {  
  // TODO: ваш код здесь
}
</pre>
<p>Вы можете предполагать, что num &lt; den</p>
<p>Не забудьте, что дроби надо сокращать в процессе вычисления, чтобы их знаменатели не вылезали за размер unsigned типа</p>
<p>Возможно вам понадобится несколько раз реаллоцировать память в процессе вычисления массива и вы (чтобы избежать частых реаллокаций) будете делать это с запасом. Проследите чтобы перед выходом из функции поле sz было установлено в правильный размер, точно совпадающий с количеством знаменателей</p>
<p>В выходном массиве меньший знаменатель должен идти по младшему адресу</p>
<p><br/>Примеры</p>
<p>
Вход: n = 39, m = 50
Выход: 2, 4, 34, 1700
Пример разобран выше
</p>
<p>
Вход: n = 1, m = 50
Выход: 50
Тривиальный случай когда дробь уже египетская
</p>
<p>
Вход: n = 2, m = 5
Выход: 3, 15
Поскольку 2/5 = 1/3 + 1/15
</p>
<p>
Вход: n = 4, m = 5
Выход: 2, 4, 20
Поскольку 4/5 = 1/2 + 1/4 + 1/20
</p>
<p>
Вход: n = 1023, m = 1024
Выход: 2, 3, 7, 44, 9462, 373029888
Обратите внимание, знаменатели могут быть довольно большими
</p>
</body>
