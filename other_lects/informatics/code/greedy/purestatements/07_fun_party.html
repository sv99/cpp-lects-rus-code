<head>Problem FP: организация утренника</head>
<body>
<p>Вам нужно организовать детский утренник на которых пришло nkids детей. У каждого ребёнка есть номер id и возраст age</p>
<p>Вы хотели бы получить минимальное количество групп, но при этом возраст детей в каждой группе не должен отличаться больше, чем на 2 года</p>
<pre>
// ребёнок
struct kid_t { int id; int age; };

// соответствие номера ребёнка номеру группы
struct kidgroup_t { int nkid; int ngroup; };

// ответ это массив соответствия
// размер mapping = размеру массива детей
struct answer_t { int ngroups; struct kidgroup_t *mapping; };

struct answer_t 
funparty(struct kid_t *kids, int nkids) {
  // TODO: ваш код здесь
}
</pre>
<p>Результирующий массив должен быть выделен в динамической памяти</p>
<p>Вы не должны полагаться на то, что входной массив с детьми как-то отсортирован</p>
<p><br/>Примеры</p>
<p>
Вход: 
<pre>
3, 4, 4, 6, 8
</pre>
Выход: 
<pre>
{3, 4, 4}, {6, 8}
</pre>
Здесь решение довольно очевидно: маленьких детей определяем в одну группу, более старших в другую
</p>
<p>
Вход:
<pre>
4, 5, 5, 6, 6, 8, 8, 9, 10, 11
</pre>
Выход:
<pre>
{4, 5, 5, 6, 6}, {8, 8, 9, 10}, {11}
</pre>
Здесь та же логика, но в итоге получается три группы. Обратите внимание, нет ничего страшного если ребёнок в группе один
</p>
<p>
Альтернативный выход: 
<pre>
{4, 5, 5}, {6, 6, 8, 8}, {9, 10, 11}
</pre>
Тех же детей можно распределить и таким образом.
Любой из этих ответов будет зачтён, потому что в обоих случаях число групп минимально и требования на возраст соблюдены
</p>
</body>
