<head>Problem RU: ларьки под общую крышу</head>
<body>
<p>На прямой расположены отрезки [xi, yi] которые все вместе полностью или даже с избытком покрывают интервал [L, R]</p>
<p>При этом некоторые отрезки могут начинаться и заканчиваться раньше, чем вообще начинается интересующий интервал, или гораздо позже. Вы можете быть уверены только в том, что те, которые точно покрывают этот интервал, среди них тоже есть</p>
<p>Вам нужно выбрать наименьшее количество отрезков таким образом, чтобы они всё ещё покрывали интервал</p>
<pre>
struct intvl_t { int number; int start; int fin; };

int covermin(int L, int R, struct intvl_t *intervs, int nintervs) {  
  // TODO: ваш код здесь
}
</pre>
<p>Обратите внимание, что отрезки (0, 2) и (2, 4) вместе покрывают интервал (0, 4) то есть все концы включены</p>
<p>Вы должны быть готовы к тому, что пришедший на вход массив интервалов никак не отсортирован</p>
<p><br/>Пример</p>
<img src="cover_interval.png" alt="covering example"> 
<p>Красным помечено выбранное оптимальное множество. Для такого множества вы должны вернуть число 2</p>
</body>
