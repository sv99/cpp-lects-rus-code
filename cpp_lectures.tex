\documentclass[a4paper,12pt,oneside]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1,T2A]{fontenc}
\usepackage[english,russian]{babel}
\usepackage[usenames]{xcolor}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{cmap}
\usepackage{indentfirst}
\usepackage{makeidx}
\usepackage[unicode]{hyperref}

\hypersetup{
%bookmarks=true,            % show bookmarks bar?
%unicode=false,             % non-Latin characters in Acrobat’s bookmarks
pdfproducer={Producer},    % producer of the document
pdfkeywords={keywords},    % list of keywords
pdfnewwindow=true,         % links in new window
colorlinks=true,           % false: boxed links; true: colored links
linkcolor=black,           % color of internal links
citecolor=black,           % color of links to bibliography
    filecolor=black,           % color of file links
    urlcolor=black             % color of external links
}

\renewcommand{\rmdefault}{cmr} 

\renewcommand{\texttt}[2][black]{\textcolor{#1}{\ttfamily #2}}

\definecolor{OliveGreen}{cmyk}{0.64,0,0.95,0.40}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\setlength{\parskip}{6pt}

\makeindex

\title{Лекции по C++}
\author{
  Владимиров Константин Игоревич\\
  \texttt{konstantin.vladimirov@gmail.com}
}
\date{\today}

\begin{document}

\begin{titlepage}
\begin{center}

\large ~ \\[4.5cm]

\huge Курс лекций\\[0.6cm]
\large По языку программирования C++\\[3.7cm]

\begin{minipage}{0.5\textwidth} % начало маленькой врезки в половину ширины текста
\begin{flushleft} % выровнять её содержимое по левому краю
\emph{Автор:} Владимиров К. И.\\
\end{flushleft} % конец выравнивания по левому краю
\end{minipage} % конец врезки

\vfill

Страница с последней редакцией: \url{sourceforge.net/p/cpp-lects-rus}\\
Email автора: \texttt{konstantin.vladimirov@gmail.com}\\
{\large \today}
{\large \LaTeX}

\end{center}
\thispagestyle{empty}
\end{titlepage}

\tableofcontents

\lstset{
language=C++,                           % Code langugage
basicstyle=\ttfamily,                   % Code font, Examples: \footnotesize, \ttfamily
keywordstyle=\color{OliveGreen},        % Keywords font ('*' = uppercase)
commentstyle=\color{gray},              % Comments font
stringstyle=\color{mauve},
numbers=left,                           % Line nums position
numberstyle=\tiny,
numbersep=10pt,
stepnumber=1,                           % Step between two line-numbers
frame=none,                             % A frame around the code
tabsize=2,                              % Default tab size
captionpos=b,                           % Caption-position = bottom
breaklines=true,                        % Automatic line breaking?
breakatwhitespace=false,                % Automatic breaks only at whitespace?
showspaces=false,                       % Dont make spaces visible
showstringspaces=false,
showtabs=false,                         % Dont make tabls visible
columns=flexible,                       % Column format
title=\lstname,
caption={},
extendedchars=\true,
inputencoding=utf8,
}

\pagebreak
\section{Общие сведения}\label{Introduction}

С++ (произносится ``си плас плас'')\index{C++} это язык общего назначения с сильной статической типизацией и ручным управлением ресурсами. Де-факто в современном программировании C++ является индустриальным стандартом. Язык был создан Бьярном Строструпом\index{Stroustrup} в 1980-м году как объектно-ориентированное расширение языка C\index{C}, известного с 70-х. В 1985-м появилась первая коммерческая версия компилятора Cfront и по языку была опубликована первая книга. 

По прошествии времени, C++ был принят сообществом, широко распространился. Код на C++ переносимо работает на различных архитектурах и операционных системах. В 1998-м году язык C++ был стандартизован (работа велась с 1990-го года). Сейчас язык C++ имеет развитую инфраструктуру средств компиляции, отладки, библиотек, поддержку в IDE. Много новых возможностей было введено в язык новым стандартом, принятым в 2011-м году. Ещё больше возможностей добавлено в стандарте C++14, окончательно принятом в 2015-м году.

\subsection{Стандартизация C++}\label{Standartization}

Вопрос к студентам: что такое ISO\index{ISO standard}, какие стандарты ISO вы знаете (читали).

Первый стандарт языка C++ под кодовым номером ISO/IEC 14882-1998 \cite{stdcpp98} был написан и утверждён ISO в 1998 году. Он включает в себя по нормативной ссылке стандарт языка C, ISO/IEC 9899-1990 \cite{stdc90}, что означает следующее: 
\begin{itemize}
\item
Возможности C90 (кроме явно оговоренных исключений) также являются возможностями C++98, также и стандартная библиотека языка C в ревизии C90 является стандартной библиотекой C++98
\item
Новые возможности C99 \cite{stdc90} не являются возможностями C++98 (стоит отметить, что стандарт C99 включён по ссылке в C++11 \cite{stdcpp11}, но стандарт C11 \cite{stdc11} снова разошёлся с текущим нижележащим подмножеством C в C++)
\end{itemize}

Стандарт языка C++ традиционно отличается от стандарта языка C тем, что стандарт C определяет корректность программы, написанной на C, стандарт же C++ определяет корректность компилятора. Это различие с первого раза кажется несущественным и бюрократическим, но во многом из-за него, например, стандарт C99 никогда не был целиком реализован ни в одном компиляторе C, поскольку конформные программы можно писать и с подмножеством возможностей. В то же время гораздо более сложный C++98 был реализован в некоторых компиляторах даже в своих наиболее эзотерических частях, таких как экспорт шаблонов.

Любой код, подаваемый на вход удовлетворяющего стандарту компилятора, стандарт классифицирует на следующие типы:
\begin{itemize}
\item
 \textbf{Syntax violation}\index{Syntax violation} -- нечто, вообще не являющееся кодом на языке C++. Это наиболее распространённый вид кода, производимого программистами.
\item
 \textbf{Implementation defined}\index{Implementation defined} – зависящий от разработчика и документации конкретного компилятора. Пример – как ведёт себя знаковое целое при сдвиге вправо.
\item
 \textbf{Unspecified}\index{Unspecified} – поведение корректного кода, не регламентированное стандартом. 
 Пример – порядок выполнения аргументов у функции.
\item
 \textbf{Undefined behavior}\index{Undefined behavior} – поведение некорректного кода, не запрещённое стандартом. 
 Пример – поведение целого числа при переполнении.
\item
 \textbf{Strictly conforming}\index{Strictly conforming} – хороший, полностью удовлетворяющий стандарту код, не выходящий за пределы стандарта. ``In anima vili'' редко встречается за пределами hello world у профессионалов и никогда не встречается у новичков.
\item
 \textbf{Conforming}\index{Conforming} – код удовлетворяющий стандарту + использующий implementation defined features.
\end{itemize}

У разных компиляторов есть своя стратегия выдачи диагностических сообщений. Для компиляции большинства примеров из этих лекций, будет использован компилятор g++ версии 4.7.1 или выше, входящий в GNU Compiler Collection с опциями: 

\lstinline!g++ -pedantic-errors -Wall -Werror -g3 -O0 -std=c++98!

\lstinline!g++ -pedantic-errors -Wall -Werror -g3 -O0 -std=c++11!

Эти опции заставляют репортить о не-conforming коде и воспринимать все диагностические сообщения как ошибки, а также включать отладочную информацию включая отладку по макросам и отключать все оптимизации (с моей точки зрения это единственный приемлимый способ компиляции учебных примеров).

Пример conforming кода на C-подмножестве C++:

\lstinputlisting{cpp_code/p0s1.cpp}

Приведённый выше код является conforming но не strictly conforming из-за использования INT\_MAX, являющегося implementation-defined. Тем не менее, нет способа заставить GCC выдать такое диагностическое предупреждение и этот код проходит компиляцию без ошибок, так что можно считать уровень conforming достаточным.

\pagebreak
\subsection{Неопределенное поведение}\label{UB}

Изо всех рассмотренных выше видов поведения программы, самое страшное это неопределённое поведение (undefined behavior или для краткости UB). Любой программист на языке C++ с опытом развивает чутьё на неопределённые ситуации, но даже профессионалы часто попадаются на эту удочку. В этих лекциях я предпочитаю остановиться на этой теме с самого начала, поскольку упомянутое выше чутьё надо развивать сразу. Сначала эффектный пример.

\subsubsection{Неявное UB как путь к проклятию}\label{HiddenUB}

Следующий код на C++ выглядит достаточно невинно

\begin{lstlisting}
#include <iostream>

int
main ()
{
  int i;

  for (i = 0; i < 10; ++i)
    std::cout << i << " : " << i*1000000000 << " : " << std::endl;

  return 0;
}
\end{lstlisting}

Но в эксперименте с GCC 4.8.2 мы получаем (в случае INT\_MAX = $2^{31} - 1$) бесконечный цикл. Компилятор на этапе agressive-loop-optimizations, считает, что без переполнения i не может быть больше 2. А раз 2 < 10, то и выход по условию (i < 10) невозможен, так что его и проверять не стоит.

Этот пример показателен тем, что в случае UB компилятор может не только \textbf{сделать} всё что угодно (например отформатировать диск), но и \textbf{не сделать} чего-то, причём компилятор даже не обязан об этом сообщать.

\subsubsection{Типичные случаи неопределённого поведения}\label{TypicalUB}

Здесь будет рассмотрен только язык C и C-подмножество C++. Неопределённое поведение возникающее при работе с ООП и шаблонами будет рассмотрено в конце соответствующих частей, а вот C вы уже должны знать. Типичными случаями, когда вы можете ожидать неопределённого поведения являются:

\textbf {Арифметика}
\begin {itemize}
\item Целочисленное переполнение
\item Математическая неопределенность результата (скажем деление на 0)
\item Сдвиг влево на отрицательные значения
\item Сдвиг на значения, превышающие размер типа
\item Приведение целого числа к не вмещающему его типу
\item Попытка изменить константный объект, приведя его к не константному
\end {itemize}

\textbf {Указатели}
\begin {itemize}
\item Разыменование нулевого указателя
\item Разыменование неинициализированного указателя
\item Разыменование указателя на память, динамически выделенную с нулевым размером
\item Использование указателей и ссылок на объекты с истекшим сроком жизни
\item Адресная арифметика с результатом, выходящим за границы массива и доступ к такой памяти
\item Преобразование указателей в несовместимые типы
\item Использование memcpy на пересекающихся участках памяти
\end {itemize}

\textbf {Препроцессор}
\begin {itemize}
\item Непустой исходный файл, не оканчивающийся на пустую строку (или оканчивающийся на обратный слеш)
\item Обратный слеш после которого стоит нечто отличное от перечня escape-кодов
\item Выход за реализационные пределы (скажем 1024 условия в switch)
\item Динамически генерируемый токен под \lstinline!#if!
\end {itemize}

Разумеется этот список не претендует на полноту, но он даёт представление о местах, которых стоит опасаться.

\subsubsection{Пример исправления ситуации}\label{CorrectingUB}

Очень часто код, демонстрирующий неопределённое поведение, можно переписать на эквивалентный детерминированный. Это работает не во всех случаях, но гораздо чаще, чем многие думают. Типичный грозящий UB код:

\begin{lstlisting}
int foo(int a) 
{
  assert(a + 100 > a); /* ORLY? */
  printf("%d %d\n", a + 100, a);
  return a;
}
\end{lstlisting}

Автор этого кода скорее всего считает, что оградился от случаев арифметичесого переполнения. На самом деле он просто заложился на неопределенное поведение. Простое переписывание кода сделает его гораздо более безопасным:

\begin{lstlisting}
int foo(int a) 
{
  assert(a < (INT_MAX - 100));
  printf("%d %d\n", a + 100, a);
  return a;
}
\end{lstlisting}

Если исправление ситуации с неопределённым поведением в ваших силах -- делайте это.

\subsection{Важность стандартизации}\label{StandartizationImportance}

Стандарты и даже ошибки в стандартах отлиты в граните. Например, в стандарте IEEE POSIX 1003.1-1988 была допущена ошибка: в одной главе было указано, что \lstinline!PATH_MAX! включает terminating null, в то время, как в другой главе было указано что не включает. Ошибка была обнаружена после публикации стандарта, люди обратились в комиссию стандартизации и оттуда пришло объяснение, что если написано и так и так, значит может быть и так и так. Хотя изначально идея была как раз в том, чтобы определённо установить включает ли \lstinline!PATH_MAX! нулевой символ.

Язык как соглашение между программистами и разработчиками компиляторов утверждается своим стандартом и не существует вне его. Все стандарты ISO доступны бесплатно в версии final draft – последнего черновика перед утверждением. Часто пиратски доступны и окончательные версии.

Читать и понимать стандарт языка – то, чем занимается каждый программист при решении любых спорных вопросов, возникающих у него относительно тех или иных языковых средств. Это последняя и окончательная инстанция.

Все эти лекции можно считать приглашением к самостоятельной проработке стандарта C++ совместно с решением практических задач. Собственно чтобы научится писать программы, надо знать язык и писать программы, иных вариантов нет.

\subsection{С++ это конгломерат языковых возможностей}\label{CppNature}

При изучении C++ необходимо понимать, что C++ не является монолитным языком (как C), а является сложным, исторически сформировавшимся конгломератом возможностей, зачастую порождающих взаимоисключающие стили решения конкретных задач. Кроме того, язык имеет много ``почти стандартных'' библиотек и популярные расширения на конкретных компиляторах. Самые известные это GNU расширения для C и C++, позволяющие, например, использовать в языке C вложенные функции и возвращать результат выполнения блока из фигурных скобок.
\paragraph{}
Поэтому всегда, когда вы пишете на C++, вы на самом деле пользуетесь неким его подмножеством или надмножеством, логическим или же техническим. Эти лекции охватывают (в указанном порядке) следующие основные подмножества C++:
\begin{itemize}
\item
Old plain C – подмножество C в языке C++, основные сложности, сходства и отличия
\item
Object-oriented С++ – объектно-ориентированные возможности в C++
\item
Template meta-programming – шаблоны и метапрограммирование
\item
STL – стандартную библиотеку, её основные идеи и возможности
\item
Exceptional C++ – исключения, гарантии исключений, проектирование с учётом исключений
\item
Функционал нового стандарта C++11 – rvalue references и  lambda-expressions
\item
Расширения GNU, популярные библиотеки, в частности Boost и ``несовершенные'' решения в языке
\end{itemize}

Для успешной разработки и поддержки кода на C++, каждую из его частей необходимо знать (хотя бы поверхностно). Сложность изучения языка C++ делает абсурдной задачу уложить его в 14 лекций (да даже и в 140 лекций, если уж на то пошло), но при достаточной работе дома, это должно дать хороший старт.

Задания на домашнюю работу в этих лекциях встречаются в тексте лекций, помеченные как \textbf{Домашняя наработка}. Обычно эти задания требуют всего лишь понимания прочитанного текста или поставить некоторый эксперимент который поможет в понимании. Более сложные задачи (впрочем без какого-нибудь ранжирования сложности) сведены в конце соответсвующих разделов.

\pagebreak
\subsection{Домашняя наработка по стандартам и неопределенному поведению}\label{StandHomework}
\begin{enumerate}
\item
Найти, скачать и бегло посмотреть стандарты о которых шла речь на этой лекции. В дальнейшем необходимость консультироваться с этими документами будет периодически возникать.
\item
Пусть дан код на C:

\lstinputlisting{cpp_code/p0s2.cpp}

Задача: охарактеризовать этот код с точки зрения стандарта C99, указать причины, по которым могу возникнуть проблемы.

Попробуйте проделать же самое для прочих стандартов -- C90, C++98, C11, C++11, etc

\item
Пусть дан код на C:

\lstinputlisting[firstline=1,lastline=5]{cpp_code/p0s3.cpp}

Задaча: охарактеризовать этот код с точки зрения стандарта C99, указать причины, по которым могу возникнуть проблемы.

\item
Пусть дан код на C:

\lstinputlisting[firstline=7,lastline=11]{cpp_code/p0s3.cpp}

Задaча: охарактеризовать этот код с точки зрения стандарта C99, указать причины, по которым могу возникнуть проблемы.

Попробуйте также С++98, сравните результат.

\item
Пусть дан код на C:

\lstinputlisting[firstline=13,lastline=17]{cpp_code/p0s3.cpp}

Задaча: охарактеризовать этот код с точки зрения стандарта C99, указать причины, по которым могу возникнуть проблемы. 

Попробуйте также С++98, сравните результат.

\item
Пусть дан код на C:

\lstinputlisting[firstline=19,lastline=24]{cpp_code/p0s3.cpp}

Задaча: охарактеризовать этот код с точки зрения стандарта C99, указать причины, по которым могу возникнуть проблемы.

Попробуйте также С++11, сравните результат.

\item
Пусть дан код на C:

\lstinputlisting[firstline=26,lastline=29]{cpp_code/p0s3.cpp}

Задaча: охарактеризовать этот код с точки зрения стандарта C99, указать причины, по которым могу возникнуть проблемы.

Попробуйте также С++11, сравните результат.

\end{enumerate}

В основном в этих лекциях рассматривается стандарт C++98, с небольшими заходами в C++11 особенно в конце.

\pagebreak
\section{Корни, кровавые корни}\label{BloodyRoots}

Язык C++ невозможно ни понять, ни оценить, если начинать осваивать его с его высокоуровневых возможностей (как иногда рекомендуют делать). Так или иначе, но C++ это не Java и программирование на нем без понимания того, что происходит под капотом, чревато крайне неприятными сюрпризами. Этот раздел будет посвящён C-подмножеству языка C++.

\subsection{Простые задачи для языка C}\label{SimpleTasks}

Предполагается, что человек, слушающий этот курс, обладает хотя бы минимальным знанием языка C в объёме стандарта 2011-го года.

Предлагается решить следующие задачи (у доски каждому студенту, в случайном порядке):

\begin{itemize}
\item
Перевернуть текстовую строчку
\item
Найти подстроку в строке
\item
Найти старший установленный бит в длинном слове
\item
Перевернуть односвязный список в памяти
\item
Найти тысячное простое число
\end{itemize}

Несмотря на то, что существенная часть этой лекции посвящена повторению языка C, я во-первых призываю всех читать и перечитывать Кернигана и Ричи, а во-вторых практиковаться в C, не забывая о нём при изучении C++. Лично я предпочитаю C и решения в стиле C за их простоту и близость аппаратуре.

Начать следует, как и полагается, с азов.

\subsection{Дьяволы деталей синтаксиса C}\label{DevilDetails}

Пусть стоит задача прочитать простое объявление на языке C

\lstinputlisting[firstline=5,lastline=5]{cpp_code/p1s1.cpp}

Что это? Ответ: да, это массив указателей\index{Array of pointers}. Вопрос: кто запишет указатель на массив?

Ответ\index{Pointer to array}:

\lstinputlisting[firstline=6,lastline=6]{cpp_code/p1s1.cpp}

Теперь рассмотрим модификатор \lstinline!const!\index{const}. Вопрос: есть ли разница между следующими объявлениями:

\lstinputlisting[firstline=8,lastline=10]{cpp_code/p1s1.cpp}

Ответ: между первым и вторым нет, между вторым и третьим очень существенная разница. Во втором случае (как и в первом) речь идёт о константном указателе на не константные данные. В третьем случае речь идёт о константном указателе на не константные данные. Обратите внимание -- объявляя константу мы не можем оставить её неинициализированной, поэтому инициализатор выделяет строчку, где объявлен константный указатель. В то же время, указатель на константные данные сам может быть неконстантным и инициализации не требует (хотя она возможна).

Вопрос: кто запишет константный указатель на константные данные? Сделать это надо двумя способами, не меньше.

Вопрос: кто понимает, что значит ключевое слово \lstinline!volatile!\index{volatile}.

Вопрос: Запишите теперь константый указатель на волатильные данные. Имеет ли он смысл? Можете ли вы представить ситуацию, когда вам может понадобиться волатильный указатель на константные данные?

\subsubsection{Чтение объявлений, как источник радости\index{C declarations}}\label{AlgDecl}

Теперь самостоятельно прочитайте объявление:

\lstinputlisting[firstline=12,lastline=12]{cpp_code/p1s1.cpp}

Алгоритм чтения таких объявлений (приведён например в \cite{linden}) следует из стандарта и в данном случае довольно прост:

\begin{itemize}
\item
Идём к имени переменной ``next''
\item
Группируем её с содержимым её скобок: ``next is a pointer to''
\item
За пределами скобок объявление функции имеет больший приоритет, поэтому ``next is a pointer to a function, returning''
\item
Далее обрабатываем слева звёздочку, имеем: ``next is a pointer to a function, returning pointer to''
\item
И далее парсим char * const: ``next is a pointer to a function, returning pointer to constant pointer to character''
\end{itemize}

Его можно обобщить и изобразить на рисунке:
\begin{figure}[h!]
\centering
\includegraphics[width=1.0\textwidth]{illustrations/cdecls-crop.pdf}
\caption{Алгоритм разбора объявлений на C}
\label{fig:cdecl_parse}
\end{figure}

\textbf{Домашняя наработка:} по этому алгоритму написать программу, которая парсила бы произвольное объявление на C. Дополнительно: учесть возможность \lstinline!enum!, \lstinline!struct!, \lstinline!union!.

С учётом новых знаний попробуйте прочитать самостоятельно:

\lstinputlisting[firstline=13,lastline=13]{cpp_code/p1s1.cpp}

Ответ: c is array of 10 pointers to functions, accepting pointer to pointer to int and returning pointer to char.

\subsubsection{Ваш друг typedef\index{typedef}}\label{FriendTypedef}

Рассмотрим прекрасное объявление типа:

\lstinputlisting[firstline=15,lastline=15]{cpp_code/p1s1.cpp}

С помощью \lstinline!typedef! его можно переписать, доставив гораздо меньше боли глазам читающего (и без риска посадить случайную опечатку).

\lstinputlisting[firstline=16,lastline=17]{cpp_code/p1s1.cpp}

Умение читать запутанные объявление не означает необходимости их писать (если вы не участвуете в международном конкурсе по обфускации программ). Где возможно, пользуйтесь \lstinline!typedef!, это хороший стиль. Но ваш личный хороший стиль (с другой стороны) это не основание не иметь навыка чтения запутанных объявлений. Каждый программист в жизни имеет дело с тоннами унаследованного кода, где встречается всякое.

У \lstinline!typedef! есть некоторые опасности, которые часто ускользают от новичков. Так например \lstinline!typedef! может объявить сразу несколько синонимов типов:

\lstinputlisting[firstline=19,lastline=19]{cpp_code/p1s1.cpp}

Это считается дурным тоном, старайтесь этого избегать. Ещё более дурным тоном считается зарыть typedef вглубь объявления, что тоже позволяется синтаксисом.

\lstinputlisting[firstline=20,lastline=20]{cpp_code/p1s1.cpp}

Опытный программист на языке C часто чувствует себя свободнее с препроцессором, скажем вместо

\lstinputlisting[firstline=21,lastline=21]{cpp_code/p1s1.cpp}

Есть соблазн написать

\lstinputlisting[firstline=22,lastline=22]{cpp_code/p1s1.cpp}

Но здесь есть тонкая ловушка:

\lstinputlisting[firstline=21,lastline=25]{cpp_code/p1s1.cpp}

Здесь переменные \lstinline!x! и \lstinline!y! будут разных типов, а \lstinline!w! и \lstinline!v! – одного типа.

\subsection{Знакомство с \lstinline!const!, \lstinline!enum! и \lstinline!inline!}\label{ConstVsDef}

Пример с \lstinline!typedef! показывает нам, что использование возможностей языка лучше, чем использование препроцессора. Есть такие возможности C++, которые кардинально отличают программирование на C-подмножестве C++ и использование которых является хорошим тоном. Например всегда следует предпочитать введение символьных констант препроцессорным объявлениям.

\begin{lstlisting}
#ifdef USE_PREPROC
#define MADELUNGNACL 1.747558
#define PI 3.1415926
#else
const double MADELUNGNACL = 1.747558;
const double PI 3.1415926
#endif

double 
ENaCl (double z, double e, double epsilon, double r)
{
  return (z * e * e * MADELUNGNACL) / (4 * PI * epsilon * r);
}
\end{lstlisting}

Постоянная Маделунга (для определения энергии электростатического взаимодействия одного иона Ei в ионном кристалле) та же самая. Разумеется и $\pi$ то же самое. В чём разница? В первом случае препроцессор сделает текстовую подстановку \lstinline!1.747558! везде, где вы использовали \lstinline!MADELUNGNACL!, во втором случае компилятор объявит (и поместит в таблицу символов для отладочной информации) символьную константу. 

Ещё в большей степени это касается работы с перечислениями (строго говоря, она и в C была введена в C99).

\lstinputlisting[firstline=30,lastline=35]{cpp_code/p1s1.cpp}

Здесь кроме очевидной экономии места, вводится тип keyword, который может принимать только определённые в enum значения, что также является преимуществом.

Ещё сильнее C++ выигрывает для определения небольших функций, где в C были выгодны макросы:

\lstinputlisting[firstline=37,lastline=44]{cpp_code/p1s1.cpp}

Давайте рассмотрим контекст использования

\lstinputlisting[firstline=48,lastline=50]{cpp_code/p1s1.cpp}

Вопрос: что будет содержаться в \lstinline!c! и в \lstinline!d!? А что если подставить вызов функции \lstinline!max!? Ещё лучше объявление функции max будет себя вести при использовании ссылок (мы познакомимся с ними далее).

Кстати, поскольку шаблон раскроется на этапе компиляции, а вызов max почти всегда будет проинлайнен, эффективность C++ метода как минимум не страдает.

Более того, почти всегда, когда в C использовался \lstinline!void*! для передачи параметров неопределённого типа, в C++ можно написать более эффективный код, используя шаблоны. Мы вернемся к этому далее (\ref{CppBetterC}).

\subsection{Различие объявлений и определений\index{declaration}\index{definition}}\label{DeclVsDef}

До сих пор действия с объявлениями и определениями выполнялись интуитивно, без полного понимания того, что это такое. Давайте теперь посмотрим на детали.

В языке C это довольно просто и это надо просто знать.

Объявление (declaration) это введение идентификатора и описание типа.

\begin{lstlisting}
extern int bar;
extern int g(int, int);
double f(int, double); /* extern can be omitted for function declarations */
class foo; /* no extern allowed for class declarations */
\end{lstlisting}

Объявление достаточно компилятору, чтобы разрешить ссылки на данный идентификатор. 

Определение это реализация типа или выделение памяти объекту.

\begin{lstlisting}
int bar;
int g(int lhs, int rhs) {return lhs*rhs;}
double f(int i, double d) {return i+d;}
class foo {};
\end{lstlisting}

Определение достаточно линкеру, чтобы реализовать идентификатор в объектном коде. 

Объявление может встречаться сколько угодно раз. Определение встречается лишь один раз. Это называется One Definition Rule (ODR\index{ODR}) и оно должно чётко соблюдаться. Нарушение ODR -- UB. При этом любое определение также является объявлением.

У ODR есть несколько уровней строгости и из него есть несколько исключений, перечисленных в пункте 3.2 стандарта C++14
\begin{itemize}
\item функции и переменные с внешним связыванием должны быть определены один раз на все единицы трансляции
\item встраиваемые функции, статические функции и переменные, определения пользовательских типов, шаблоны классов и их частичные специализации должны быть определены не более одного раза в каждой единице трансляции
\end{itemize}

Можно запомнить мнемоническое правило чтобы не путать объявление с определением, а в англоязычной литературе declaration и definition, нужно смотреть на словарное упорядочение.  Буква ``б'' расположена раньше, чем ``п''. Значит в словаре слово ``объявление'' будет раньше, чем ``определение'' и так же declaration в английском словаре идёт раньше, чем definition. И так же в программе – объявление всегда должно идти раньше определения.

Важной концепцией является точка определения \index{Point of Declaration}. Определение считается законченным когда записан полный идентификатор (то есть \textbf{до} возможных инициализаторов). Поэтому:

\begin{lstlisting}
int x = 2;
{
  int x /* PoD */ = x;
}
\end{lstlisting}

В этом случае значение внутреннего \lstinline!x! не определено. Но в следующем случае:

\begin{lstlisting}
int x = 2;
{
  int x[x] /* PoD */;
}
\end{lstlisting}

всё корректно и вложенный массив имеет два элемента.

С концепцией точки определения, связана концепция области видимости. Область видимости \index{Scope} переменной, объявленной внутри блока из фигурных скобок это текст программы от точки определения до закрывающей фигурной скобки блока. В стандарте можно посмотреть правила для других областей видимости (scopes).

Важные термины здесь – полный и неполный тип. Если тип (структура, класс, массив) только объявлен, но не определен то этот тип считается неполным. Полным тип  становится только в точке, в которой встречается его определение. Рассмотрим на примере структур.

\lstinputlisting[firstline=57,lastline=65]{cpp_code/p1s1.cpp}

Функция \lstinline!foo! может брать аргументом указатель на \lstinline!t!, но не может брать аргументом сам \lstinline!t! пока тип \lstinline!t! неполный.

Интересно, что строчка одного и того же вида может служит определением или обявлением в зависимости от контекста:

\begin{lstlisting}
typedef void T();
T t; /* declaration of function "t" */

struct X 
{ 
  T t; /* declaration of function "t" */
};

typedef int T;
T t; /* definition of object "t" */
\end{lstlisting}

При рассмотрении шаблонов, станет очевидно, что определения и объявления имеют больше подводных камней, чем описано здесь.

\subsection{Lvalue и rvalue\index{lvalue}\index{rvalue}}\label{LRvalues}

Разговор о C++ невозможен без введения таких фундаментальных понятий, как lvalue и rvalue. Для начала можно рассмотреть пример, который многим из вас может показаться простым.

\begin{lstlisting}
x = y;
\end{lstlisting}

Что здесь написано? Здесь написано – взять адрес переменной x и записать по этому адресу значение переменной y. В этом выражении присваивания, переменная x находится слева, а y справа и стандарт C++98 вводит специальные термины rvalue (right-hand-side value) и lvalue (left-hand-side value) интуитивно понимаемые как ``нечто, что может быть справа (слева) в выражении присваивания''. 

Итак, какие ограничения этот пример накладывает на \lstinline!x!? Похоже, что \lstinline!x! должен быть полного типа, не константым, и иметь определённое местоположение в памяти (быть адресуемым). Есть ли ограничения на \lstinline!y!? Да есть. Он должен быть полного типа и этот тип должен быть совместим с типом \lstinline!x! по присваиванию.  

Это типичный пример того, как компилятор может решить из контекста (в данном случае из положения справа или слева от присваивания) будет ли он использовать адрес переменной или её значение в своих фактических вычислениях. Такая возможность у компилятора есть, потому что адрес переменной полного типа всегда известен во время компиляции и нет необходимости заставлять программиста его специально получать.

\begin{lstlisting}
*(&x) = y;
\end{lstlisting}

Возможно, кстати, писать так было бы честнее. Интересные вещи начинаются, когда дело доходит до массивов и указателей.

\pagebreak
\subsection{Массивы и указатели}\label{ArrPointers}

Многие программисты заучивают правило для новичка: массивы в C это указатели и наоборот. Это правило, пожалуй, действительно полезно для новичка. Но в общем случае это не так. Ниже будут проведены чёткие разграничения. Начать следует с указателей. Итак, что можно сделать с указателем (базовые вещи):

\begin{enumerate}
\item Объявить и инициализировать константой
\begin{lstlisting}
int *x = 0;
\end{lstlisting}
\item Объявить и инициализировать адресом переменной или функции
\begin{lstlisting}
struct str_t {int x; int y;};
int foo (int x);
int c = 2;
str_t s = {1, 2};
int *p = &c;
int (*pfoo) (int) = &foo;
str_t *ps = &s;
\end{lstlisting}
\item Присвоить иное значение
\begin{lstlisting}
int bar (int x);
p = x;
x = &c;
pfoo = &bar
\end{lstlisting}
\item Разыменовать и получить или изменить значение
\begin{lstlisting}
c = *x;
*p = 5;
c = (*ps).x;
c = ps->x;
ps->x = *p;
\end{lstlisting}
\item Использовать индексацию, похожую на массив
\begin{lstlisting}
p[0] = c;
*(p+0) = c;
\end{lstlisting}
\item Возвращать из функций
\begin{lstlisting}
int *foo (int x) { return &x; }
\end{lstlisting}
\end{enumerate}

Важно понять: указатели (неконстантные) являются lvalue. В принципе вы можете записать:

\lstinputlisting[firstline=26,lastline=28]{cpp_code/p1s2.cpp}

Этот код является дурным тоном, он будет плохо переносим и совершенно точно тут указатель используется не по назначению, но важно, что это можно сделать. Указатель это честная ячейка памяти. Он хранит то, что туда положил программист.

\begin{figure}[h!]
\centering
\includegraphics[width=0.3\textwidth]{illustrations/pointers-crop.pdf}
\caption{Визуальное представление указателей}
\label{fig:pointers-crop}
\end{figure}

По аналогии, что можно сделать с массивом

\begin{enumerate}
\item Объявить и инициализировать списком данных (все пропущенные инициализаторы -- нулевые)
\begin{lstlisting}
int a = 5;
int x[10] = {6, a};
\end{lstlisting}
Обратите внимание: неинициализированным может быть только локальный массив. Глобальные массивы всегда инициализированы нулями.
Также обратите внимание. Определение вида:
\begin{lstlisting}
int wrong[]; /* boom! */
\end{lstlisting}
Это ошибка (поскольку компилятор не знает сколько памяти выделять на этот массив). Но мы можем использовать такой синтаксис в объявлениях
\begin{lstlisting}
extern int wrong[]; /* ok */
\end{lstlisting}
\item Прочитать или записать значение
\begin{lstlisting}
int t = x[0];
x[1] = t;
x[0] = x[1];
\end{lstlisting}
\item Деградировать (decay) к указателю если он используется как rvalue\label{ArrDecaying}
\begin{lstlisting}
int foo (int *t);
int *p = &x[0];
*p = x; /* decay */
a = *(x + 3); /* decay */
a = foo (x + 5); /* decay */
\end{lstlisting}
\end{enumerate}

\begin{figure}[h!]
\centering
\includegraphics[width=0.3\textwidth]{illustrations/arrays-crop.pdf}
\caption{Визуальное представление массивов}
\label{fig:arrays-crop}
\end{figure}

Но массивы \textbf{никогда} не употребляются вместо указателей там, где указатель это lvalue.

\begin{lstlisting}
int v = 5;
int *p = &v;
int a[1] = {v};
p = a; /* ok */
a = p; /* never */
\end{lstlisting}

По той же причине мы никогда не можем вернуть массив из функции:

\begin{lstlisting}
typedef int arr_t[10];

arr_t foo (void); /* Error! */
\end{lstlisting}

Массивы хранят сами данные, а не указатели на них. То, что они синтаксически могут вырождаться к указателям -- не более, чем причудливый исторический факт, связанный с ранней историей массивов в языке C. Массив содержит lvalue-ячейки данных, но сам как целое он не является lvalue-ячейкой данных.

Кроме того, инициализация массивов и указателей выглядит похоже, но означает разные вещи:

\lstinputlisting[firstline=35,lastline=37]{cpp_code/p1s2.cpp}

Вопрос: есть ли разница между этими двумя записями и какую вы предпочтёте? Почему?

Верный ответ: строчка 1 предпочтительней, чем (устаревшая, с Wall + Werror выдаст ``error: deprecated conversion from string constant to \lstinline!char*!'') строчка 2 и они имеют разную семантику. Память под массивы выделяется автоматически (и строчка 1 подразумевает неявный memset) но память никогда автоматически не выделяется под указатели, поэтому для построения динамических структур данных (например, связных списков) используются указатели, а не массивы.

Между прочим, строковые литералы в инициализации указателей это счастливое (и опять таки исторически сложившееся) исключение. Строчка 2 в примере ниже:

\lstinputlisting[firstline=43,lastline=44]{cpp_code/p1s2.cpp}

Не будет скомпилирована.

Вопрос: есть ли разница между

\begin{lstlisting}
int foo (int x[]);
int foo (int *x);
\end{lstlisting}

Ответ: из-за decaying разницы нет.

Вопрос: означает ли эта запись:

\begin{lstlisting}
int foo (int x[16]);
\end{lstlisting}

Что \lstinline!foo! принимает массив из 16 символов?

Ответ: нет, здесь \lstinline!foo! принимает любой указатель.

Но это всё были одномерные случаи. Что же с многомерными массивами?

\subsubsection{Многомерные массивы\index{multidimensional arrays}}\label{MultiDimArr}

Язык C и C-подмножество языка C++ не поддерживают семантику ``настоящего'' многомерного массива на уровне языка.  То, что поддерживается, является по факту ``массивом массивов ... массивов''. 

К ним применяются те же правила, что к обычным массивам, например

\lstinputlisting[firstline=60,lastline=60]{cpp_code/p1s2.cpp}

Причём последние индексы идут последними. Так же и с инициализацией:

\lstinputlisting[firstline=63,lastline=63]{cpp_code/p1s2.cpp}

Причём наиболее вложенные скобки относятся к последним индексам. Первый индекс ясен из контекста и его можно опускать в инициализаторе.

Если часть вложенных инициализаторов пропущена, они считаются нулевыми, поэтому, например двумерные массивы символов могут быть проинициализированы последовательностями строковых литералов.

При передаче многомерных массивов в функции может быть опущен только первый индекс в прототипе (и он может быть любым). Остальные индексы у формального и фактического аргументов должны совпадать.

Вот такой прототип функции не может быть скомпилирован

\begin{lstlisting}
int func(int a[][], int n);
\end{lstlisting}

Это происходит потому, что массивы в памяти должны занимать непрерывную память. Для многомерных массивов раскладка в памяти идёт построчно

\begin{lstlisting}
int a[2][3];
/* TODO: картинка */
/* a[0][0], a[0][1], a[0][2], a[1][0], ... */
\end{lstlisting}

Дальше когда встречается индексирование \lstinline!a[i][j]!, компилятор генерирует код \lstinline!*(a + i*3 + j)!
Но, чтобы сгенерировать такой код, компилятор должен знать все измерения, кроме первого. Именно поэтому чтобы передать многомерный массив, программист должен так или иначе сообщить эту информацию компилятору.

\begin{lstlisting}
int func(int a[][3], int n);
int func(int (*a)[3], int n);
\end{lstlisting}

Некоторые думают, что можно обойтись двойным указателем.

\begin{lstlisting}
int func(int **a, int n, int m);
int a[2][3];
func (a, 2, 3); /* wrong! */
\end{lstlisting}

Но это не работает. Двумерный массив уже не может деградировать к указателю на указатель, а только к указателю на массив. Забавный хак в этом отношении -- обойтись одинарным указателем:

\begin{lstlisting}
int func(int *a, int n, int m);
int a[2][3];
func (&a[0][0], 2, 3); /* ok */
\end{lstlisting}

Но внутри функции это потребует ручного обслуживания такого "развернутого" массива.

Точно так же нельзя, даже указав нужные инициализаторы, определить двумерный массив, для которого компилятор дедуцирует оба размера

\begin{lstlisting}
int a[][] = {{1, 2}, {3, 4}}; /* Error! */
\end{lstlisting}

Увы, но здесь, как и в прототипах функций, должны быть указаны все размеры, кроме, может быть, первого.

\subsection{От указателей к ссылкам\index{references}}\label{PointersAndRefs}

Очень важной особенностью C++ является введение довольно низкоуровневой, но принципиально новой конструкции – ссылок. Ссылка это альтернативное имя переменной.

\lstinputlisting[firstline=67,lastline=70]{cpp_code/p1s2.cpp}

Каждая ссылка обязательно должна быть инициализирована в точке определения. ``Ссылка сама по себе'' так же как ``нулевая ссылка'' не могут существовать. Указатель сам по себе является местом для хранения данных, ссылка – это просто имя. Поэтому ссылки не нуждаются в явном разыменовании – каждое обращение к ним это уже разыменование. Поэтому различия существенны:

\lstinputlisting[firstline=76,lastline=81]{cpp_code/p1s2.cpp}

\subsubsection{Когда ссылки уступают указателям}\label{PointersVsRefs}

В целом при программировании на C++ следует повсюду предпочитать использование ссылок использованию указателей.

Но есть нюансы. Ссылки иммутабельны -- назначив ссылку ``другим именем'' чего-то, её нельзя перевязать на что-то другое

\begin{lstlisting}
int a = 2;
int b = 3;

int *pa = &a; /* ok */
pa = &b; /* ok, now *pa == 3 */

int &ra = a; /* ok */
ra = b; /* ok, now a == 3 */
\end{lstlisting}

Вторая строчка в случае ссылок -- не перевязывает ссылку, а присваивает значение тому lvalue на которое она ссылается. Поэтому ссылки нельзя использовать для создания динамических структур данных (см. ниже про динамическую память) таких как стеки, очереди, деревья.

Кроме того, у ссылок нет аналога \lstinline!(void *)! для передачи идиомы ``ссылки на неопределённый тип''. Появившиеся в новом стандарте \lstinline!auto&! всё таки должны быть разрешены на этапе компиляции, что бывает невозможно:

\begin{lstlisting}
void *read (void);

void 
use (void)
{
  int a = *(int *) read(); /* read int */
  double d = *(double *) read(); /* next read double */
  /* ... */
}
\end{lstlisting}

Итак, использование ссылок должно происходить где это возможно, но нужно хорошо понимать места, в которых их использование невозможно или нецелесообразно.

\subsection{От malloc и free к new и delete\index{new}\index{delete}}\label{newdelete}

Для управления динамической памятью в языке C использовались библиотечные функции malloc и free. Они остались в C++, но их использование не рекомендовано и считается дурным тоном, поскольку C++ предоставляет гораздо более гибкие возможности с помощью ключевых слов \lstinline!new!, \lstinline!delete! и \lstinline!delete[]!.

\lstinputlisting[firstline=87,lastline=90]{cpp_code/p1s2.cpp}

Следует оговориться, что для C-подмножества эти возможности пожалуй менее гибкие и более ограничивающие. Нужно помнить о парности \lstinline!new!/\lstinline!delete! и \lstinline!new a[]!/\lstinline!delete[] a! и нет возможности сделать \lstinline!realloc!. Вся сила новых ключевых слов раскроется позже, когда будут рассматриваться элементы ООП. Пока что вы можете просто запомнить их и начинать применять. Впрочем и в C-подмножестве можно найти плюсы.

Например \lstinline!new! существенно упрощает выделение в памяти многомерных массивов, что было не так то просто в случае языка C. Для C++ можно просто записать:

\begin{lstlisting}
typedef int dimensions[3][4];

dimensions * dim = new dimensions[10];
dim[/* from 0 to 9 */][/* from 0 to 2 */][/* from 0 to 3 */] = 42;
delete [] dim;
\end{lstlisting}

Это не требует убогих трюков когда массив выделяется как одномерный, а потом обслуживается как двумерный -- всё прозрачно и типизировано.

\subsection{От приведения в стиле C к приведению в стиле C++\index{cast}}

Язык C, поскольку он разрабатывался с интенцией отображения один в один на машинные типы, имеет слабую типизацию. Кусок памяти, который хранит int или указатель на int или механическую структуру из чего-нибудь, легко приводится к другому такому же куску памяти.

\lstinputlisting[firstline=95,lastline=100]{cpp_code/p1s2.cpp}

Язык C++ содержит гораздо более развитую систему типов и позволяет определять типы, обладающие состоянием и поведением, о которых пойдёт речь в следующих лекциях. Поэтому, несмотря на то, что формально C++ унаследовал от C способ непосредственного приведения C-style cast, применять его считается крайне плохим тоном. Вместо этого следует применять \lstinline!static_cast!\index{static\_cast}, \lstinline!reinterpret_cast!\index{reinterpret\_cast} или \lstinline!const_cast!\index{const\_cast}. Чаще всего вы будете применять \lstinline!static_cast!. Он записывается так:

\lstinputlisting[firstline=106,lastline=107]{cpp_code/p1s2.cpp}

В принципе это ничем не отличается от C-стиля, рассмотренного выше. Запись чуть более уродлива, зато чуть лучше бросается в глаза в коде программы. Разница в том к чему можно применять \lstinline!static_cast!, а к чему C-cast. Последний применяется к чему угодно. \lstinline!static_cast! применяется только к переменным, совместимым по статическим типам. Его можно использовать в преобразовании \lstinline!int*! к \lstinline!float*! (и то и другое – указатели). 

Гораздо более редкий \lstinline!const_cast! нужен для снятия константности и волатильности. С его помощью можно привести \lstinline!const int *! к \lstinline!int *!. 

\lstinputlisting[firstline=113,lastline=114]{cpp_code/p1s2.cpp}

Вы конечно понимаете опасность этих игр – в памяти, выделенной для \lstinline!const int*!, компилятор размещает данные, изменения которых не ожидает. В тот момент, когда вы принудительно снимаете константность и изменяете (пытаетесь изменить) нечто объявленное ранее константным, вы стреляете себе в ногу.

И самый редкий \lstinline!reinterpret_cast! существует для непереносимых низкоуровневых приведений, которые, тем не менее, иногда нужны.

\lstinputlisting[firstline=120,lastline=121]{cpp_code/p1s2.cpp}

Любое использование \lstinline!reinterpret_cast! (как и C-cast) компрометирует вашу программу. Но случаи использования \lstinline!reinterpret_cast! читающему ваш код будет куда проще найти и вычистить.

Выучить и использовать эти три оператора не намного сложнее, чем использовать обычные преобразования в стиле C, но в дальнейшем они сослужат вам отличную службу, упрощая поддержку кода и не давая посадить тяжело обнаружимых ошибок приведения.

\subsection{Перегрузка функций, аргументы по умолчанию и искажение имён\index{Function Overloading}\index{Name Mangling}}\label{NameResolution}

Вопрос к слушателям сколько функций вычисления квадратного корня вы можете назвать из стандартной библиотеки языка C?

Правильный ответ: три (7.12.7.5) \lstinline!sqrtf!, \lstinline!sqrt! и \lstinline!sqrtl!. Три функции с разными именами понадобилось вводить потому, что они принимают аргументы разных типов, а язык C предоставляет достаточно сильную гарантию того, что любое имя, использованное в вашей программе будет отображено в ассемблер вашей целевой машины один к одному, без искажения.

Язык C++ такой гарантии не даёт. Вместо этого он согласен сделать эту (и многую другую) работу за вас посредством встроенного искажения (манглирования) имён. Используя C++ вы можете написать три функции с одинаковыми именами, но различными типами:

\lstinputlisting[firstline=125,lastline=127]{cpp_code/p1s2.cpp}

Посмотрим во что они были откомпилированы в ассемблер:

\begin{lstlisting}[language=make]
_Z3barc:
...
_Z3bari:
...
_Z3barx:
...
\end{lstlisting}

Конвенции манглирования не документированы и являются implementation-defined, закладываться на них не надо. Но грамотно использовать механизм перегрузки функций в C++ бывает очень выгодно для облегчения читаемости вашей программы.

Для большинства компиляторов C++ существуют ``деманглеры'' -- специальные приложения, способные по искаженному имени ассемблерной метки восстанавливать сигнатуру функции. Скажем в GCC это \lstinline!c++filt!. Попробуйте, скажем: \lstinline!c++filt _ZN4Anls3Cfg7_DeleteEPKv!

Иногда требуется из кода на C++ сделать некую функцию или переменную (обычно входящую в интерфейс модуля) ``линкуемой в C стиле'' -- т.е. отображаемой в ассемблер один в один. Для этого используется спецификатор линковки \lstinline!extern "C"!. Им можно как аннотировать функцию или переменную, так и брать их в блоки.

\begin{lstlisting}
extern "C" void 
foo(int);

extern "C"
{
   void g(char);
   int i;
}
\end{lstlisting}

Так слинкованы могут быть свободные функции и глобальные переменные, но не члены классов. Две функции с такой линковкой с одинаковым именем -- нарушение ODR.

\textbf{Домашняя наработка:} посмотрите как работает манглирование в вашем любимом компиляторе. Можете ли вы установить некие закономерности?

Также удобная концепция (и снова проистекающая от отсутствия обязательств C++ быть близким к машине) это аргументы по умолчанию. Посмотрим как они могут быть заданы:

\lstinputlisting[firstline=1,lastline=5]{cpp_code/p1s2.cpp}

Функция не может быть перегружена по значению аргумента по умолчанию. Для перегрузки вы можете использовать только сигнатуру – возвращаемый тип функции и типы её аргументов.

Перегрузка функций и аргументы по умолчанию сильно упрощают работу с именами функций в C++, перенося всю её тяжесть на плечи компилятора и вам следует научиться использовать эти возможности правильно.

\subsubsection{Правила разрешения перегрузки\index{overloading resolution}}\label{Overloading}

Многие считают, что разрешение перегрузки в C++ неочевидно и подчиняется странным правилам. На самом деле это так и есть. Но вдумчивое чтение стандарта (вся 13 глава посвящена перегрузке) позволяет вывести некоторые закономерности. 

Можно запомнить или записать:

Если среди вариантов перегрузки присутствует функция, точно совпадающая с вызываемой по типам аргументов, будет вызвана она. Далее применяются преобразования аргументов в следующем порядке:

\begin{enumerate}
\item Стандартные преобразования
\item Пользовательские преобразования
\item Троеточия
\item Ссылочное связывание
\item (новый стандарт) Списочная инициализация
\end{enumerate}

После каждого типа преобразований сверху-вниз, получается множество возможных функций. Если это множество состоит из одной функции, будет вызвана она. Если это множество состоит из нескольких функций, будет выдана ошибка компиляции. Если это множество пусто, будет попробован следующий тип преобразований аргументов.

Пока можно оставить за бортом третий и пятый типы преобразований, до них дойдёт дело в своё время. Простой пример на всё остальное:

\begin{lstlisting}
#include <cstdio>

int foo (char x) { return 0;}  /* step 1 */
int foo (short x) { return 1;} /* step 1 */
int foo (int x) { return 2;}   /* step 0 */
int foo (...) { return 3;}     /* step 3 */
int foo (int &x) { return 4;}  /* step 4 */

int
main (void)
{
  std::printf ("result: %d\n", foo (10));
  return 0;
}
\end{lstlisting}

Здесь никаких конфликтов нет. Для вызова \lstinline!foo (10)! точно подходит \lstinline!foo (int)!, программа возвращает 2.
Если стереть её, то будет ошибка компиляции:

\begin{lstlisting}
#include <cstdio>

int foo (char x) { return 0;}  /* step 1 */
int foo (short x) { return 1;} /* step 1 */
int foo (...) { return 3;}     /* step 3 */
int foo (int &x) { return 4;}  /* step 4 */

int
main (void)
{
  std::printf ("result: %d\n", foo (10));
  return 0;
}
\end{lstlisting}

Конфликт между двумя равноправными функциями \lstinline!step 1!. Если далее стереть одну из них:

\begin{lstlisting}
#include <cstdio>

int foo (char x) { return 0;}  /* step 1 */
int foo (...) { return 3;}     /* step 3 */
int foo (int &x) { return 4;}  /* step 4 */

int
main (void)
{
  std::printf ("result: %d\n", foo (10));
  return 0;
}
\end{lstlisting}

Снова всё норм, программа вернёт 0. Если стереть оставшуюся.

\begin{lstlisting}
#include <cstdio>

int foo (...) { return 3;}     /* step 3 */
int foo (int &x) { return 4;}  /* step 4 */

int
main (void)
{
  std::printf ("result: %d\n", foo (10));
  return 0;
}
\end{lstlisting}

Программа вернёт 3. И, наконец, если стереть все варианты кроме ссылочного связывания, программа вернёт 4.

Если вдуматься в эти правила они уже не выглядят столь марсианскими, правда? Хех. Это от того, что я рассказал вам их \textbf{не все}. Тема разрешения перегрузок ещё будет затронута в разговоре про ООП и далее, в разговоре про новый стандарт. Но на уровне C подмножества, всё выглядит довольно логично.

\subsection{Пространства имён, using и поиск Кёнига\index{namespaces}}

Каждое объявление в C++ принадлежит некоторому пространству имён. Глобальное пространство имён это префикс через два двоеточия, а все стандартные функции принадлежат пространству имён std. Напишем hello world с явным указанием пространств имён.

\lstinputlisting[firstline=1,lastline=7]{cpp_code/p1s3.cpp}

Обратите внимание на включение \lstinline!<cstdio>! вместо привычного \lstinline!<stdio.h>! хедера. Все заголовочные файлы к которым вы привыкли в C, сохранены в C++. Но хорошим тоном считается писать унаследованные заголовочные файлы в C++ conforming виде, то есть \lstinline!<cXXX>! вместо \lstinline!<XXX.h>!.

Нужно быть осторожным с теми функциями, которые объявлены в стандартной библиотеке языка C как макросы, а не как функции. Разумеется, макросы не могут быть обернуты никаким пространством имен, поэтому мы пишем \lstinline!assert! а не \lstinline!std::assert!. Макросы в стандартной библиотеке нужны там, где функциональность может быть отключаема -- скажем опция \lstinline!NDEBUG! позволяет сделать сборку более эффективной, отключив все ассерты в приложении. 

Засорять собственными именами, такими как \lstinline!::helloworld!, глобальное пространство имён это на самом деле крайне плохая идея. Несколько лучше объявить своё пространство имён, включив туда всё, что специфично именно для вашей программы.

\lstinputlisting[firstline=1,lastline=9]{cpp_code/p1s4.cpp}

Допустимо объявлять вложенные пространства имён с произвольным количеством уровней вложенности. При помещении в пространство имён функции с большим телом, вполне достаточно поместить в пространство имён явно только объявление (например в заголовочном файле), указав пространство имён при определении (например в файле реализации).

\lstinputlisting[firstline=1,lastline=6]{cpp_code/p1s5.cpp}

Пространства имён являются областями видимости (как блоки из фигурных скобок) и подчиняются тем же правилам – если имя указано в охватывающем пространстве имён оно может быть использовано без квалификации. Но в отличии от блоков скобок они могут быть поименованы и тогда переменная или функция с квалификацией может быть использована где угодно

\lstinputlisting[firstline=8,lastline=17]{cpp_code/p1s5.cpp}

Здесь приведён пример неименованного пространства имён (по русски это звучит странно, мы будем часто говорить ``анонимное пространство имён''). Объявленные в анонимном пространстве имён функции доступны только в текущем модуле -- этим они похожи на функции, объявленные с модификатором \lstinline!static! 

В пространстве имён buz у нас есть доступ к \lstinline!foo::y!. Также можно избежать необходимости постоянно ставить некий префикс (скажем std) если включить это пространство имён в текущее с помощью директивы using. Этой директивой можно включить и одно имя и целое пространство.

Когда компилятор видит, например, вызов функции, имя этой функции он будет искать:
\begin{itemize}
\item
сначала в области видимости вызова и текущем пространстве имён
\item
далее в пространствах имён аргументов, включая их классы и все базовые классы
\end{itemize}

Этот трюк называется ``поиск Кёнига''\index{Kenig search} по имени человека, который его придумал и ввёл в стандарт C++98.

\lstinputlisting[firstline=19,lastline=28]{cpp_code/p1s5.cpp}

Впрочем, если компилятор встречает вызов фукции из функции-члена некоего класса, то иные члены этого класса и его родительских имеют приоритет над функциями, найденными на основании информации о типах аргументов.

Любая стандартная функция в C++ принадлежит пространству имён std. Каждый раз писать \lstinline!std::printf! или \lstinline!std::memcpy! бывает накладно. Чтобы этого избежать, добавьте строчку \lstinline!using namespace std!\index{using} после включения хедеров. Директива \lstinline!using some_name! также может применяться чтобы внести из произвольного пространства имён только одно имя.

\lstinputlisting[firstline=1,lastline=10]{cpp_code/p1s6.cpp}

Поиск Кёнига не срабатывает для имён, которые компилятор считает известными

\begin{lstlisting}
typedef int f;

namespace N {
  struct A;
  int f(A*);
}

int g(N::A *a)
{
  int i = f(a);
  /* f is the typedef, not the N::f
     function: equivalent to int(a) */
  return i;
}
\end{lstlisting}

Без верхнего \lstinline!typedef! всё сработало бы прекрасно, но в его присутствии, компилятор не будет искать функцию \lstinline!f!, полагая, что здесь написано преобразование к типу \lstinline!int!.

\subsection{Мелкие отличия C-подмножества C++ от ISO C}

\begin{itemize}
\item
Функция \lstinline!main()! в C++ не может быть вызвана из пользовательского кода. В языке C это разрешено, хотя и несколько необычно.
\item
Прототипы функций обязательны в C++, но опциональны в C.
\item
Сложная и развитая система инициализации в C обычно не работает в C++

\begin{lstlisting}
struct T {
    union {
        struct {
            int x, y, z;
        };
        int xyz[3];
    };
    int a;
};

struct T v = { { .x = 1, .y = 2, .z = 3}, 4 };
struct T w = { { .xyz[0] = 1, .xyz[1] = 2, .xyz[2] = 3}, 4 };
struct T x[] = { [0].a = 1, [1].a = 2 };
\end{lstlisting}

Такой код инициализации легален в C и совершенно нелегален в C++
\item
Имена, определяемые через \lstinline!typedef! не могут совпадать с существующими именами структур в C++, но могут в C (последний требует явной квалификации \lstinline!struct!).
\item
При присвоении к \lstinline!void *! указателю указателя на иной тип, C++ требует приведения (C не требует, но оно считается хорошим тоном).
\item
C++ вводит более десяти новых ключевых слов. Они могут быть использованы как идентификаторы в программе на C, но компилятор C++ выдаст ошибку.
\item
В языке C++ объявление переменной может появится везде, где может быть выражение; в C, объявления должны быть в начале блока.
\item
Имя структуры или объединения во внутренней области видимости скроет такое же имя любой переменной во внешней области видимости в C++, но не в C.
\item
У символьных литералов тип char в C++, но тип int в C. То есть \lstinline!sizeof('a')! даёт 1 в C++, но может дать большее значение в C.
\end{itemize}

\pagebreak
\subsection{Домашняя наработка по второй части}
\begin{enumerate}
\item
Дана структура данных, воплощающая простой односвязный список

\begin{lstlisting}
typedef struct list_tag
{
  void *data;
  struct list_tag *next;
} list_t, *list_p;
\end{lstlisting}

У последнего элемента \lstinline!next = 0!

Необходимо написать на языке C++ функцию, берущую на вход указатель на голову списка и переворачивающую список в памяти, так, что первый элемент становится последним, второй предпоследним и так далее.

\item
Дана программа на языке C с комментариями вида \lstinline!/* comment */!

Необходимо написать на языке C++ программу, выкидывающую все комментарии из текста данной.

\item
Дана структура данных, соответствующая n-арному дереву

\begin{lstlisting}
typedef struct tree_tag
{
  void *data;
  struct tree_tag *top;
  struct tree_tag **childs;
} tree_t, *tree_p;
\end{lstlisting}

Реализуйте на языке C++ функцию, берущую на вход пару указателей на произвольные элементы дерева, и подсчитывающую расстояние между ними (минимальный путь в дереве). Как вы будете тестировать эту функцию?

\item
Реализуйте на языке C++ алгоритм из (\ref{AlgDecl}) и протестируйте на нескольких сотнях сгенерированных определений

\item
Реализуйте на языке C++ транспонирование двумерной матрицы

\item
Реализуйте на языке C++ операцию получения двумерной матрицы обратной данной

\item
Реализуйте на языке C++ операцию умножения вектора на матрицу

\item
Реализуйте на языке C++ калькулятор считающий в обратной польской нотации. Например \lstinline!1 2 3 4 + * + =! должно выдавать 25 в качестве результата.

\item
Известны год, месяц и день рождения человека. Реализуйте на языке C++ программу, определяющую его возраст в днях на текущую дату.

\item
Реализуйте на языке C++ программу, подсчитывающую количество лет в 20-м веке у которых первым днём было воскресенье

\item
На вход дана строка из \lstinline!N*N! символов. Реализуйте на языке C++ функцию, выделяющую в памяти двумерную матрицу \lstinline!N*N! и заполняющую её последовательными данными из входной строки.

\item
На вход даны завершающаяся нулём строка \lstinline!haystack! и завершающаяся нулём строка \lstinline!needle!. Реализуйте на языке C++ функцию, определяющую, является ли \lstinline!needle! подстрокой \lstinline!haystack!

\item
В условиях предыдущей задачи необходимо доработать функцию, чтобы она выкидывала из \lstinline!haystack! все вхождения \lstinline!needle! и возвращала измененную строку.

\item
Напишите на C++ программу, которая будет возвращать номер в последовательности Фибоначчи первого числа имеющего 1000 разрядов в десятичном представлении.

\end{enumerate}

\pagebreak
\section{Объектно-ориентированное счастье}

Как известно самой целью создания C++ Бьёрном Строструпом было добавление ОО-возможностей к C, поэтому изначально язык назывался ``C с классами''. Известно что Строструп вдохновлялся языком Simula, но сейчас уже нельзя оценить насколько это была удачная идея, поскольку этот язык канул в лету. С другой стороны, известному гуру ООП, Кенту Беку, приписывается высказывание: ``Это я придумал термин \textit{объектно-ориентированный} и я не имел в виду C++''. Так или иначе, но C++ действительно обладает уникальной среди современных ОО-языков моделью объявления и инстанциирования классов. Многим нравится богатство и гибкость её возможностей, многие в ужасе отползают. Впрочем, давайте начнём с основ.

\subsection{Структуры в C и в C++, POD и NPOD\index{POD}\index{NPOD}}

В языке C структура являлась способом ввести пользовательский тип, являющийся механическим объединением разнородных данных:

\lstinputlisting[firstline=1,lastline=12]{cpp_code/p2s1.cpp}

Такие типы возможны и в C++ и они называются POD-типами (от английского Plain Old Data). Но в C++ была также добавлена принципиально новая возможность группировать данные с методами их обработки внутри структуры:

\lstinputlisting[firstline=1,lastline=13]{cpp_code/p2s2.cpp}

Получившийся тип (собственно ``not POD-тип'' или ``NPOD-тип'') несколько удобнее в работе. Но при этом теряются гарантии по расположению в памяти и размерам (которые с учётом выравнивания и в C в общем-то были довольно призрачными). Обратите внимание что в C++ была исключена необходимость добавлять \lstinline!struct! к символьному имени структуры, что делает ненужным оставшийся в C-style коде \lstinline!typedef! тэга структуры на её имя.

Кстати имя метода \lstinline!transpose_pair! структуры \lstinline!pair_t! в C++ также будет манглировано (вспоминаем прошлую лекцию) и в ассемблере встретится, например в виде:

\begin{lstlisting}[language=make]
_Z14transpose_pair4pair:
\end{lstlisting}

Определённая так функция называется методом. Объявление метода происходит внутри определения структуры, определение метода имеет явную квалификацию того к чему метод относится. Обратите внимание, что символ сдвоенных двоеточий такой же, как и в случае пространств имён. Он дословно означает пространство имён, задаваемое структурой.

Использование \lstinline!this! внутри метода позволяет получить данные той структуры, для которой метод был вызван, так что нам не надо специфицировать исходную структуру как параметр. Его использование можно опустить.

\subsection{Инкапсуляция и игра в мячик}

Представим, что вас попросили разработать тип данных, который будет использован для моделирования полёта материальной точки в двумерном мире (высота, длина). Мяч может лететь свободно, для чего у него вызывается метод \lstinline!fly(double t)! или его можно толкнуть, придав ему определённую скорость под определённым углом (после чего например опять отправить в полёт и так далее). Вы напишете нечто вроде:

\lstinputlisting[firstline=14,lastline=23]{cpp_code/p2s1.cpp}

Представляет ли эта структура данных абстракцию мяча, о которой вас просили? Нет, не представляет. Каждый пользователь вашего ``мяча'' может произвольно менять его координаты. Это означает, что в плохо отлаженной программе симуляции, ваш мяч сможет свободно ``телепортироваться'', а это явно не то, чего ждут от законченной модели. 

\lstinputlisting[firstline=29,lastline=36]{cpp_code/p2s1.cpp}

Хуже того, время может быть свободно переставлено вперёд или назад. Но пусть даже никто не ошибся и всё написано правильно. А потом... возникла необходимость ``запустить'' ваш мяч в многопользовательской среде. Всё пропало – для того, чтобы вставить синхронизацию, переписывать придётся каждый участок кода где ссылались на эти поля.

\subsubsection{Конкретные классы}

Для разграничения состояния модели от её поведения и более гибкого управления поведением, в C++ были введены классы. Простые классы, без использования полиморфизма и без иерархий наследования, называются ``конкретными классами''. Конкретные классы -- мощный и полезный инструмент для поддержания консистентности абстракции. Перепишем модель мяча, создав его класс

\lstinputlisting[firstline=43,lastline=54]{cpp_code/p2s1.cpp}

Модификатор \lstinline!public! означает, что любой пользователь типа \lstinline!ball_t! имеет доступ к этим методам или данным. 

Модификатор \lstinline!private! означает, что доступ к соответствующим методам и данным имеют только методы этого класса.

\lstinputlisting[firstline=58,lastline=74]{cpp_code/p2s1.cpp}

Хорошим тоном считается закрывать данные, составляющие состояние объекта и открывать функции, составляющие его поведение.

Обратите внимание на опущенный \lstinline!this! в коде \lstinline!ball_t::push!, это допустимо.

\subsubsection{Инициализация и уничтожение\index{constructor}\index{destructor}}

Отсутствие доступа к состоянию означает, что при создании объекта он должен уметь сам установить своё состояние, а при уничтожении – освободить свои ресурсы. Для этого в класс вводятся конструктор и деструктор – специальные функции, вызывающиеся при создании и уничтожении объекта. Например у класса мяча, конструктор может устанавливать начальное положение, деструктор же может быть тривиальным.

\lstinputlisting[firstline=18,lastline=21]{cpp_code/p2s2.cpp}

Обратите внимание на список инициализации у конструктора в этом примере кода. Можно, конечно, написать инициализацию в теле конструктора, но использование списков инициализации является лучшей идеей. По умолчанию, удовлетворяющий стандарту языка C++ компилятор позаботится о вас, сгенерировав вам конструктор и деструктор по умолчанию (позднее мы поговорим о степени этой заботы и её оборотных сторонах). Конструктор по умолчанию вызывает конструкторы всех членов класса, у которых они есть, деструктор -- их деструкторы.

\subsubsection{Неявное преобразование типов и explicit}

Важная тема в конструкторах это их использование для задания неявного преобразования типа\index{implicit type cast}. Неявные преобразования есть и в C, там они называются type promotions, некоторые из них (действуют и в C++) сведены в таблицу ниже (здесь anytype это любой встроенный тип, совместимый по операции но не перечисленный выше):

\begin{lstlisting}
anytype `op` long double => long double `op` long double
anytype `op` double => double `op` double
anytype `op` float => float `op` float
anytype `op` unsigned long long => unsigned long long `op` unsigned long long
anytype `op` long long => long long `op` long long
anytype `op` unsigned long => unsigned long `op` unsigned long
anytype `op` long => long `op` long
anytype `op` unsigned int => unsigned int `op` unsigned int
anytype `op` int => int `op` int
\end{lstlisting}

Но в C++ неявные преобразования также пробуются компилятором для пользовательских типов. Определение в пользовательском типе конструктора, который может быть истрактован как конструктор с одним аргументом (считая аргументы по умолчанию частично подставленными всюду кроме первого аргумента), считается определением неявного преобразование из аргумента конструктора к этому типу. Это может иметь неприятные последствия:

\lstinputlisting[firstline=26,lastline=31]{cpp_code/p2s2.cpp}

Верный способ определить конструктор, чтобы явно заявить компилятору, что он не поддерживает неявного преобразования это определить его с ключевым словом \lstinline!explicit!

\lstinputlisting[firstline=12,lastline=13]{cpp_code/p2s3.cpp}

Это важное решение при проектировании и его надо принимать осознанно. Лепить \lstinline!explicit! куда ни попадя -- дурной тон (скажем это ключевое слово возможно но совершенно не нужно на конструкторе более чем с одним аргументом и без аргументов по умолчанию). Но иногда он очень нужен.

\subsubsection{Value-инициализация и Default-инициализация}

POD и NPOD типы требуют разной обработки. Когда пользователь пишет

\begin{lstlisting}
int *t = new int; /* t uninitialized */
int *pt = new int [10]; /* pt[.] uninitialized */
\end{lstlisting}

Он не ожидает, что будет вызвано десять конструкторов для целых чисел. Вместо этого ожидаемое поведение это десять неинициализированных объектов.

\begin{lstlisting}
struct SomePOD
{
  int x;
};

SomePOD *px = new SomePOD; /* x uninitialized */
\end{lstlisting}

Аналогично никакого конструктора не будет вызвано и в этом случае. Но немного изменим структуру:

\begin{lstlisting}
struct SomeNPOD
{
  int x;
  ~SomeNPOD() {;}
};

SomeNPOD *px = new SomeNPOD; /* x initialized with 0 */
\end{lstlisting}

Поскольку в этой структуре есть деструктор, она теперь NPOD и для неё будет сгенерирован конструктор по умолчанию. Для того, чтобы сделать у POD-типов такое же поведение, разработчики языка предусмотрели указание пустых скобок для value-initialization:

\begin{lstlisting}
struct SomePOD
{
  int x;
};

SomePOD *px = new SomePOD (); /* x initialized with 0 */
int *t = new int (); /* t initialized with 0 */
int *pt = new int [10](); /* 10 ints are initialized with 0 */
\end{lstlisting}

Это создаёт некоторую запутанность, зато даёт некий аналог \lstinline!calloc! для C++ POD-типов. 

\subsubsection{Селекторы}

Отражает ли созданная до сих пор абстракция физический мяч? Всё ещё нет. Мяч в физическом мире обычно виден пользователю, у которого есть возможность считать его координаты. То есть нам нужны некоторые методы, которые будут, сохраняя состояние мяча, давать возможность прочитать его. Такие методы традиционно называются селекторами.

\lstinputlisting[firstline=16,lastline=18]{cpp_code/p2s3.cpp}

Обратите внимание на const в их объявлении. Внутри объявленного таким образом метода изменить любое поле класса это ошибка компиляции. Исключение составляют поля, объявленные с mutable.

Хорошим тоном является делать селектором любой метод, который теоретически может быть селектором и по логике не должен менять внутреннего состояния объекта.

\subsubsection{Статические константы в классе\index{static members}}

Задумаемся над реализацией метода \lstinline!fly!. Очевидно, нам понадобится ускорение свободного падения. Логично сделать его константой общей для каждого экземпляра класса \lstinline!ball_t!, но при этом закрытой, так как это его деталь реализации.

Пишем объявление:

\lstinputlisting[firstline=9,lastline=9]{cpp_code/p2s3.cpp}

Определяем вне определения класса:

\lstinputlisting[firstline=26,lastline=26]{cpp_code/p2s3.cpp}

И теперь можно написать код полёта:

\lstinputlisting[firstline=35,lastline=42]{cpp_code/p2s3.cpp}

И мяч полетит. 

Вообще спецификатор \lstinline!static! в классах используется для объявления статических членов, то есть таких атрибутов и методов, которые являются методами и атрибутами класса, а не объекта. Подобно константе \textbf{g}, все статические члены которые нуждаются в инициализации должны быть определены вне определения класса.

\subsubsection{Объявления и определения классов}

Это важный момент, перекликающийся с затронутой на прошлой лекции темой объявлений и определений. Объявление класса как неполного типа выглядит так:

\begin{lstlisting}
class ball_t;
\end{lstlisting}

С этого момента тип \lstinline!ball_t! можно использовать по правилам, прописанным в стандарте для неполных типов. Определение класса это объявление всех его методов и полей.

Но внутри определения класса, каждое объявление поля, статического поля или метода это его объявление. Определением нестатического члена считается конструктор класса (поэтому если членом класса является ссылка она должна быть инициализирована в списке инициализации конструктора). Определение метода может как встречаться внутри класса, так и быть вынесено вне его. Определение статического объекта всегда должно быть вне класса.

Давайте сведём всё воедино.

\subsubsection{Игра в мячик (код)}\label{BallGame}

\lstinputlisting{cpp_code/p2s3.cpp}

\pagebreak
\subsection{Классы для управления ресурсами}

В идеальном мире, программа производит чистые вычисления над неограниченным входным потоком и записывает результаты в неограниченный выходной поток. Реальный мир вносит коррективы: хорошо написанная программа всегда работает в условиях недостаточности машинных ресурсов и должна сама заботиться о том, чтобы рационально управлять запросами и освобождением ресурсов. До сих пор основным видом ресурсов с которыми вы сталкивались была динамическая память. Хорошо написанная программа рационально выделяет себе нужное количество динамической памяти и вовремя её освобождает. Возможность тонкого ручного управления ресурсами -- важная особенность языков C и C++

Вопрос студентам: какие ещё вы знаете ресурсы.

Ожидаемые ответы: файловые дескрипторы, мьютексы, шрифты и кисти, объекты гуя, соединения с бд, сокеты.

Что общего у всех этих ресурсов? Как правило -- наличие парных команд для запроса и освобождения. 
Скажем это: 
\begin{itemize}
\item
\lstinline!new! и \lstinline!delete! для динамической памяти, 
\item
\lstinline!fopen! и \lstinline!fclose! для файлов, 
\item
\lstinline!mysql_real_connect! и \lstinline!mysql_close! для запросов MySQL C API, 
\item
\lstinline!pthread_mutex_init! и \lstinline!pthread_mutex_destroy! для работы с мьютексами в POSIX. 
\end{itemize}

В общем случае мы имеем некую функцию \textbf{query} запрашивающую ресурс и функцию \textbf{release} освобождающую его. Если ресурс имеет семантику общего владения, добавляется ещё функция \textbf{addref}, добавляющая ресурсу пользователя, но в общем это уже экзотика. Ограничимся пока моделью из функций \textbf{query} и \textbf{release}. Рассмотрим типичный код на C-подмножестве C++, работающий с выделением динамической памяти и дополнительно неким ещё ресурсом \lstinline!res_t!

\begin{lstlisting}
int
foo (int n)
{
  int *a = new int[n];
  res_t other = query ();
  /* ... some code ... */
  if (condition1)
    {
      delete [] a;
      release (other);
      return FAILURE1;      
    }
  /* ... some code ... */
  if (condition2)
    {
      delete [] a;
      release (other);
      return FAILURE2; 
    }
  /* ... some code ... */
  if (condition3)
    {
      delete [] a;
      release (other);
      return FAILURE3;
    }
  delete [] a;
  release (other);
  return SUCCESS;
}

\end{lstlisting}

В этом коде очевидна проблема с проектированием: код освобождения дублируется многократно, часто в непредсказуемых местах. Сначала рассмотрим какие выходы обычно используются в legacy code на языке C или подобных ему.

Как ни странно, лучший выход, официально применяемый в ядре Linux, \url{https://www.kernel.org/doc/Documentation/CodingStyle}, Chapter 7, это использование в таких случаях \lstinline!goto!

\begin{lstlisting}
int
foo (int n)
{
  int *a = new int[n];
  res_t other = query ();
  int errcode = SUCCESS;

  /* ... some code ... */
  if (condition1)
    {
      errcode = FAILURE1;
      goto cleanup;
    }
  /* ... some code ... */
  if (condition2)
    {
      errcode = FAILURE2;
      goto cleanup;
    }
  /* ... some code ... */
  if (condition3)
    {
      errcode = FAILURE3;
      goto cleanup;
    }

cleanup:
  delete [] a;
  release (other);
  return errcode;
}

\end{lstlisting}

Вообще при упоминании \lstinline!goto! люди нехорошо напрягаются. Использование таких конструкций в языках высокого уровня некрасиво и отчасти может приводить к проблемам, описанным ещё Дейкстрой.

Вариантом первого выхода является \lstinline!do-while hack!, который позволяет организовать \lstinline!goto! без \lstinline!goto!:

\begin{lstlisting}
int
foo (int n)
{
  int *a = new int[n];
  res_t other = query ();
  int errcode = SUCCESS;

  do {
    /* ... some code ... */
    if (condition1)
      {
        errcode = FAILURE1;
        break;
      }
    /* ... some code ... */
    if (condition2)
      {
        errcode = FAILURE2;
        break;
      }
    /* ... some code ... */
    if (condition3)
      {
        errcode = FAILURE3;
        break;
      }
  } while (0);

  delete [] a;
  release (other);
  return errcode;
}

\end{lstlisting}

Этот поучительный код организует цикл нулевой длины, эксплуатируя возможности языка по принудительному выходу из таких циклов. Он выглядит криво и косо, но, бывает, встречается. Таких мест не надо пугаться -- люди просто боялись \lstinline!goto! и этот страх породил чудовищ.

Второй выход известен как вложенная функция -- логика отдаётся в особую функцию, управление ресурсами которой происходит извне. Такой подход также можно часто встретить в открытом коде, например в GCC. Для приведенного примера это будет:

\begin{lstlisting}
int
foo1 (int *a, int n, res_t other)
{
  /* ... some code ... */
  if (condition1)
    return FAILURE1;

  /* ... some code ... */
  if (condition2)
    return FAILURE2;

  /* ... some code ... */
  if (condition3)
    return FAILURE3;

  return SUCCESS;
}

int
foo (int n)
{
  int *a = new int[n];
  res_t other = query ();

  int errcode = foo1 (a, n, other);

  delete [] a;
  release (other);
  return errcode;
}

\end{lstlisting}

Но этот метод имеет свои недостатки – он как минимум создаёт лишний вызов функции и запутывает код. ``Всего лишь ещё одна'' обёрточная функция прощённая себе десять раз это плюс десять уровней косвенности при отладке.

Третий выход известен как oksofar trick, от английского ``Ok so far'' == ``Всё пока что [идёт] хорошо''. Он предлагает рассматривать функцию как последовательность состояний:

\begin{lstlisting}
int
foo (int n)
{
  int *a = new int[n];
  res_t other = query ();
  int errcode = SUCCESS;
  int oksofar = 1;

  /* ... some code ... */

  if (oksofar)
    {
      /* ... some code ... */
      if (condition1)
        {
          errcode = FAILURE1;
          oksofar = 0;
        }
    }

  if (oksofar)
    {
      /* ... some code ... */
      if (condition2)
        {
          errcode = FAILURE2;
          oksofar = 0;
        }
    }

  if (oksofar)
    {
      /* ... some code ... */
      if (condition3)
        {
          errcode = FAILURE3;
          oksofar = 0;
        }
    }

  delete [] a;
  release (other);
  return errcode;
}

\end{lstlisting}

Этот ужас также можно наблюдать в реальных проектах.
Если на C это ещё как-то работает, то в C++ исключения добавляют огня (об этом будет отдельный разговор на одной из следующих лекций) и все эти выходы для C++ просто не работают в общем случае.

\subsubsection{Идиома RAII\index{RAII}}\label{RAII}

Создатели языка C++ прекрасно знали все эти трюки языка C и применяли их не по разу. Но зная их, они их не любили. 

Поэтому в современном C++ при программировании очень часто используют важную идиому – идиому обёрточного класса \textbf{Resource Aquistion Is Initialization} сокращённо RAII (выделение ресурса это инициализация), создавая для каждого ресурса обёрточный объект, в котором ресурс будет захвачен в конструкторе и освобождён в деструкторе. Эта же идиома расширяется на так называемые ``умные указатели'' о которых разговор пойдёт позднее.

Проще всего

\begin{lstlisting}
struct Buffer
{
  Buffer (int n) : m_a (new int[n]) {};
  ~Buffer () {delete [] m_a;}
  int *ptr() const {return m_a;}
private:
  int *m_a;
};

struct Resource
{
  Resource () : m_res(query()) {};
  ~Resource () {release(m_res)};
  const res_t &res() const {return m_res;}
private:
  res_t m_res;
};

int
foo (int n)
{
  Buffer a(n)
  Resource other;

  /* ... some code ... */
  if (condition1)
    return FAILURE1;

  /* ... some code ... */
  if (condition2)
    return FAILURE2;

  /* ... some code ... */
  if (condition3)
    return FAILURE3;

  return SUCCESS;
}

\end{lstlisting}

Обратите внимание на то как элегантно выделение и освобождение ресурсов теперь поисходят только в те моменты когда они должны происходить. Но в разработанных выше классах \lstinline!Buffer! и \lstinline!Resource! есть одна общая важная уязвимость, которая будет пояснена далее.

\subsubsection{Переопределение копирования}\label{CopyConstr}

Но сначала немного теории. Интересный объект рассмотрения -- пустой, сферический класс в вакууме.

\lstinputlisting[firstline=3,lastline=3]{cpp_code/p2s10.cpp}

Так ли он пуст, как это кажется на первый взгляд? Совершенно очевидно, что даже объект такого совершенно пустого класса в программе на C++ может быть создан, создан по образцу, скопирован и разрушен. Всю эту обвязку, если её не предоставляете вы, предоставляет компилятор C++. То есть написанное определение эквивалентно следующему:

\lstinputlisting[firstline=7,lastline=14]{cpp_code/p2s10.cpp}

Конструктор и деструктор должны быть к этому моменту уже понятны. Но мы видим, что C++ генерирует ещё две функции специального вида – копирующий конструктор\index{copy constructor}, отвечающий за создание объекта по образцу такого же и оператор присваивания\index{assignment operator}, который будет вызван при присваивании объекта в выражениях вида \lstinline!a=b!.

\lstinputlisting[firstline=20,lastline=22]{cpp_code/p2s10.cpp}

По умолчанию сгенерированные компилятором конструктор копирования и оператор присваивания просто побитово копируют код аргумента в целевой объект. Разумеется, это не пройдёт если в классе есть член-ссылка, тогда вы должны писать оператор присваивания самостоятельно.

\textbf{Домашняя наработка:} объяснить почему присваивание по умолчанию не годится при членах класса, являющихся ссылками.

Иногда такое умолчательное поведение приводит к мрачным проблемам, тяжёлым в отладке. Предположим, вы написали некий класс, управляющий внутренним буфером, который выделяется в конструкторе и освобождается в деструкторе.

\lstinputlisting[firstline=30,lastline=38]{cpp_code/p2s10.cpp}

А потом кто-то по незнанию создал буфер по его образцу внутри какой-то функции.

\lstinputlisting[firstline=40,lastline=44]{cpp_code/p2s10.cpp}

Что при этом произойдёт? Выделенный вами буфер доступен по указателю. Указатель будет побитово скопирован. Это значит что теперь на буфер есть два указателя. При выходе за границы блока оба будут освобождены. Это крайне неприятная ошибка двойного освобождения, которое является UB.

\begin{figure}[h!]
\centering
\includegraphics[width=0.6\textwidth]{illustrations/copying-crop.pdf}
\caption{Ошибка двойного освобождения}
\label{fig:copying-crop}
\end{figure}

Говорят, что по умолчанию C++ реализует поверхностное копирование (shallow copy\index{shallow copy}). Копирование с выделением нового буфера и копированием в него содержимого старого это глубокое копирование (deep copy\index{deep copy}) которое пользователь всегда должен реализовать самостоятельно. Ниже показано переопределение копирующего конструктора, о переопределении операторов и в частности оператора присваивания см. (\ref{OperatorOverloading})

\begin{lstlisting}
class CCopyableBuffer {
public:
  CCopyableBuffer(int size) { m_size = size; m_buffer = new char[size]; }
  ~CCopyableBuffer() { delete[] m_buffer; }
  CCopyableBuffer(const CCopyableBuffer& rhs) { 
    m_size = rhs.m_size; m_buffer = new char[m_size];
    memcpy(m_buffer, rhs.m_buffer, m_size);
  } 
  char &get(int x) { assert(x >= 0 && x < m_size); return m_buffer[x]; } 
private:
  char *m_buffer;
  int m_size;
};
\end{lstlisting}

Так всё будет работать. Но иногда копирование не нужно и его проще запретить, объявив собственные конструктор копирования и оператор присваивания в закрытой части класса.

\lstinputlisting[firstline=67,lastline=77]{cpp_code/p2s10.cpp}

Теперь компилятор не сгенерирует за вас неправильные варианты и копирование просто не будет скомпилировано.

\textbf{Домашняя наработка:} поясните или опровергните мысль: ``именно из-за проблемы двойного освобождения, в C++ нет и не может быть простого аналога realloc''

\subsubsection{Оптимизации возвращаемого значения\index{RVO}}\label{RVO}

RVO или оптимизация возвращаемого значения, прописана в стандарт C++ (например 12.3.2.15 для С++98) и она гласит, если коротко, что компилятор имеет право не вызывать копирующие конструкторы если он может статически доказать, что объекты эквивалентны.

Пример:

\begin{lstlisting}
#include <cstdio>

using namespace std;

class foo {
public:
  foo () { printf ("foo::foo()\n"); }
  foo (const foo&) { printf ("foo::foo( const foo& )\n"); }
  ~foo () { printf ("foo::~foo()\n"); }
};

foo
bar()
{
  foo local_foo;
  return local_foo;
}

int
main()
{
  foo f = bar();
  return 0;
}
\end{lstlisting}

В случае если GCC компилирует этот код без RVO (опция \lstinline!-fno-elide-constructors!), вывод на экран выглядит как:

\begin{lstlisting}
foo::foo()
foo::foo( const foo& )
foo::~foo()
foo::foo( const foo& )
foo::~foo()
foo::~foo()
\end{lstlisting}

Последовательность очевидна: создаётся локальный \lstinline!local_foo!, создаётся его копия -- возвращаемое значение, уничтожается \lstinline!local_foo!, возвращаемое значение копируется в \lstinline!f!, уничтожается возвращаемое значение, уничтожается \lstinline!f!.

В случае же обычной компиляции с RVO, вывод выглядит гораздо проще:

\begin{lstlisting}
foo::foo()
foo::~foo()
\end{lstlisting}

Эта экономия разрешена стандартом и поэтому программист не должен закладываться на то, что его конструктор копирования всегда будет вызван в контексте копирования.

\subsection{Перегрузка\index{overload} операторов\index{operator}}\label{OperatorOverloading}

Язык C++ позволяет переопределять для пользовательских типов почти все операторы, которые применимы для встроенных типов, включая арифметические, логические, а также некоторые специального вида операторы. В прошлом разделе уже встречалось упоминание переопределения присваивания. Рассмотрим класс, абстрагирующий матрицу $N*M$ для $N>1, M>1$.

Вопрос к студентам: написать у доски то, что они уже знают:

\begin{lstlisting}
class Matrix
{
public:
  Matrix (int n, int m) : m_n (n), m_m (m), m_buf (new int[n*m]()) {}
  ~Matrix () { delete [] m_buf; }

  Matrix (const Matrix &rhs) : m_n (rhs.m_n), m_m (rhs.m_m), m_buf (new int[m_n * m_m])
    {
      std::memcpy (m_buf, rhs.m_buf, rhs.m_n * rhs.m_m * sizeof (int));
    }

  void set (int x, int y, int val) { m_buf[x*m_m + y] = val; }
  int get (int x, int y) { return m_buf[x*m_m + y]; }

private:
  int m_n, m_m;
  int *m_buf;
};
\end{lstlisting}

Допустим, хотелось бы написать сложение матриц:

\begin{lstlisting}
/* adds rhs to this and returns new sum matrix */
Matrix
Matrix::add (const Matrix &rhs)
\end{lstlisting}

Тогда мы могли бы его использовать:

\begin{lstlisting}
Matrix m, n, t;
...
t.assign (m.add (n));
\end{lstlisting}

Это не так красиво, как если бы мы могли писать:

\begin{lstlisting}
t = m + n;
\end{lstlisting}

И С++, как мы увидим дальше, даёт нам переопределить операторы, такие как \lstinline!+!, \lstinline!=! и многие другие, чтобы добиться такой непосредственности в выражении мыслей.

Главная проблема здесь в том, что вы действительно вольны написать любой код в определении оператора сложения. Ваше сложение не обязано удовлетворять даже каким-то базовым инвариантам сложения:

\begin{lstlisting}
assert (a + b == b + a); /* ORLY? */
\end{lstlisting}

Вместо этого ваша операция сложения может осуществлять вычитание, лезть в базу данных или форматировать диск. Почти всегда, когда вы читаете код на C++, вы обязаны иметь в виду, что не можете быть уверены что значит операция \lstinline!+! этим утром. Ночью кто-нибудь мог вкоммитить в неё чудовищные изменения – из лучших побуждений, разумеется.

Всё усугубляется тем, что общий список операторов, которые можно переопределить, крайне внушающ. Его всегда можно посмотреть в стандарте, но кроме основных арифметических и логических операций, определение которых довольно таки прямолинейно, перегрузке могут подвергаться совершенно экзотические вещи – сравнение, присваивание, приведение к типу (любому, включая встроенные), обращение по указателю и даже выделение памяти с помощью new и её освобождение. Давайте побеседуем об нескольких специальных и проблематичных случаях переопределённых операторов.

\subsubsection{Переопределение операций, формирующих цепочки}\label{ChainOps}

Первый особый случай, это операторы, которые могут быть записаны цепочками (обычно -- правоассоциативными). Скажем, пользователь оператора \lstinline!=!, скорее всего ожидает корректной работы строчки:

\begin{lstlisting}
x = y = z = w;
\end{lstlisting}

распространяющей, значение \lstinline!w! справа налево. Рассмотренный в (\ref{CopyConstr}) буфер может и должен быть расширен определение оператора равенства, который для того, чтобы такая цепочка могла быть сформирована, должен возвращать ссылку на текущий объект

\begin{lstlisting}
  CCopyableBuffer& operator= (const CCopyableBuffer& rhs)
  {
    if (&rhs == this) return *this;
    delete [] m_buffer;
    m_size = rhs.m_size; m_buffer = new char[m_size];
    memcpy(m_buffer, rhs.m_buffer, m_size);
    return *this;
  }
\end{lstlisting}

Особое внимание следует обратить на проверку \lstinline!if (&rhs == this)! в начале. Вторым способом написать эту проверку будет: \lstinline!if (rhs == *this)!

\textbf{Домашняя наработка:} почему второй способ может привести к некорректному и неожиданному поведению?

Большинство цепочечных операций: \lstinline!+=!, \lstinline!*=! и так далее, являются прямыми модификаторами состояния класса и должны быть определены в классе, чтобы у них был \lstinline!this! для возврата.

\subsubsection{Переопределение симметричных бинарных операций}\label{SymmBinary}

Можно рассмотреть ещё один пример -- разработку класса, реализующего абстракцию комплексных чисел.

Для того, чтобы абстракция комплексных чисел была завершённой, должна быть возможность неявного преобразования double в complex, ведь по сути число \lstinline!2.0! это \lstinline!2.0 + 0.0 * i!. Эта возможность заложена в конструкторе класса (вспоминаем, что конструктор с одним аргументом это неявное преобразование типа).

\lstinputlisting[firstline=36,lastline=37]{cpp_code/p2s8.cpp}

Но здесь таится и опасность, потому что сложение перестаёт быть коммутативным и простая запись, вида:

\lstinputlisting[firstline=39,lastline=40]{cpp_code/p2s8.cpp}

Выдаст ошибку компиляции. Ошибка связана с тем, что неявные преобразования применяются только к параметрам, перечисленным в списке параметров. Поэтому \lstinline!a.operator+(2.0)! преобразует \lstinline!double! к \lstinline!Complex!, но для \lstinline!(2.0).operator+(a)! неявный параметр \lstinline!this! -- указатель на объект для которого вызывается метод, не подвергается, согласно стандарту, никаким неявным преобразованиям.

Правильный метод: определить операторы сложения и умножения вне класса как отдельные функции:

\lstinputlisting[firstline=8,lastline=29]{cpp_code/p2s8c.cpp}

Точно так же необходимо поступать со всеми функциями, которые по определению должны быть коммутативными. Тогда коммутативность будет сохранена.

Очень часто бинарные операции можно определить вне класса в терминах цепочечных операций, определенных в классе:

\begin{lstlisting}
Complex operator+ (Complex a, Complex b)
{
  Complex tmp = a;
  tmp += b;
  return tmp;
}
\end{lstlisting}

На самом деле, это предпочтительный метод. Он кроме всего прочего позволяет естественным образом сохранить когерентность \lstinline!+! и \lstinline!+=! или в общем случае -- цепочечной и соответствующей ей бинарной операции.

\subsubsection{Переопределение инкремента и декремента}\label{IncrOverload}

Язык C++ получил своё название от унарной операции \lstinline!x++!, которая увеличивает значение переменной в данном случае x, и возвращает старое значение. Такая операция называется постинкрементом. Известен также прединкремент \lstinline!++x!, который увеличивает свой аргумент и возвращает увеличенное значение.

\begin{lstlisting}
class Complex
{
public:
  Complex& operator++ ()
    {
      re += 1.0;
      return *this;      
    }
/*...*/
};
\end{lstlisting}

Такая запись возвращает прединкремент, он совсем простой. Постинкремент в терминах прединкремента может быть определен вот так:

\begin{lstlisting}
Complex operator++ (int unused)
{
  Complex result = *this;
  ++(*this);
  return result;
} 
\end{lstlisting}

Очевидно, что прединкремент в общем случае не требует копирования, которое, как мы уже выяснили может быть очень дорогим. Поэтому очень часто программисты на C++ используют именно прединкремент в циклах:

\begin{lstlisting}
for (Complex t = 1.0; t < 5.0; ++t) { ... }
\end{lstlisting}

вместо

\begin{lstlisting}
for (Complex t = 1.0; t < 5.0; t++) { ... }
\end{lstlisting}

Обычно замеры показывают что такая запись не несет какого-то особого выигрыша. Она просто показывает, что человек знает внутреннюю механику языка.

\subsection{Управление выделением и освобождением памяти}\label{MemManage}

Переопределение \lstinline!new! и \lstinline!delete! это всегда отдельная и крайне неприятная тема. Она связана с несколькими неочевидными ограничениями и десятком подводных камней. В общем случае, если вам понадобилось переопределять \lstinline!new! и \lstinline!delete!, подумайте ещё раз, может быть вы что-то сделали не так.

\subsubsection{Отличия \lstinline!new! и \lstinline!malloc!}

Есть два отличия \lstinline!new! от \lstinline!malloc! -- первое функциональное и второе идеологическое. 

С идеологической точки зрения, есть только одна пара глобaльных функций \lstinline!std::malloc! и \lstinline!std::free!, но при этом кроме соответствующей ей пары глобальных \lstinline!new! и \lstinline!delete!, существует также возможность переопределить выделение и освобождение памяти для каждого пользовательского типа.

С функциональной точки зрения можно говорить только об отличиях глобальных функций \lstinline!::operator new! и \lstinline!::operator delete! от глобальных функций \lstinline!std::malloc! и \lstinline!std::free!

Итак, \lstinline!std::malloc! и \lstinline!std::free! отличаются тем, что:

\begin{enumerate}
\item
Память аллоцируется из кучи (``Heap'')
\item
Возвращаемое значение имеет тип \lstinline!void*!
\item
При неудаче \lstinline!malloc! возвращает \lstinline!NULL!
\item
Требуют спецификации точного размера в байтах
\item
Выделение массива требует ручного подсчёта места на массив
\item
Перевыделение памяти просто (нет вызова копирующих конструкторов)
\item
Никогда не вызовут из себя \lstinline!new! или \lstinline!delete!
\item
Нет способа автоматически побить запрашиваемую память на более мелкие участки при нехватке памяти на большой линейный кусок
\item
Не могут быть легально переопределены ни в каком случае
\end{enumerate}

В отличие от них, \lstinline!::operator new! и \lstinline!::operator delete! имеют следующие свойства:

\begin{enumerate}
\item
Память аллоцируется из свободного хранилища (``Free Store''). Совпадает ли оно с кучей (``Heap'') упомянутой выше или это два разных места -- Implementation defined. Обычно в Unix совпадает, так как используется системный вызов sbrk, но есть варианты.
\item
Возращаемое значение -- типизированный указатель
\item
Обычно выбрасывает исключения при неудаче (см. ниже про специальные формы)
\item
Размер памяти вычисляется компилятором исходя из данного типа
\item
Есть версия специально для массивов
\item
Перевыделение памяти сложно (из-за вызова конструкторов) и стандартно не поддерживается
\item
Вызовет ли из себя \lstinline!malloc! и \lstinline!free! зависит от реализации
\item
Поддерживает установку аллокатора для случая исчерпания памяти через \lstinline!set_new_handler!
\item
Могут быть легально переопределены для пользовательских типов
\item
Использует конструкторы и деструкторы для инцииализации и уничтожения объектов
\end{enumerate}

Наверное нет смысла заучивать эти отличия наизусть, но вместе они составляют консистентную картину, которую нужно понимать.

\subsubsection{Стандартные и специальные формы \lstinline!new!}\label{PlacementNew}

Рассмотрим типичное выделение памяти в программе на C++:

\begin{lstlisting}
class Widget {};
...
Widget *w = new Widget;
\end{lstlisting}

Предположим, оператор \lstinline!new! не переопределён для класса \lstinline!Widget!

Что здесь происходит? Неожиданно много всего.

\begin{enumerate}
\item
Сначала, по форме оператора new, компилятор определяет какой именно new имеется в виду. Существуют три нормальные формы new:
\begin{itemize}
\item
new в куче с возбуждением исключений при исчерпании памяти. Именно он использован в рассматриваемом примере.
\item
new в куче с возвратом нуля при исчерпании памяти
\item
placement new (размещающий \lstinline!new!)\index{placement new} (с размещением в заданном месте). Именно он и был использован в листинге выше. Его синтаксис похож на выделяющий new из этого примера, но буфер, в котором размещается сконструированный объект, не выделяется, а передаётся как параметр в скобках.
\end{itemize}

Кроме нормальных существуют ещё и специальные формы new, когда пользователь некоего типа переопределяет размещающий new этого типа передавая ему не область памяти, а нечто иное -- скажем область памяти и поток для записи лога и т.п. В следующем листинге показано использование разных форм new.

\begin{lstlisting}
class Widget {};
...
Widget *w = new Widget;
Widget *w = new (std::nothrow) Widget;
Widget *w = new (WidgetPool) Widget;
Widget *w = new (WidgetPool, WidgetLogStream) Widget;
\end{lstlisting}

Здесь первая строчка это \lstinline!malloc!+вызов конcтруктора с возбуждением исключения при ошибке выделения, вторая строчка это \lstinline!malloc!+вызов конcтруктора без возбуждения исключения при ошибки выделения (тогда в \lstinline!w! просто запишется \lstinline!NULL!), третья строчка это просто вызов конструктора на уже выделенную память (при этом неудачи выделения быть, разумеется, уже не может). И четвёртая строчка иллюстрирует специальную пользовательскую форму оператора \lstinline!new! и не будет у вас скомпилирована, без специальных объявлений внутри класса \lstinline!Widget!.

\item
Далее компилятор выделяет память в куче (строго при необходимости, размещающие и специальные формы пропускают этот пункт) и в случае нехватки памяти вызывает пользовательский обработчик, который можно поставить и на стандартное выделение с помощью \lstinline!set_new_handler!.
\item
Далее в случае если вызвана нормальная форма неразмещающего new, компилятор вызывает конструктор размещённого в куче объекта или все конструкторы, если был размещён массив.
\item
Разрушение происходит в обратном порядке.
\end{enumerate}

Обычный сценарий работы \lstinline!malloc()! для выделения буфера, вместе с размещающим new для явного вызова конструктора приведён ниже:

\lstinputlisting{cpp_code/p2s9.cpp}

Обратите внимание -- деструктор может быть вызван явно.

\subsubsection{Переопределение \lstinline!new! и \lstinline!delete!}

Ниже приведен класс для которого объявлены переопределения всех нормальных форм \lstinline!new!/\lstinline!delete! как это сделано в \cite{effcpp3d}.

\begin{lstlisting}
class StandardNewDeleteForms {
public:
static void *operator new(std::size_t size);
static void operator delete(void * memory);
static void *operator new(std::size_t size, const std::nothrow_t &nt);
static void *operator new(std::size_t size, void *ptr);
};
\end{lstlisting}

\textbf{Домашняя наработка:} Напишите и протестируйте код для каждого из переопределений.

C++ предоставляет достаточно тонкий инструментарий для работы с памятью, который необходимо использовать с осторожностью. Переопределяя каждый оператор не забывайте о возможном пользовательском вызове \lstinline!set_new_handler!. Переопределяя \lstinline!new! не забывайте переопределять соответсвующий \lstinline!delete!. Работайте с памятью осторожно и внимательно. И главное -- трижды подумайте нужно ли вам это вообще.

\subsection{Наследование интерфейса\index{Inheritance}\index{Interface inheritance}}

Программа, в которой важной абстракцией является физический объект, иногда подразумевает сложные архитектурные решения, относительно представления этого объекта. Координаты нужны (почти) всем физическим объектам, но как быть с массой, с радиусом, с электрическим зарядом, с любыми дополнительными параметрами? Конечно можно написать один тип со всем богатством возможностей внутри него

\begin{lstlisting}
class AnyPhysicalBody
{
private:
  double x, y, z;
  double vx, vy, vz;
  double m;
  double r;
/* ... */
public:
  int move (double dt);
};
\end{lstlisting}

Но создавать объект такого типа, когда нужна всего лишь материальная точка с массой -- означает тащить за собой массу ненужных полей с произвольными и не нужными значениями. Это называется overhead -- пустая трата памяти и машинного времени. Вторая возможность -- написать небольшие конкретные типы на каждый случай:

\begin{lstlisting}
class CelestialBody
{
  double x, y;
  double vx, vy
  double m;
public:
/* ... */
  int move (double dt);
  int apply_force (double f, double dt);
};

class Planet
{
  double x, y;
  double vx, vy
  double m;
  double r;
public:
/* ... */
  int move (double dt);
  int apply_force (double f, double dt);
  int detect_collision (const Planet *rhs) const;
  int detect_collision (const CelestialBody *rhs) const;
};
\end{lstlisting}

Это работает, но возникают две проблемы: методы \lstinline!detect_collision! внутри класса \lstinline!Planet! дублируются (это не страшно, но может быть неприятно) и гораздо более печальная проблема -- принципиально разные типы \lstinline!Planet! и \lstinline!CelestialBody! теперь не могут быть объединены, скажем в массив указателей на небесные тела. Решение этой проблемы состоит в том, чтобы указать компилятору на \textbf{общий интерфейс} или на то, что планета тоже является небесным телом (и материальной точкой).

\subsubsection{Чисто виртуальные функции и абстрактные базовые классы}\label{PureVirtual}

Интерфейсным или чисто абстрактным является пользовательский тип, в котором определён хотя бы один \textbf{чисто виртуальный} метод. Ключевое слово \lstinline!virtual! предусматривает довольно сложное поведение и будет подробно рассмотрено в (\ref{VirtualUnderHood}). Чисто виртуальные методы легко различать по спецификации \lstinline!=0!. Хорошим тоном является писать тип, полностью состоящий из таких методов.

\begin{lstlisting}
struct ICelestialBody
{
  virtual double get_x () const = 0;
  virtual double get_y () const = 0;
  virtual int move (double dt) = 0;
  virtual int apply_force (double f, double dt) = 0;
};
\end{lstlisting}

Объекты такого типа нельзя создавать, его методы не могут иметь реализации. Это общий интерфейс -- обещание того, что все реализующие его пользовательские типы реализуют две именно такие функции. Такое обещание пользовательский тип может дать через механизм открытого наследования интерфейса.

\begin{lstlisting}
class CelestialBody: public ICelestialBody
{
  double x, y;
  double vx, vy;
  double m;
public:
/* ... */
/* ICelestialBody implementation */
  double get_x () const { return x; }
  double get_y () const { return y; }
  int move (double dt); 
  int apply_force (double f, double dt);
/* ... */
};
\end{lstlisting}

Синтаксис открытого наследования очевиден из примера. Указание модификатора \lstinline!public! обязательно, поскольку наследование может быть и иным см. (\ref{OtherInheritance}). Для выражения идиомы ``реализация интерфейса'' подходит только открытое наследование. 

\begin{lstlisting}
class Planet: public ICelestialBody
{
  double x, y;
  double vx, vy;
  double m;
  double r;
public:
/* ... */
/* ICelestialBody implementation */
  double get_x () const { return x; }
  double get_y () const { return y; }
  int move (double dt);
  int apply_force (double f, double dt);
  int detect_collision (const ICelestialBody &rhs) const;
};
\end{lstlisting}

Разумеется, каждый класс может открыто наследовать от любого количества интерфейсов, но на данном этапе имеет смысл ограничиться одиночным наследованием, отложив рассмотрение обобщений до (\ref{MultipleInheritance}).

Визуально открытое наследование интерфейса представляет UML-диаграммой следующего вида:

\begin{figure}[h!]
\centering
\includegraphics[width=1.0\textwidth]{illustrations/inhdiag.pdf}
\caption{Открытое наследование интерфейса}
\label{fig:inheritance-interface}
\end{figure}

Теперь можно писать довольно абстрактный код, использующий приведение указателя или ссылки на объект, к указателю или ссылке на его открытый интерфейс. Как обычно сначала полезно написать небольшую служебную функцию:

\begin{lstlisting}
int 
in_between (double x, double ymin, double ymax)
{
  return (x <= ymax) && (x >= ymin);
}
\end{lstlisting}

И определить

\begin{lstlisting}
int 
Planet::detect_collision (const ICelestialBody &rhs) const
{
  return in_between (rhs.get_x(), x - r, x + r) && 
         in_between (rhs.get_y(), y - r, y + r);
}
\end{lstlisting}

Совершенно неважно с чем мы проверяем столкновение, если это ``что-то'' поддерживает все методы \lstinline!ICelestialBody!:

\begin{lstlisting}
Planet Jupiter;
Planet Earth;
CelestialBody Gallea;
/* .. */

Earth.detect_collision(Jupiter); 
Earth.detect_collision(Gallea);
\end{lstlisting}

Это похоже на общий разъём розетки, куда в стандартный интерфейс можно подключить много разных уcтройств.

\subsubsection{Статический и динамический тип\index{Dynamic type}}

Функция \lstinline!Planet::detect_collision! вызывает внутри себя виртуальную функцию \lstinline!ICelestialBody::get_x()! которая имеет один неявный аргумент -- указатель \lstinline!this! того объекта, для которого она вызвана. Этот указатель протягивается через формальный аргумент. 

Что можно сказать об аргументе \lstinline!rhs!? Всего лишь, что его тип, объявленный в списке аргументов (иначе говоря статический тип) это константная ссылка на \lstinline!ICelestialBody!. Это всё, что компилятор может сказать об этом типе \textbf{статически}, без контекста исполнения.

Но \textbf{динамически}, при вызове из \lstinline!main!, функция \lstinline!detect_collision! вызывается из двух разных мест с двумя разными параметрами, один из которых имеет тип \lstinline!Planet!, другой – тип \lstinline!CelestialBody! и именно эти типы имеет указатель \lstinline!this! для которого вызывается \lstinline!get_x()! в первом и во втором случае.

При вызове функции, она должна быть верно связана с именем типа, поскольку имя типа участвует в манглированном имени функции, как это объяснялось в (\ref{NameResolution}). При обычном вызове функции или метода, она связывается со своим типом статическим или ранним связыванием. Динамическое или позднее связывание работает при вызове виртуальной функции по ссылке или указателю на интерфейс. При этом решение о том какая функция в действительности будет вызвана, откладывается до момента вызова и принимается на основании её динамического типа. Обычно это требует дополнительного уровня косвенности для вызова через таблицу виртуальных методов, которая будет рассмотрена в (\ref{VirtualUnderHood}).

Если при динамическом связывании, функция имеет аргумент, который может принимать значения разных динамических типов с которыми она вызвана, этот аргумент называется \textbf{полиморфным} аргументом для динамического полиморфизма, а сама функция -- полиморфной (динамически полиморфной) функцией. В случае любой виртуальной функции единственный её полиморфный аргумент -- неявный указатель на объект, для которого она вызвана.

Вообще говоря, динамический тип может быть разрешен и в абстрактный класс. При этом производится попытка прямого вызова чисто виртуальной функции. Это ошибка, но язык C++ всегда даёт программисту возможность выстрелить себе в ногу, это фирменный стиль. Поэтому важно знать тот случай, когда это наиболее часто может произойти.

\subsubsection{Проблема срезки\index{Cutting}}\label{Cutting}

Можно ещё раз рассмотреть функцию \lstinline!detect_collision!, на этот раз остановившись на её параметрах. Аргумент \lstinline!rhs! передан в неё по константной ссылке. В принципе, он мог бы быть передан и по обычной ссылке и по (константному) указателю:

\begin{lstlisting}
int 
Planet::detect_collision (const ICelestialBody *rhs)
{
  return in_between (rhs->get_x(), x - r, x + r) && 
         in_between (rhs->get_y(), y - r, y + r);
}
\end{lstlisting}

Но крайне дурным тоном (и в случае абстрактного класса -- ошибкой компиляции) является передача аргументов по значению.

\begin{lstlisting}
Planet::detect_collision (const ICelestialBody rhs) /* Error */
\end{lstlisting}

Это происходит от того, что формальные аргументы, переданные по значению конструируются при входе в функцию. Попытка сконструировать объект абстрактного класса (то есть класса, содержащего хотя бы один чисто виртуальный метод) сама по себе ошибочна. Хорошо, пусть даже это удалось. В этом случае новосконструированный объект \lstinline!rhs! будет иметь динамический тип \lstinline!ICelestialBody! независимо от динамического типа аргументов. В этом случае вызов функции \lstinline!get_x()! будет связан с чисто виртуальной заглушкой интерфейса и в лучшем случае программа выйдет по ошибке. 

Этот срез информации при передаче по значению называется ``проблемой срезки''. Срезка часто возникает в практических контекстах и важно о ней помнить.

Но тогда возникает вопрос -- что такого магического в ссылках и указателях, что при передаче по ним динамический тип сохраняется? Для этого нужно заглянуть как всё устроено под капотом.

\subsubsection{Подробнее о чисто виртуальных функциях}\label{VirtualUnderHood}

Чтобы понять, что именно делает компилятор для того, чтобы вызов по указателю на интерфейс делегировался верному динамическому типу, полезно попробовать написать нечто подобное на C.

Сначала определяется таблица виртуальных методов

\begin{lstlisting}
typedef double (get_t)(void *);

struct celestial_body_vmt
{
  get_t *pget_x;
  get_t *pget_y;
/* ... */
};
\end{lstlisting}

Дальше указатель на эту таблицу идёт в структуру интерфейса:

\begin{lstlisting}
struct icelestial_body
{
  struct celestial_body_vmt vtable;
  /* ... */
};
\end{lstlisting}

Инициализация VMT происходит в конструкторе интерфейса:

\begin{lstlisting}
void
icelestial_ctor(struct icelestial_body *ths, get_t *pget_x, get_t *pget_y)
{
  ths->vtable.pget_x = pget_x;
  ths->vtable.pget_y = pget_y;
  /* ... */
}
\end{lstlisting}

Каждый класс-наследник содержит в себе интерфейсную часть и собственную реализацию интерфейсных функций:

\begin{lstlisting}
struct celestial_body
{
  struct icelestial_body intf;
  double x, y;
  /* ... */
};

double celestial_get_x(void *ths) { return ((struct celestial_body *)ths)->x; }
double celestial_get_y(void *ths) { return ((struct celestial_body *)ths)->y; }
\end{lstlisting}

Конструктор класса-наследника устанавливает известные ему функции в таблицу виртуальных функций интерфейсного класса:

\begin{lstlisting}
void 
celestial_ctor(struct celestial_body *ths)
{
  icelestial_ctor (&ths->intf, &celestial_get_x, &celestial_get_y);
  /* ... */  
}
\end{lstlisting}

Теперь всё готово для того, чтобы правильно сконструированный объект наследника мог участвовать в обобщённом коде наподобие уже рассмотренного collision detection (для простоты мы не будем рассматривать написание также планеты, а примем столкновение двух небесных тел как прохождение их на расстоянии epsilon):

\begin{lstlisting}
int
detect_collision (struct icelestial_body *lhs, struct icelestial_body *rhs)
{
  double x = lhs->vtable.pget_x(lhs);
  double y = lhs->vtable.pget_y(lhs);
 
  return in_between (rhs->vtable.pget_x(rhs), x - epsilon, x + epsilon) && 
         in_between (rhs->vtable.pget_y(rhs), y - epsilon, y + epsilon);
}
\end{lstlisting}

Вызов этого кода требует конструирования (вручную, поскольку мы пишем на C). Скажем:

\begin{lstlisting}
struct celestial_body Gallea;
struct celestial_body Encke;

celestial_ctor (&Gallea);
celestial_ctor (&Encke);

/* ... */

detect_collision (&Gallea.intf, &Encke.intf);
\end{lstlisting}

Таким образом, очевидно насколько много компилятор C++ прячет под капот. Знание механики работы виртуальных функций необязательно, но часто и очень сильно помогает. Например теперь проблема срезки становится ясна. Если передача параметров внутрь \lstinline!detect_collision! идёт по значению, то они должны быть сконструированы внутри функции. Но поскольку у \lstinline!icelestial_body! нет собственных координат и нет методов, чтобы их вернуть, то единственное, что можно передать в такой конструктор это нули:

\begin{lstlisting}
int
detect_collision (struct icelestial_body lhs, struct icelestial_body rhs)
{
  double x, y;
  
  icelestial_ctor (&lhs, 0, 0);
  icelestial_ctor (&rhs, 0, 0);

  x = lhs->vtable->pget_x();
  y = lhs->vtable->pget_y();
 
  return in_between (rhs->vtable->pget_x(), x - epsilon, x + epsilon) && 
         in_between (rhs->vtable->pget_y(), y - epsilon, y + epsilon);
}
\end{lstlisting}

И тогда вызов чисто виртуальной функции превращается в аналог вызова функции по нулевому указателю. При передаче же по указателю мы имеем просто приведение типа к указателю другого типа, без потери данных. Подобным образом работает и передача по ссылке в C++. Есть ещё несколько поучительных уроков: наличие дополнительного расхода памяти в каждом объекте на таблицу виртуальных функций, наличие дополнительной косвенности по вызову, ухудшение возможностей компилятора для инлайн-подстановки довольно простых методов и так далее -- всё это очевидно при понимании того, как вещи функционируют на самом деле.

Теперь самое время разобрать несколько хитрых вопросов, относящихся к наследованию интерфейса:

\subsubsection{Параметры по умолчанию\index{default arguments} и чисто виртуальные функции\index{virtual}}

Тонкий вопрос, который многие программисты на C++ часто упускают из виду это то, как ведут себя виртуальные функции с параметрами по умолчанию. Если параметр по умолчанию в интерфейсе изменён в одном из его наследников:

\begin{lstlisting}
struct ICelestialBody
{
/* ... */
  virtual int apply_force (double f, double dt = 0.1) = 0;
};

void 
forcesApply (ICelestialBody *pbody, double *pfs, int n)
{
  for (; n > 0; --n)
    pbody->apply_force(pfs[n - 1]);
}

class CelestialBody: public ICelestialBody
{
public:
/* ... */
  int apply_force (double f, double dt = 0.01);
};
\end{lstlisting}

После чего этот обобщённый код вызван для конкретного динамического типа:

\begin{lstlisting}
double fs[5] = {1.0, 1.5, 1.2, 1.8, 1.10};
CelestialBody t;
forcesApply (&t, fs, 5);
\end{lstlisting}

Казалось бы -- реально будет вызвана функция \lstinline!CelestialBody::apply_force! и логично ожидать значение аргумента по умолчанию как он выставлен там. Но в реальности эта функция будет вызвана со значением аргумента по умолчанию, выставленного в интерфейсе.

Дело в том, что функции в C++ связываются динамически, а аргументы по умолчанию – статически. Если вернуться к сишному аналогу, можно легко увидеть, что в таблице виртуальных функций нет места для хранения и перезаписи аргументов по умолчанию.

\subsubsection{Виртуальные деструкторы}\label{virtdestr}

Для программиста на C++ важно знать один очень специальный случай полиморфизма, относящийся к семантике освобождения, а именно виртуальные деструкторы. Рассмотрим пример – пусть у нас есть фабричная функция, которая в зависимости от радиуса желаемого пользователем небесного тела возвращает \lstinline!CelestialBody! если он меньше порогового значения или планету в другом случае:

\begin{lstlisting}
ICelestialBody *get_celestial_body (double r)
{
  if (r < epsilon)
    return new CelestialBody ();

  return new Planet ();
}
\end{lstlisting}

Что произойдёт если планета была получена через эту функцию, а потом удалена из памяти обычным способом?

\begin{lstlisting}
ICelestialBody *planet = get_celestial_body (100.0);
/* ... */
delete planet;
\end{lstlisting}

Будет освобождена базовая часть, но не будет освобождена производная часть, что неминуемо приведёт к утечкам памяти и проблемам. 

Решение этой проблемы: сделать деструктор виртуальным в интерфейсе. Тогда будет автоматически правильно вызван деструктор производного класса по указателю на базовый.

\begin{lstlisting}
struct ICelestialBody
{
  virtual double get_x () const = 0;
  virtual double get_y () const = 0;
  virtual int move (double dt) = 0;
  virtual int apply_force (double f, double dt) = 0;
  virtual ~ICelestialBody() {}
};
\end{lstlisting}

Следует обратить внимание, что виртуальный деструктор, несмотря на то, что он пустой, не может быть чисто виртуальным. Это связано с тем, что производный класс должен при уничтожении иметь возможность вызвать деструктор базового класса.

Наличие в классе невиртуального деструктора является в мире промышленного программирования достаточным основанием никогда ничего не наследовать от этого класса. Обратное – дурной тон. 

Но, с другой стороны, наличие в абстрактном интерфейсе исполнимых функций, делает его уже не таким абстрактным и закономерно возникает вопрос: а что если размещать в базовых классах общие поля, реализацию общих методов, переопределения операторов. Всему этому посвящен следующий раздел.

\pagebreak
\subsection{Наследование реализации}

Разработанные в (\ref{PureVirtual}) классы-наследники \lstinline!CelestialBody! и \lstinline!Planet! всё ещё имеют слишком много дублирующегося кода: общие поля координат и скоростей, общие и притом идентичные селекторы координат. Это обычная и, более того, достаточно частая ситуация. Для уменьшения дублирования в классе \lstinline!Planet!, мы можем заметить, что планета также \textbf{является} небесным телом, отличаясь только тем, что у неё имеет значение радиус и есть дополнительный метод для определения столкновений. Это отношение ``быть частным случаем'' также, как и отношение ``реализовать интерфейс'' моделируется открытым наследованием, но в данном случае унаследована будет и реализация некоторых методов и поля класса \lstinline!CelestialBody!, такие как \lstinline!x! и \lstinline!y!. Общий интерфейс тот же:

\begin{lstlisting}
struct ICelestialBody
{
  virtual double get_x () const = 0;
  virtual double get_y () const = 0;
  virtual int move (double dt) = 0;
  virtual int apply_force (double f, double dt) = 0;
  virtual ~ICelestialBody() {}
};
\end{lstlisting}

Пользовательский тип \lstinline!CelestialBody! всё так же реализует общий интерфейс:

\begin{lstlisting}
class CelestialBody: public ICelestialBody
{
protected:
  double x, y;
  double vx, vy;
  double m;
public:
/* ... */
/* ICelestialBody implementation */
  double get_x () const { return x; }
  double get_y () const { return y; }
  int move (double dt); 
  int apply_force (double f, double dt);
/* ... */
};
\end{lstlisting}

Новое ключевое слово \lstinline!protected! сообщает, что все помеченные им поля при открытом наследовании будут доступны производным классам.

Пользовательский тип \lstinline!Planet! сообщает, что является уточнением \lstinline!CelestialBody!:

\begin{lstlisting}
class Planet: public CelestialBody
{
  double r;
public:
  int detect_collision (const ICelestialBody &rhs) const;
};
\end{lstlisting}

Теперь есть необходимость определить расстояние между небесными телами. Соответствующий обобщённый код:

\begin{lstlisting}
double 
get_distance (const ICelestialBody &lhs, const ICelestialBody &rhs)
{
  double xdist = lhs.get_x() - rhs.get_x();
  double ydist = lhs.get_y() - rhs.get_y();

  return sqrt (xdist*xdist + ydist*ydist);
}
\end{lstlisting}

Вполне может быть вызван так:

\begin{lstlisting}
Planet Jupiter;
Planet Earth;

/* ... */

double d = get_distance (Jupiter, Earth);
\end{lstlisting}

Несмотря на то, что функций \lstinline!Planet::get_x! и \lstinline!Planet::get_y! попросту не существует, у класса \lstinline!Planet! тем не менее есть эти методы, унаследованные от класса \lstinline!CelestialBody!. Внутри функции \lstinline!Planet::get_distance!, динамический тип \lstinline!Planet! аргумента \lstinline!lhs! позволяет сделать вызов общей для \lstinline!Planet! и \lstinline!CelestialBody! функции, которая изменяет их общую открытую часть.

Существенное отличие открытого наследования от наследования интерфейса -- класс не только даёт обещание, что будет поддерживать тот или иной интерфейс, но ещё и заимствует у базового класса конкретную реализацию, оставляя себе только уточнение специфичных для себя методов. Эта техника существенно улучшает переиспользование кода и может быть в произвольной пропорции смешана с чисто абстрактными классами: например вполне можно было бы внести координаты и их селекторы в интерфейсный класс, у которого в этом случае появилась бы часть интерфейса который наследники должны реализовать (чисто виртуальные функции) и часть реализации, которая просто наследуется для использования. Впрочем смешивать такие вещи -- не всегда полезно.

Теперь UML-диаграмма становится несколько более иерархичной

\begin{figure}[h!]
\centering
\includegraphics[width=0.3\textwidth]{illustrations/indiag2.pdf}
\caption{Открытое наследование}
\label{fig:inheritance-implementation}
\end{figure}

Можно заметить, что сверху вниз по этой диаграмме, более общие понятия предшествуют более частным. Скажем ``конкретное небесное тело'' это ``небесное тело вообще'', а планета это и то и другое. При открытом наследовании все открытые члены базового класса доступны как открытые члены производного класса, а также работает неявное преобразование типа от производного к базовому классу. Говорят, что открытое наследование \textbf{моделирует} отношение ``is-a'', при котором объект производного класса является объектом базового класса (в том смысле, в каком планета является небесным телом).

\subsubsection{Закрытое и защищенное наследование}\label{OtherInheritance}

Существенно иначе обстоят дела с закрытым наследованием. При закрытом наследовании, неявного преобразования типа от производного к базовому не задаётся, а все открытые методы базового класса становятся закрытыми методами производного класса, как показано в таблице ниже:

\begin{center}
  \begin{tabular}{ | l | c | c | r | }
    \hline
    modifier & public & protected & private \\ \hline \hline
    public & public & protected & private \\ \hline
    protected & protected & protected & private \\ \hline
    private & private & private & private \\ \hline
  \end{tabular}
\end{center}

Говорят, что закрытое наследование моделирует отношение part-of (быть частью).


Упомянуть про закрытое и защищённое наследование. Объяснить что закрытое это такая композиция (и поэтому лучше делать явную композицию), а защищённое вообще никто не знает зачем нужно.

\subsubsection{Конструкторы базовых классов}

При конструировании каждого класса будут неявно вызваны конструкторы его базовых классов по умолчанию, если они не вызваны явно в списке инициализации. Но в последнем случае, необходимо понимать, что время жизни объекта начинается после того, как отработал его конструктор. Это означает, что следующий код (хотя и корректен с точки зрения языка) не верен:

\lstinputlisting[firstline=1,lastline=12]{cpp_code/p2s7.cpp}

Здесь сразу две ошибки. Во-первых попытка вызвать метод \lstinline!f()! базового подобъекта, который ещё не сконструирован в этой точке (поскольку только вызывается его конструктор). Это может прокатить, может нет, но это в любом случае некорректно. Во-вторых попытка инициализировать и потом использовать ещё не существующий член производного класса (до конструирования которого там пока вообще далеко).

Не следует допускать таких ошибок в своём коде.

\subsection{Принципы объектно-ориентированного программирования}\index{SOLID}

При использовании объектно-ориентированного программирования, на практике оказывается полезным придерживаться некоторых принципов

\subsubsection{Принцип единственной обязанности}\index{SRP}

Не только классы и объекты занимаются инкапсуляцией данных. На языке C, данные могут быть инкапсулированы в модуль (объявлены в нём статическими переменными и функциями) и программист, использующий такой модуль, будет оперировать только его открытым интерфейсом. Данные могут быть инкапсулированы и в обычных функциях, когда локальные переменные внутри функции безопасны относительно изменений извне. Общее понятие, определяющее совокупность ``своих'' данных, используемых для неких ``своих'' целей называется \textbf{контекст}.

Принцип единственной обязанности гласит, что каждый контекст должен выделять единственную обязанность и полностью инкапсулировать всё, относящееся к деталям её выполнения.

Этот принцип должен останавливать руку каждого человека, который захочет добавить в класс CelestialBody поддержку имитации разумной жизни, или открыть извне доступ к инкапсулированным внутри CelestialBody координатам небесного тела.

\subsubsection{Принцип открытости и закрытости}\index{OCP}

В своей простейшей формулировке он звучит так: ``каждый контекст должен быть открыт для расширения, но закрыт для изменения''. Это означает, что при наличии контекста, корректно выполняющего одну обязанность, разработка контекста, выполняющего обязанность, которая расширяет данную, исходный код первого контекста должен быть переиспользован, но не изменен. Это особенно значимо в производственной среде, когда изменения в исходном коде потребуют проведение пересмотра кода, модульного тестирования и других подобных процедур, чтобы получить право на использования его в программном продукте. Код, подчиняющийся данному принципу, не изменяется при расширении и поэтому не требует таких трудозатрат.

\subsubsection{Принцип подстановки Лисков}\index{LSP}

И реализация интерфейса и открытое наследование реализации это на самом деле одно и то же фундаментальное отношение, которое в англоязычной литературе называется ``is-a'', а по-русски -- специализацией. Есть некая терминологическая несогласованность в том, как называть классы выше и ниже по иерархии наследования. Многие из предлагаемых в современной литературе вариантов, ``родитель'' и ``наследник'', или, скажем, ``суперкласс'' и ``подкласс'', кажутся вводящими в заблуждение. Далее классы, стоящие выше по иерархии, будут называться \textbf{базовыми} для классов, стоящих ниже, а классы стоящие ниже в иерархии -- \textbf{производными} от стоящих выше.

Отношение обобщения и специализации в правильно спроектированной иерархии классов должно подчиняться ``принципу подстановки'', сформулированному Барбарой Лисков в \cite{LSP}. Суть этого принципа в том, что любое свойство объектов базового класса должно быть верно и для объектов производного класса. Иначе говоря, любая функция, работающая с объектом базового класса, должна работать и с любым объектом производного класса. Поскольку удовлетворящий LSP наследник может быть \textbf{подставлен} в контекст, где использован базовый класс, этот принцип называется принципом подстановки.

Самый простой пример нарушения принципа подстановки -- перегрузка виртуальных функций базового класса невиртуальными функциями наследника. Более сложные примеры его применения будут рассмотрены ниже.

\subsubsection{Принцип разделения интерфейса}\index{ISP}

Самая простая его формулировка была дана Робертом Мартином в \cite{ISP} и звучит так: ``Клиенты не должны зависеть от методов, которые они не используют''

Принцип разделения интерфейсов говорит о том, что слишком ``толстые'' интерфейсы необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе. В итоге, при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют.

\subsubsection{Принцип инверсии зависимостей}\index{DIP}

Обычный способ думать о зависимостях между модулями -- это рассмотрение зависимостей высокоуровневых модулей от низкоуровневых. Принцип инверсии разворачивает зависимость и гласит, что:

\begin{enumerate}
\item Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
\item Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
\end{enumerate}

\subsubsection{Закон Деметры}\index{Demeter Law}

Перечисленные выше пять принципов входят в пятёрку SOLID, предложенную Робертом Матрином. Кроме SOLID-принципов, известны другие, в частности Закон Деметры, который гласит: ``Объект A не должен иметь возможность получить непосредственный доступ к объекту C, если у объекта A есть доступ к объекту B и у объекта B есть доступ к объекту C''. Чтобы понять его совсем просто, можно сказать ``Наездник должен управлять лошадью, а не ногами лошади''.

Преимуществами закона Деметры является то, что код, разработанный с соблюдением данного закона, делает написание тестов более простым, а разработанное программное обеспечение менее сложно при поддержке и имеет большие возможности повторного использования кода. Так как объекты являются менее зависимыми от внутренней структуры других объектов, контейнеры объектов могут быть изменены без модификации клиентов.

\subsubsection{Проблемы, возникающие при проектировании открытого наследования}

Принцип подстановки Лисков требует навыка при работе с ним. Предположим, вы проектируете иерархию геометрических объектов и столкнулись с необходимостью расположить в ней такие абстракции как ``квадрат'' и ``прямоугольник''. Первой мыслью может быть унаследовать прямоугольник от квадрата – в конце концов прямоугольник вводит ещё одно поле и может быть какие-нибудь дополнительные методы

\lstinputlisting[firstline=3,lastline=20]{cpp_code/p2s11.cpp}

Но такой подход создаёт проблемы, связанные с тем, что прямоугольник не является частным случаем квадрата и здесь нарушается принцип подстановки. 

Вопрос к студентам: опишите проблемы которые может вызвать такое проектирование. Например рассмотрите реализованную в \lstinline!Square! (и даже виртуальную) функцию \lstinline!void increase(int times)!, в times раз увеличивающую площадь квадрата. Как вы реализуете её для прямоугольника?

\subsection{Динамическое приведение\index{dynamic\_cast} и RTTI\index{RTTI}}

Кроме всех операторов приведения, рассмотренных в предыдущей лекции, существует ещё один, разработаный специально, чтобы приводить статический тип к динамическому типу. Он называется \lstinline!dynamic_cast!. Его интересной особенностью является то, что он по-разному работает для указателей и для ссылок. Сначала разберём \lstinline!dynamic_cast! для указателей

\begin{lstlisting}
Derived* temp = dynamic_cast<Derived*>(base);
\end{lstlisting}

Пытается привести p, типа \lstinline!Base*! к типу \lstinline!Derived*!, где \lstinline!Base! и \lstinline!Derived! принадлежат одной и той же иерархии. Если \lstinline!Derived! является базовым классом для \lstinline!Base!, то это ничем не отличается от \lstinline!static_cast!. Но \lstinline!dynamic_cast! работает также если Base является полиморфным базовым классом для \lstinline!Derived!, то есть является базовым классом для \lstinline!Derived! и содержит виртуальные функции. Звучит запутано? Давайте посмотрим пример.

\lstinputlisting{cpp_code/p2s13.cpp}

Что будет на выдаче? Ответ:

\begin{lstlisting}[language=make]
You are Dart Veider!
You are not Dart Veider, you are Pokemon
\end{lstlisting}

Коротко говоря, \lstinline!dynamic_cast!, использованый для указателя даёт возможность ``спросить'' такой ли у этой переменной динамический тип, как он полагает. Он приводит к этому типу если ответ ``да'' или возвращает \lstinline!NULL!, если ответ ``нет''.

При использовании \lstinline!dynamic_cast! для ссылок, вопрос превращается в утверждение. Если это утверждение нарушается, кидается исключение, но о них мы поговорим в другой раз.

Для \lstinline!dynamic_cast! очень важно, чтобы в базовом классе была хотя бы одна виртуальная функция. Очень часто отличным кандидатом на роль такой функции является виртуальный деструктор, о котором мы сейчас поговорим.

\subsection{Иерархии}\label{MultipleInheritance}

Продолжим разговор о наследовании. До сих пор рассматривалось только одиночное одноуровневое наследование, но C++ даёт в этом отношении гораздо больше свободы. Один класс может наследовать многим классам, которые сами кому-то наследуют и так далее. Для этого базовые классы с их модификаторами доступа перечисляются через запятую

\begin{lstlisting}
class Man: public AnimalsWithTwoLegs, public OnesWithoutWings {};
\end{lstlisting}

Это позволяет строить иерархии взаимодействующих классов и объектов при проектировании сложных программных систем.

\begin{figure}[h!]
\centering
\includegraphics[width=0.8\textwidth]{illustrations/hierarchies-crop.pdf}
\caption{Иерархии классов и объектов}
\label{fig:hierarchies-crop}
\end{figure}

Проектирование хорошей иерархии это всегда сложный инженерный процесс, выходящий за рамки этого курса. Зато можно на игрушечных примерах рассмотреть основные проблемы, ожидающие разработчика на этом пути.

\subsubsection{Ромбовидные схемы и виртуальные базовые классы}

Предположим, вы проектируете систему, поддерживающую абстракции файлов ввода и вывода. Рано или поздно вы пришли к чему-то вроде такого

\begin{lstlisting}
class File {};
class InputFile : public File {};
class OutputFile : public File {};
class IOFile : public InputFile, public OutputFile {};
\end{lstlisting}

Графически это может быть выражено ромбовидной схемой

\begin{figure}[h!]
\centering
\includegraphics[width=0.5\textwidth]{illustrations/romb-crop.pdf}
\caption{Ромбовидная схема}
\label{fig:romb-crop}
\end{figure}

Предположим, что в классе \lstinline!File! есть поле \lstinline!File::filename!. По умолчанию, в классе \lstinline!IOFile! у вас получится два члена: \lstinline!InputFile::File::filename! и \lstinline!OutputFile::File::filename!, но файл у которого два имени это абсурд. Чтобы избежать такой ситуации, базовый класс в наследовании может быть объявлен виртуальным (ещё можно вообще никогда ничего не писать на C++, а использовать C, это предпочтительный вариант).

\begin{lstlisting}
class File {};
class InputFile : virtual public File {};
class OutputFile : virtual public File {};
class IOFile : public InputFile, public OutputFile {};
\end{lstlisting}

Теперь всё хорошо и в ромбовидной схеме у самого нижнего производного класса есть только одна копия базового.

\subsubsection{Порядок инициализации в сложных диаграммах}

Важно очень хорошо представлять себе порядок конструирования сложных диаграмм классов. Представим несколько синтетический (но на самом деле гораздо менее сложный, чем многие практически важные иерархии) пример.

\lstinputlisting[firstline=3,lastline=15]{cpp_code/p2s12.cpp}

Для простоты можно изобразить эту иерархию на листочке:

\begin{figure}[h!]
\centering
\includegraphics[width=0.5\textwidth]{illustrations/complexhier-crop.pdf}
\caption{Сложная иерархия}
\label{fig:complexhier-crop}
\end{figure}

Порядок инициализации объекта класса \lstinline!X! для изображённой иерархии следующий:

\begin{itemize}
\item Сначала конструируются виртуальные базовые классы
  \begin{enumerate}
  \item Конструирование \lstinline!V1!: \lstinline!B1::B1()!, \lstinline!V1::V1()!
  \item Конструирование \lstinline!V2!: \lstinline!B1::B1()!, \lstinline!B2::B2()!, \lstinline!V2::V2()!
  \end{enumerate}
\item Затем конструируются невиртуальные базовые классы
  \begin{enumerate}
  \item Конструирование \lstinline!D1!: \lstinline!D1::D1()!
  \item Конструирование \lstinline!D2!: \lstinline!B3::B3()!, \lstinline!D2::D2()!
  \end{enumerate}
\item Затем конструируются члены \lstinline!M1::M1()!, \lstinline!M2::M2()!
\item И в последнюю очередь выполняется конструктор \lstinline!X::X()!
\end{itemize}

Вид наследования (открытое, закрытое или защищённое) не влияет на порядок инициализации.

\subsubsection{Вложенные классы и снова о пространствах имён}

Вложенные функции в C++ невозможны так же как и в C (что кстати не вполне логично, так как вложенные лямбда-функции в новом стандарте возможны и будут рассмотрены на следующих лекциях, так что казалось бы гулять так гулять). Зато C++ позволяет вкладывать классы. Синтаксис очевиден, но, если необходимо, чтобы вложенный класс ``знал'' о своём окружении, об этом надо позаботиться отдельно:

\lstinputlisting{cpp_code/p2s15.cpp}

Каждый вложенный класс определяет область видимости своих имён. Таким образом, можно создать отдельный объект типа \lstinline!DeathStar::DartVeider!, но можно и запретить это, поместив его в private. Собственно обычные пространства имён имеют всего одно отличие от классов со всеми открытыми статическими членами. В случае обычных пространств имён вы можете писать много их объявлений и все они будут объединены компилятором. Таким образом, даже зная как можно сэмулировать их классами, есть смысл всё же использовать пространства имён.

\subsection{Скажи мне кто твой друг}

Модель инкапсуляции C++ логична и стройна (общий смех). В общем случае закрытые члены класса формируют его состояние и недоступны извне, иначе, чем через его методы, отражающие поведение -- это хорошо и правильно. Но в некоторых случаях, разработчик хотел бы дать некоему классу эксклюзивный доступ к закрытым членам другого класса. Например для того, чтобы не писать кучу геттеров и в то же время сохранить консистентность абстракции. Для этого язык C++ предусматривает механизм друзей (\lstinline!friend!) класса.

\lstinputlisting[firstline=8,lastline=16]{cpp_code/p2s16.cpp}

Класс \lstinline!Node!, назначив себе друга \lstinline!BinaryTree!, открыл ему всё свое закрытое состояние, но, при этом, сам не получил никакого доступа к \lstinline!BinaryTree!. Теперь внутри BinaryTree можно написать код вида:

\lstinputlisting[firstline=32,lastline=49]{cpp_code/p2s16.cpp}

Класс может открывать своё состояние не только классам, но и функциям. Скажем, не открывая доступ всему \lstinline!BinaryTree!, можно открыть его только методу \lstinline!find!:

\lstinputlisting[firstline=20,lastline=28]{cpp_code/p2s16.cpp}

Дружба не наследуется, но друг статического родительского типа достаточен, чтобы делать дружественные вызовы полиморфных наследников.

\lstinputlisting[firstline=51,lastline=80]{cpp_code/p2s16.cpp}

В общем случае, дружба статических типов вредна для инкапсуляции. Но дружба, позволяющая полиморфные вызовы по большой и закрытой иерархии это полезно и иногда необходимо. Также, дружба может быть полезна во многих неожиданных контекстах при работе с шаблонами, которые будут рассмотрены ниже.

\subsection{Мелкие детали, касающиеся объектной модели C++}

\begin{enumerate}
\item
Указатель на статическую функцию-член ничем не отличается от указателя на функцию
\item
Указатель на нестатическую функцию-член \lstinline!int (Complex::*)(double,double)! содержит имя класса, содержащего данный метод
\item
Вызов функции-члена объекта \lstinline!complnum! через указатель на функцию-член \lstinline!p! выглядит как \lstinline!(complnum.*p)(1.0, 3.14);!
\end{enumerate}

\pagebreak
\subsection{Домашняя наработка по части 3}

\begin{enumerate}
\item
Расширьте приведённый в (\ref{BallGame}) код до трёхмерной игры в мяч

\item
Введите в приведённый в (\ref{BallGame}) код примитивы синхронизации чтобы его можно было запускать в многопоточном окружении

\item
Расширьте приведённый в (\ref{BallGame}) код до игры в мяч со смещающимся центром тяжести (допустим мяч наполовину заполнен водой или песком)

\item
Разработайте конкретный класс \lstinline!CTime!, предназначенный для хранения текущего времени и вычисления временных интервалов. Не ограничивайтесь unix time, сделайте возможным, например, подсчёт количества часов от Куликовской битвы до Бородинского сражения

\item
Как можно улучшить рассмотренный в (\ref{RAII}) класс CFile? Реализуйте и протестируйте обёртку.

\item
Разработайте и реализуйте иерархию классов, для управления сетевым соединением. Предусмотрите как минимум классы для TCP и UDP сокетов, наследующие от общего предка

\item
Реализуйте абстрактный интерфейс материальной точки и унаследуйте от него разные варианты мяча -- идеальный, с сопротивлением воздуха, со смещённым центром тяжести, etc. На основе общего интерфейса, реализуйте игрока в мяч, которому всё равно каким мячом играть

\item
Перегрузите для класса комплексных чисел, приведённых в (\ref{OperatorOverloading}) инкремент, логические операции, вычитание

\item
Разработайте класс кватернионов со всеми перегруженными арифметическими операциями. Исследуйте есть ли смысл наследовать его от комплексных чисел.

\item
Разработайте класс для операций над матрицами. Проиллюстрируйте к каким проблемам может привести ставшее некоммутативным умножение.

\item
Для вашего класса операций над матрицами перегрузите выделение и освобождение памяти. Разработайте стратегию выделения памяти для разреженных матриц. Проиллюстрируйте умножение двух разреженных матриц 10000x10000 в каждой из которых значимыми являются всего 2-3 элемента (остальные нули).

\end{enumerate}

\pagebreak
\section{Особая шаблонная магия}

Шаблоны, введённые в C++ были в своё время введены туда экспериментально. Их не было ни в одном другом языке и никто по настоящему не знал, что из этого получится. Поэтому большинство интересных и важных свойств шаблонов не были разработаны. Они были открыты. На этой лекции нас тоже ожидают открытия.

\subsection{Шаблоны функций\index{function template} и особенности обобщенного программирования}

Ранее, в разделе (\ref{ConstVsDef}) уже приводился пример преимущества C++ в объявлении обобщённых функций без использования макросов. Теперь самое время снова на него посмотреть и постараться достичь понимания сути происходящего.

\begin{lstlisting}
template <typename T> inline const T
min (const T a, const T b)
{
  return (a < b) ? a : b;
}
\end{lstlisting}

Говорят, что здесь объявлен шаблон функции. Синтаксис шаблона ясен из определения: после слова \lstinline!template! в треугольных скобках через запятую перечисляются параметры шаблона. Подробности грамматики изложены в разделе 14 стандарта C++98 \cite{stdcpp98}.

\begin{lstlisting}
template <typename T, class U, int x>
\end{lstlisting}

Здесь слово \lstinline!typename! означает параметр шаблона, задающий имя типа. По историческим причинам можно использовать \lstinline!class!, но новый стандарт поощряет использование \lstinline!typename!. Кроме того вы уже должны видеть в функции \lstinline!max()! существенный недостаток – параметры, передающиеся по значению, в случае увесистого \lstinline!T! будут неэффективны, лучше заменить их константными ссылками.

\textbf{Вопрос:} как написать пару \lstinline!min! и \lstinline!max!

Возможный вариант ответа:

\begin{lstlisting}
template <class T> const T&
max (const T &x, const T &y)
{
  return ((x > y) ? x : y);
}

template <class T> const T&
min (const T &x, const T &y)
{
  return ((x < y) ? x : y);
}
\end{lstlisting}

Классическим тестом на минимакс является переход 

\lstinline!(x, y) | x <= y! $\rightarrow$ \lstinline!(min (x, y), max (x, y))!

Обобщённые функции можно вызывать из обобщённых функций, так что тест тоже может быть шаблонным:

\begin{lstlisting}
template <typename T> bool
test_minmax (const T &a, const T &b)
{
  assert (a <= b);
  return (min (a, b) == a) && (max (a, b) == b);
}

\end{lstlisting}

В данном случае можно протестировать на паре чисел, паре символов, паре чисел с плавающей точкой, etc:

\begin{lstlisting}
assert(test_minmax ('a', 'b'));
assert(test_minmax (5, 6));
assert(test_minmax (3.0, 7.2));
/* ... */
\end{lstlisting}

Пока всё хорошо. Но обобщённые функции могут принимать переменные любого рода. Пусть имеется очень простая структура, определяющая имя и возраст человека

\begin{lstlisting}
struct Person
{
  const char *name;
  int age;
  Person (const char *a_name, int an_age) : name (a_name), age(an_age) {}
};

static bool
operator > (const Person &lhs, const Person &rhs)
{
  return lhs.age > rhs.age;
}

static bool
operator < (const Person &lhs, const Person &rhs)
{
  return lhs.age < rhs.age;
}
\end{lstlisting}

И вот появляются Иван и Данила:

\begin{lstlisting}
Person Ivan ("Ivan", 20);
Person Danila ("Danila", 20);
std::printf ("%s %s\n", min (Ivan, Danila).name, max (Ivan, Danila).name);
\end{lstlisting}

\textbf{Вопрос:} что будет на экране?

Неожиданно на экране не осталось Ивана. Такое поведение функций, когда для пары одинаковых объектов они сохраняют их значения и порядок в результирующей паре, называется стабильностью. Мы можем сделать вывод, что наши функции \lstinline!min! и \lstinline!max! ведут себя \textbf{нестабильно}. Проблемы стабильности также возникают при проектировании обобщённых алгоритмов сортировки, бинарного поиска и многих других.

\textbf{Вопрос:} как переопределить нашу пару функций так, чтобы они стали стабильными?

Один из вариантов решения

\begin{lstlisting}
template <class T> const T&
max (const T &x, const T &y)
{
  return ((x > y) ? x : y);
}

template <class T> const T&
min (const T &x, const T &y)
{
  return ((x <= y) ? x : y);
}
\end{lstlisting}

Какая мораль? Разработка обобщенного кода очень сильно отличается от разработки конкретного кода. Нужно серьёзно вникать в детали, которых может вовсе не возникнуть когда вы работаете с заранее определенными данными. Все дальнейшие лекции будут посвящены обобщенному коду: шаблонной магии, параллельным алгоритмам и контейнерам стандартной библиотеки, исключениям. 

\textbf{Домашняя наработка:} Для трёх элементов, мы можем написать три порядковых статистики -- максимум, медиану и минимум. Попробуйте написать их в терминах уже написанных бинарных \lstinline!min! и \lstinline!max!, предполагая, что бинарные \lstinline!min! и \lstinline!max! стабильны. Сможете ли вы сделать тернарные варианты также стабильными?

\subsection{Шаблоны функций\index{function template} и перегрузка}

Правила перегрузки шаблонных функций являются расширением правил перегрузки обычных функций, рассматривавшихся ранее в \ref{Overloading}, но со спецификой обобщённого кода. Простые случаи действительно просты. Скажем рассматриваемые выше функции бинарного и тернарного максимума и минимума могут быть вызваны следующими разными способами:

\lstinputlisting{cpp_code/p3s1.cpp}

Их изучение помогает развить интуицию, но вся эта интуиция построена на простом соображении: всегда брать лучшее из имеющихся совпадений. Однако в обобщённом коде, обобщённые типы можно уточнять квалификаторами, и вот в этом случае неизбежны приключения. Предположим у нас есть три кандидата на вызов:

\begin{lstlisting}
template <typename T1, typename T2> void f( T1, T2 ); /* (1) */
template <typename T> void f( T, T* ); /* (2) */
template <typename T> void f( double, double* ); /* (3) */
\end{lstlisting}

и вызов функции, который подходит под все эти шаблоны:

\begin{lstlisting}
double t, s;
f (t, &s);
\end{lstlisting}

\textbf{Вопрос:} какая функция будет вызвана?

Все три варианта являются perfect match, но один из них является наиболее частным, один более общим и один максимально общим. В таких случаях компилятор всегда выбирает наименее общий вариант: то есть сначала (3), если мы его вычеркнем, то (2) и в последнюю очередь (1). Но с этим правилом надо быть осторожным, поскольку оно работает только когда и впрямь есть семантически точное совпадение. В другом примере:

\begin{lstlisting}
template <typename T> void f( T, T ); /* (1) */
template <typename T> void f( double*, T* ); /* (2) */
template <typename T> void f( T*, double* ); /* (3) */
template <typename T1 typename T2> void f( T1*, T2 ); /* (4) */
template <typename T1 typename T2> void f( T1, T2* ); /* (5) */
template <typename T1 typename T2> void f( T1*, T2* ); /* (6) */
\end{lstlisting}

При вызове функции:

\begin{lstlisting}
double t, s;
f (&t, &s);
\end{lstlisting}

Точное совпадение даётся всеми перечисленными функциями, при этом важность того, что типы равны (случай 1) не перевешивает важность того, что оба эти типа указатели (случай 6). В итоге компилятор не может придти к решению и выдаст ошибку ``is ambiguous''. Если мы вычеркнем (1, 2, 3), то оставшиеся разрешатся в пользу (6) как наиболее общего совпадения. Но (и это интересно), если оставить (1, 4 и 5), то это всё ещё будет ошибка. Зато (2, 4, 5) однозначно разрешаются в пользу (2). Но оба выигравших номера -- 2 и 6 дают ошибку в паре с 1. Мораль у этого такая: всегда нужно смотреть на наиболее общий семантический тип.

\textbf{Домашняя наработка:} рассмотрите случай, когда одновременно объявлены одновременно шаблоны для ссылки и константной ссылки

\begin{lstlisting}
template <typename T> inline T& max (T& a, T& b) { /* ... */ }
template <typename T> inline T const& max (T const& a, T const& b) { /* ... */ }
\end{lstlisting}

Как в этом случае будет разрешаться перегрузка? Приведите примеры. Аналогично для указателя, константного указателя, указателя на константные данные. Если добавить к перегрузке по ссылке перегрузку по значению, создав тем самым неоднозначность, компилятор должен отреагировать ошибкой. Проверьте как отработает эту ситуацию ваш компилятор.

\subsubsection{Когда C++ быстрее, чем C}\label{CppBetterC}

Простые шаблоны функций не так просты и их не стоит недооценивать. Вопрос к студентам: какую сигнатуру вы напишете, если хотите на C написать обобщённую функцию сортировки? Стандарт языка C99 регламентирует (пункт 7.20.5.2) следующую сигнатуру:

\begin{lstlisting}
void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));
\end{lstlisting}

Почему здесь использован \lstinline!void*!? Потому что в обобщённой функции мы не знаем какого типа элементы будут отсортированы. Кроме того требуется передавать размер элемента и их количество раздельно, что открывает возможности для человеческих ошибок. Но хуже всего то, что компаратор (вызываемый на каждое сравнение элементов) это указатель на функцию. Из-за этого:

\begin{itemize}
\item Каждый вызов компаратора имеет штраф на разыменование указателя на функцию -- лишний уровень косвенности
\item Исключена возможность inline-подстановки сравнения, которое обычно сводится к чему-то очень простому (скажем простому ``меньше, чем'')
\end{itemize}

Всех этих недостатков лишена реализация в стиле C++, которая может выглядеть примерно как:

\begin{lstlisting}
/* we suppose that Element class have meaningfull operator< () redefinition */
template <typename Element>
void qsortpp(Element *base, size_t nmemb);
\end{lstlisting}

Это лучше, проще, более безопасно относительно типов и это гораздо эффективнее. Платим мы за это объёмом кода, который компилятор теперь сгенерирует для каждой инстанциации \lstinline!qsort!, но это недорого.

На самом деле стандарт C++98 регламентирует (пункт 25.3.1.1) даже более изящную сигнатуру для стандартной сортировки:

\begin{lstlisting}
template<class RandomAccessIterator>
void sort(RandomAccessIterator first, RandomAccessIterator last);
\end{lstlisting}

Но вся её мощь, красота и обобщённость проявятся позже, когда речь пойдёт о стандартной библиотеке.

\textbf{Домашняя наработка:} Реализуйте \lstinline!qsort! в стиле C и в стиле C++

\subsection{Два полиморфизма\index{Template Polymorphism}}

Что же, к этому моменту вы знаете о шаблонах функций уже достаточно, чтобы вернуться к серьёзным вещам, таким как планеты и космические корабли. Мы можем наследовать их от общего предка, как мы это делали в (\ref{PureVirtual}), но совершенно не задействовать виртуальные функции:

\begin{lstlisting}
class CelestialBody
{
  double x, y;
public:
  double get_x () const;
  double get_y () const;
  /* ... other ... */ 
};

class SpaceShip : public CelestialBody
{
  /* ... spaceship-related ... */
};

class Planet : public CelestialBody
{
  /* ... planet-related ... */
};
\end{lstlisting}

И тем не менее сохранить возможность писать довольно абстрактный код, полагающийся только на общий интерфейс объектов (способность сообщить координаты) и отдающий им на откуп детали реализации:

\begin{lstlisting}
template <typename T> double
get_distance (const T &lhs, const T & rhs)
{
  double xdist = lhs.get_x() - rhs.get_x();
  double ydist = lhs.get_y() - rhs.get_y();
  return sqrt (xdist*xdist + ydist*ydist);
}
\end{lstlisting}

Это прекрасное свойство называется полиморфизм времени компиляции, или статический полиморфизм. Заметьте, никаких больше виртуальных функций, никаких таблиц виртуальных методов, никакого оверхеда времени выполнения (за счёт раздутия кода помещением туда 100500 экземпляров функции \lstinline!get_distance!, разумеется).

Разница в том, что класс \lstinline!ICelestialBody! создавал явный интерфейс, в случае же статического полиморфизма, шаблонная функция накладывает неявные требования к обоим своим инстанциирующим типам, сформулированные точно так же ``поддерживать функцию-член \lstinline!get_x()!'' и ``поддерживать функцию-член \lstinline!get_y()!''. 

При рассмотрении нового стандарта, возможно, будут рассмотрены ``концепты'', которые наконец-то определяют способ задать неявный интерфейс явно.

\subsubsection{Когда шаблонный полиморфизм уступает динамическому}

Использование шаблонного полиморфизма снижает накладные расходы на исполнение и почти всегда предпочтительно. Но есть вещи, которые требуют динамического полиморфизма и оказываются неоправданно сложными если пытаться сделать их на этапе компиляции.

\begin{lstlisting}
class obj
{
public:
  virtual int foo (int) = 0;    
};

class A : public obj;
class B : public obj;

/* ... class C, D, etc ... */

/* returns A is config have 'a', B is 'b', and so on ... */
obj * getfromconfig (const char *filename);

int
entry (obj *x)
{
  return x->foo();
}

int
main (void)
{
  return entry (getfromconfig("my.xml"))
}
\end{lstlisting}

Этот код представляет собой идиому ``виртуального конструктора'' (так же известен как фабричный метод).

\textbf{Домашняя наработка:} попробуйте переписать его с использованием только статического полиморфизма.

\subsection{Простые шаблоны классов\index{class template}}

Представьте, что перед вами стоит задача спроектировать стек – класс объектов любого типа (но однородных) которые будут туда помещаться и вытаскиваться. Как обычно синтаксис вполне понятен через пример (детали вы всегда сможете прочитать в стандарте).

\lstinputlisting[firstline=6,lastline=18]{cpp_code/p3s2.cpp}

Обратите внимание на то, что \lstinline!T!, помещённый в шаблон, используется внутри класса как совершенно обычный тип. Можно вернуть его из метода, передать в метод и даже использовать как деталь реализации скрытой подструктуры.

\lstinputlisting[firstline=20,lastline=37]{cpp_code/p3s2.cpp}

Вопрос к студентам: что мы забыли?

Ожидается хоровой ответ: деструктор, копирующий конструктор и оператор присваивания. Позвать кого-нибудь к доске разобрать как их писать.

Давайте посмотрим как применять разработанный шаблонный класс:

\lstinputlisting[firstline=39]{cpp_code/p3s2.cpp}

Из примера ясно, что с использованием шаблонов, поддержка двух разнородных контейнеров (трёх, десяти) это крайне легко. Скорость компиляции, правда, страдает, вместе с объёмом кода, но по современным реалиям это невысокая цена.

\subsubsection{Специализация\index{template specialization}}

В случае с функциями был использован механизм перегрузки функций чтобы получить специальное поведение для конкретного типа аргументов. Но нельзя ``перегрузить'' класс. Зато вы можете специализировать шаблон класса для конкретных шаблонных параметров. Синтаксис, опять же, прост:

\begin{lstlisting}
template <>
class Stack<int> { ... };
\end{lstlisting}

Такая запись создаёт отдельное поведение для стеков, инстанцированных целыми числами. Реализация и поведение такого шаблона могут не иметь вообще ничего общего с исходным. Это создаёт почти такую же радость при чтении кода на C++ как перегрузка операторов и неявные приведения.

\subsubsection{Частичная специализация\index{partial specialization}}

Суть частичной специализации в том, что вы пишете отдельный код для определённых обстоятельств инстанциирования, но часть параметров этого кода всё ещё задаёт шаблон. При исходном шаблоне

\begin{lstlisting}
template <typename T, typename U> class MyClass { ... };
\end{lstlisting}

Мы можем написать например такие специализации

\begin{lstlisting}
/* partial specialization: both template parameters have same type */ 
template <typename T> class MyClass<T,T> { ... }; 
/* partial specialization: second type is int template <typename T> */ 
class MyClass<T,int> { ... }; 
/* partial specialization: both template parameters are pointer types */
template <typename T1, typename T2> class MyClass<T1*,T2*> { ... };
\end{lstlisting}

И далее посмотрим как конкретные объявления будут раскрыты.

\begin{lstlisting}
MyClass<int,float> mif;    /* uses MyClass<T1,T2> */ 
MyClass<float,float> mff;  /* uses MyClass<T,T> */ 
MyClass<float,int> mfi;    /* uses MyClass<T,int> */ 
MyClass<int*,float*> mp;   /* uses MyClass<T1*,T2*> */
\end{lstlisting}

Учтите, что если под некое объявление подходят сразу два варианта частичной специализации, то это ошибка

\begin{lstlisting}
MyClass<int,int> m;        // ERROR: matches MyClass<T,T> 
                           //        and MyClass<T,int> 
MyClass<int*,int*> m;      // ERROR: matches MyClass<T,T> 
                           //        and MyClass<T1*,T2*>
\end{lstlisting}

Можно исправить ошибку сделав уникально подходящий шаблон

\begin{lstlisting}
template <typename T> 
class MyClass<T*,T*> { ... };
\end{lstlisting}

Очень важно понимать, что частичная специализация не доступна для функций и является прерогативой шаблонов классов.

\subsubsection{Переходники типов и специализация членов}

Иногда не хочется писать специализацию или частичную специализацию всего класса ради того, чтобы изменить поведение одного метода. Если метод можно перегрузить, все хорошо. Но что если метод требует частичной специализации? Рассмотрим ситуацию, когда один и тот же метод \lstinline!func! класса \lstinline!<T1, T2> class A! должен по разному себя вести если \lstinline!T1! это целое число и если нет.

\begin{lstlisting}
A <int, double> a;
A <float, double> b;

a.func(); /* for int */
b.func(); /* forall */
\end{lstlisting}

Вопрос к студентам -- как этого добиться?

Первый вариант ответа может быть примерно такой:

\begin{lstlisting}
template <typename T1, typename T2>
class A
{
  public:
     void func(void) { T1 dummy; internal_func (dummy); }
  private:
    template< class V >
    void internal_func (V)
      { printf ("forall\n"); }

    void internal_func (int)
      { printf ("forint\n"); }
};
\end{lstlisting}

Но тут есть проблема -- мы не знаем, что делает конструктор объекта класса \lstinline!T1!. Стандартный выход из ситуации -- подход с использованием переходника: 

\begin{lstlisting}
template <typename T>
struct Type2Type {
  typedef T OriginalType;
};
\end{lstlisting}

Подход с переходником позволяет нам не закладываться на конструктор класса \lstinline!T1! и сделать максимально легкий dummy параметр.

\begin{lstlisting}
template <typename T1, typename T2>
class A
{
  public:
     void func(void) { internal_func (Type2Type<T1>()); }
  private:
    template <class V>
    void internal_func (Type2Type<V>)
      { printf ("forall\n"); }

    void internal_func (Type2Type<int>)
      { printf ("forint\n"); }
};
\end{lstlisting}

Особое внимание нужно обратить на то, что переходник в таком виде имеет минимально возможный размер. Мы вернемся к этому вопросу когда будем разбирать CRTP чтобы увидеть как можно обойтись вообще без переходника, используя параметризованное наследование.

\subsubsection{Шаблоны членов и инкапсуляция}

Как видно из примера выше, в принципе шаблонная функция тоже может быть членом класса. Это не вносит почти никаких изменений в рассмотренный материал -- для неё верно всё то же, что и для других шаблонных функций. Но использование шаблонных членов вносит серьёзные коррективы в инкапсуляцию. Коротко говоря, использование шаблонных членов отменяет инкапсуляцию. Рассмотрим класс:

\begin{lstlisting}
class X {
public:
  X() : private_(1) {}
  tempalte <typename T> void f(const T& t) { /* ... */ }
  int Value(void) const { return private_; }
private:
  int private_;  
};
\end{lstlisting}

За счёт наличия в этом классе шаблонного члена, человек, использующий его, может написать код:

\begin{lstlisting}
namespace {
  struct Y {};
}
template<>
void X::f(const Y&) {
  private_ = 2;
}
\end{lstlisting}

Этот код эксплуатирует оговорённую в стандарте возможность специализировать шаблон-член для любого типа. Это выглядит забавно -- специализацию шаблонов-функций заменяет перегрузка, но шаблон-член вы можете как перегрузить, так и специализировать. Эта ортогональность прекрасна, если ей не злоупотреблять.

То, что шаблоны-члены неявно нарушают инкапсуляцию -- последствие взаимодействия объектно-ориентированной и шаблонной подсистем языка, которые проектировались во многом ортогонально и имеют нюансы совместного использования.

\subsection{Наследование от шаблона и CRTP\index{CRTP}}

Шаблонный класс со всеми определёнными парамтерами это уже настоящий класс и значит от него можно наследоваться. На этой технике основана интересная и часто используемая идиома CRTP.

\textbf{CRTP – curiously reccuring template parameter} означает параметризацию шаблона, являющегося базовым классом, шаблонным параметром, являющимся самим классом-потомком. 

Это позволяет реализовать на чистых шаблонах механизм, похожий на обобщение виртуальных функций:

\begin{lstlisting}
#include <iostream>
using namespace std;

template <typename Child>
struct Base
{
  void interface ()
    {
      static_cast<Child*>(this)->implementation ();
    }
};

struct Derived : Base<Derived>
{
  void implementation ()
    {
      fprintf (stderr, "%s\n", "Derived implementation");
    }
};

template <typename T> void
call_interface (Base<T> *b)
{
  b->interface ();
}

int 
main ()
{
  Derived d;
  call_interface (&d);  /* Prints "Derived implementation" */
}
\end{lstlisting}

Разумеется, список того, что может вызвать \lstinline!Base! через свою функцию \lstinline!interface! определяется программистом (в отличии от механизма виртуальных функций, где вызов всегда пробрасывался до единственной функции производного класса с тем же именем).

Если вернуться к предидущей задаче имитации специализированного метода, то её решение через CRTP вполне прозрачно:

\begin{lstlisting}
template <typename S, typename T>
class ABase
{
public:
  void func(void) {static_cast<S*>(this)->forall(); }
};

template <typename S>
class ABase <S, int>
{
public:
  void func(void) { static_cast<S*>(this)->forint(); }
};


template <typename T1, typename T2>
class A : public ABase <A<T1, T2>, T1>
{
  public:
    void forall ()
      { printf ("forall\n"); }

    void forint ()
      { printf ("forint\n"); }
};
\end{lstlisting}

Более интересный пример: организация сравнений для произвольного класса:

\begin{lstlisting}
template <typename Derived>
struct Comparisons
{
};


template <typename Derived>
bool operator==(const Comparisons<Derived>& o1, const Comparisons<Derived>& o2)
{
    const Derived& d1 = static_cast<const Derived&>(o1);
    const Derived& d2 = static_cast<const Derived&>(o2);

    return !(d1 < d2) && !(d2 < d1);
}


template <typename Derived>
bool operator!=(const Comparisons<Derived>& o1, const Comparisons<Derived>& o2)
{
    return !(o1 == o2);
}
\end{lstlisting}

Используя его через CRTP, можно бесплатно получить сравнения для пользовательского класса

\begin{lstlisting}
class Person : public Comparisons<Person>
\end{lstlisting}

Возникает вопрос -- зачем нужно CRTP, являющееся по сути имитацией динамического полиморфизма если у нас уже есть статический полиморфизм и те же сравнения могут быть написаны для любого \lstinline!T! безо всякого CRTP? Идея в том, что CRTP позволяет ограничить область действия статического полиморфизма множеством наследников данного класса и в то же время избежать расходов на виртуальные функции.

\subsection{Ваш друг typename\index{typename}}\label{FriendTypename}

Это ваш второй воображаемый друг, первый был, как вы помните, \lstinline!typedef!. Изначально \lstinline!typename! был введен в C++ чтобы явно указывать компилятору на вложенные шаблонные типы. Рассмотрим код:

\begin{lstlisting}
template <typename T>
int foo (const T& x)
{
  T::subtype *y;
  /* ... */
}
\end{lstlisting}

Что здесь написано? Думаете объявление указателя на вложенный тип? Вы не поверите, но дословно здесь написано 
следующее: ``В классе \lstinline!T! должен быть статический член с именем \lstinline!T::subtype!. Необходимо \textbf{умножить} его на некую (очевидно глобальную) переменную \lstinline!y! и проигнорировать результат''. Печально, да? Давайте исправим код:

\begin{lstlisting}
template <typename T>
int foo (const T& x)
{
  typename T::subtype *y;
  /* ... */
}
\end{lstlisting}

Теперь всё хорошо, мы явно указали компилятору, что \lstinline!T::subtype! это тип. Именно так \lstinline!typename! и был запланирован. По английски устранение такой неоднозначности называется ``\textbf{disambiguation}'' \index{disambiguation} и именно так этот термин устоялся в англоязычной литературе (не встречал его в русскоязычной). То, что я перевожу disambiguation как ``устранение неоднозначности'' это некая вольность, скорее передающая смысл термина, чем его перевод.

В использовании \lstinline!typename! для вложенных шаблонных классов может встретится один небольшой трюк -- дополнительное использование слова \lstinline!template! для устранения неоднозначности при разборе шаблона. Представим у нас есть код:

\lstinputlisting[firstline=5,lastline=18]{cpp_code/p3s4.cpp}

И надо написать вызов для шаблонной функции вложенного класса (например из другого шаблонного класса, с достаточно простым определением)

\begin{lstlisting}
template <typename T1, typename T2>
class Usage
{
public:
  void caller( /* parameter type */ &obj )
    {
      /* obj.nested<int>(); */
    }
};
\end{lstlisting}

Можно написать простую проверочную программу, где использовать этот вызов как-то так:

\lstinputlisting[firstline=31]{cpp_code/p3s4.cpp}

Сам по себе этот пример представляет собой лишь изящную головоломку, но полезен для иллюстрации концепции. В реальных проектах эти проблемы могут всплыть в гораздо более сложном коде и нужно вдоволь натренироваться на простых примерах, чтобы уметь их угадывать. Правильный ответ выглядит несколько необычно:

\lstinputlisting[firstline=20,lastline=28]{cpp_code/p3s4.cpp}

Но что произойдёт если мы не упомянем ключевого слова \lstinline!template!? Примерно та же проблема, что и с \lstinline!typename! -- компилятор не будет в точности знать как ему трактовать треугольную скобку, открывающуюся после имени типа \lstinline!Inner! или после имени функции \lstinline!nested!. И в том и в другом случае, без явного указания ключевого слова template, он будет трактовать эту скобку как переопределённый оператор ``меньше'' (снова нечто невероятное). Это может привести вас к массе неявных но интересных ошибок.

\subsection{Правила инстанцирования и SFINAE\index{SFINAE}}

\subsubsection{Целочисленные шаблонные параметры}

Кроме типов, шаблоны могут быть параметризованы целыми числами (и много чем ещё, о чем речь пойдет несколько позднее). Простейший пример: массив с заданным во время компиляции размером:

\begin{lstlisting}
template<unsigned int S>
class Array {
    unsigned char bytes[S];
public:
    /* work with bytes */
};
\end{lstlisting}

Теперь в своем коде вы можете написать:

\begin{lstlisting}
Array<42> a;
\end{lstlisting}

Объявив таким образом массив из сорока двух байт как класс с поведением, но без выделения динамической памяти.

Разумеется никто не мешает вам его специализировать.

\begin{lstlisting}
template<>
class Array<3> {
    /* alternative definition for SIZE == 3 */
};
\end{lstlisting}

Важно, что константа должна быть известна на этапе компиляции. Вы не можете написать нечто вроде:

\begin{lstlisting}
int x;
/* ... nontrivial code around x ... */
Array<x> a; /* Error! */
\end{lstlisting}

Это ограничивает целочисленные параметры целочисленными константами. Позднее будет рассмотрена тонкая связь целых чисел с типами, но пока что изложенного достаточно чтобы работать с простыми целочисленными параметрами, которые нужны для SFINAE.

\subsubsection{Ленивость и энергичность}

C и C++ -- это языки с энергичной (с некоторыми исключениями) редукцией выражений при вычислениях, поэтому изучающие их (если у них нет предварительного опыта в таких языках как Lisp или Haskell) часто даже не подозревают, что может быть как-то иначе.

\begin{lstlisting}
int foo (int x, int y)
{
  return (x > 3) ? 0 : y;
}
/* ... */
foo (a + 3, b + 2);
\end{lstlisting}

Ленивые и энергичные вычисления для этого кода проиллюстрированы на рисунке

\begin{figure}[h!]
\centering
\includegraphics[width=0.6\textwidth]{illustrations/lazyorder-crop.pdf}
\caption{Ленивые и энергичные вычисления}
\label{fig:lazy_calc}
\end{figure}

Видно, что при ленивых вычислениях, реальное вычисление результата выражения откладывается насколько это возможно. Это создает свои проблемы: скажем передавать в функцию такое недосчитанное выражение гораздо сложнее, чем передать посчитанное заранее число. Поэтому ленивые вычисления в C++ встречаются только в двух контекстах:

\begin{enumerate}
\item В вычислениях с длинными логическими операциями: \lstinline!&&! и \lstinline!||!. Из-за ленивого порядка их применения, легальны выражения вида:
\begin{lstlisting}
if (p && p->next) { /* ... */ }
\end{lstlisting}
Если бы порядок вычисления был энергичным, то при нулевом указателе второе условие взорвалось.
\item В инстанцировании шаблонов
\end{enumerate}

Второй пункт создает столько неочевидных преимуществ, что дальше мы будем говорить в основном о нём.

\subsubsection{Инстанцирование шаблонов}

Выше уже несколько раз было употреблено слово ``инстанцирование''. Интуитивно оно понятно, но оно имеет разный смысл для обычных классов (там инстанцирование класса это создание его объекта) и для шаблонов. Настало время дать этому слову более точное определение.

\textbf{Шаблонным инстанцированием} называется процесс порождения типов и функций из обобщённых шаблонных определений.

В книгах по шаблонам, таких как \cite{vandervoord} традиционно много места отводится тому, что называется ``Separation model''\index{Separation model}. Это модель инстанцирования, когда код шаблона находится в одной единице трансляции, а инстанцирование происходит в другой. Начиная с C++11 \cite{stdcpp11} экспорт шаблонов был запрещён, а Separation model объявлена устаревшей. Поэтому мы далее будем полагать, что код шаблона и инстанцирование происходят в одной единице трансляции.

Самое важное, что нужно знать про инстанцирование -- оно по стандарту обязано работать лениво. Это означает, что проверены на корректность будут только те части шаблона, которые действительно были использованы. Давайте рассмотрим пример:

\lstinputlisting{cpp_code/p3s6.cpp}

Несмотря на то, что инстанцирование определяет \lstinline!typedef! с некорректным параметром размера массива, это не является ошибкой, поскольку реально этот зависимый тип нигде не был использован. Ленивость вынуждает компилятор откладывать инстанцирование любой части шаблона так долго, как это возможно.

\subsubsection{Идиома SFINAE}

Ещё более разрешающей идиомой в правилах инстанцирования является SFINAE, что означает \textbf{substitution failure is not an error}. Она означает, что некорректная подстановка шаблонных параметров сама по себе не является ошибкой. SFINAE является очень мощной техникой, позволяющей делать интересные вещи. Например определить на этапе компиляции имеет ли некий тип вложенный зависимый тип с определённым именем.

\lstinputlisting{cpp_code/p3s7.cpp}

Этот код выведет результат \lstinline!foo: 1, bar: 0!, верно определив наличие зависимого типа \lstinline!foo::foobar! в \lstinline!foo! и его отсутствие в \lstinline!bar!. Эта техника может казаться взрывающей мозг, но я рекомендую изучить идею, пока она не станет ясна.

\subsection{Разрешение имён с учётом шаблонов}

Вернёмся к рассмотренной ранее (\ref{NameResolution}) теме разрешения имён. Если бы всегда при работе с шаблонами возникала необходимость явно указывать шаблонные аргументы, код довольно скоро разрастался бы, обрастая ненужными подробностями. Скажем так ли нужно писать \lstinline!concat<std::string, int>(s, 3)! если компилятор достаточно умён, чтобы понять и более простую форму \lstinline!concat(s, 3)! из контекста.

При выводе параметров, компилятор строит вывод для каждого параметра и выдаёт ошибку, если вывод расходится. Пусть снова дана функция \lstinline!max! и написан неоднозначный вызов для неё:

\lstinputlisting[firstline=5,lastline=9]{cpp_code/p3s01.cpp}

\begin{lstlisting}
int g = max(1, 1.0);
\end{lstlisting}

Что произойдёт? Вывод типов для данного шаблона будет неоднозначен и подстановка провалится. Заметьте -- подстановка провалена не означает, что программа некорректна (снова SFINAE). Возможно где-то определён более подходящий шаблон, скажем 

\begin{lstlisting}
template <typename T, typename U> inline const T 
max (const T a, const U b) { ... }
\end{lstlisting}

и подстановка в него завершится успехом.

Если нет, то сообщение об ошибке будет выглядеть довольно очевидно:

\begin{verbatim}
error: no matching function for call to ‘max(int, double)’
note: candidate is:
note: template<class T> const T max(T, T)
note: template argument deduction/substitution failed:
note: deduced conflicting types for parameter 
     ‘T’ (‘int’ and ‘double’)
\end{verbatim}

Нужно быть крайне осторожным с символьными литералами как параметрами шаблона. На первый взгляд вызов \lstinline!max("Apple", "Pear")! будет приведен к \lstinline!const char*!, но это неверно. Статическими типами для этих двух строк будут \lstinline!char const[5]! и \lstinline!char const[6]!, и С++ посчитает их разными типами.

Подстановка также может провалиться, если результатом подстановки служит код, некорректный по стандарту C++. Например:

\lstinputlisting[firstline=11,lastline=22]{cpp_code/p3s01.cpp}

\begin{verbatim}
note: template argument deduction/substitution failed:
      In substitution of ‘template<class T> 
      typename T::ElementT at(const T&, int) [with T = int*]’:
      required from here
error: ‘int*’ is not a class, struct, or union type
\end{verbatim}

Здесь для p будет выведен тип \lstinline!int*!, который создаёт неверное присваивание в точке использования и такая подстановка также будет провалена.

\subsection{Немного истории (трюк Бартона-Накмана)\index{Barton-Nackman trick}}

В долгой истории шаблонов C++ встречаются примеры интересных обходных решений, изучение которых полезно не с практичекой а с общеразвивающей точки зрения. Одно из них, которое сейчас уже не актуально, решало интересную и важную проблему. Итак, перенесёмся в 1994-й и представим что у нас ещё нет перегрузки шаблонных функций и пространств имён.

Зато у нас есть некий шаблон Array, для которого необходимо переопределить оператор сравнения на равенство \lstinline!==!. Первый вариант -- определить его как член класса, но это действительно плохая идея, поскольку первый аргумент (указатель на \lstinline!this!) будет преобразоваться иначе чем второй. Мы уже разбирали такой пример в (\ref{SymmBinary}). Поэтому, конечно, его хочется определить вне класса:

\begin{lstlisting}
template<typename T> 
class Array { 
  public: 
  ...
}; 

template<typename T> 
bool operator == (Array<T> const& a, Array<T> const& b) 
{ 
  ... 
} 
\end{lstlisting}

Однако, если у нас нет перегрузки шаблонных функций, это создаёт проблему: ни одна больше функция с названием \lstinline!operator ==! не может быть объявлена в этом же пространстве имён. Тем не менее, вполне логично, что оператор сравнения может быть нужен в том же пространстве имён для других классов. Бартон и Накман предложили определить этот оператор в классе как функцию-друг.

\begin{lstlisting}
template<typename T> 
class Array { 
  public: 
    ... 
    friend bool operator == (Array<T> const& a, 
                             Array<T> const& b) { 
        return ArraysAreEqual(a, b); 
    } 
}; 
\end{lstlisting}

Пусть эта версия класса \lstinline!Array! инстанцирована для типа \lstinline!float!. Тогда оператор сравнения объявлен как результат этого инстанцирования, но сам по себе не является шаблоном функции и, таким образом, может быть перегружен как обычная функция.

В связи с тем, что \lstinline!operator == (Array<T> const&, Array<T> const&)! определён внутри определения класса, он неявно считается встраиваемой функцией. Поэтому там и заложена делегация к не-инлайновой ArraysAreEqual, которая уже вряд ли будет конфликтовать с другими именами.

\subsection{Другие шаблонные параметры}

До сих пор мы рассматривали только параметризацию шаблонов типами и немного -- целыми числами. Это не вполне исчерпывает возможности шаблонов. Они могут быть параметризованы указателями и даже другими шаблонами. Кроме того, можно увидеть, что по сути параметризация целыми, указателями, шаблонами -- это одна и та же параметризация. Ниже будут систематично рассмотрены все упомянутые случаи.

\subsubsection{Связь целых чисел и типов}

Следующая конструкция была предложена Александреску и использует возможность параметризации шаблона типом для создания в C++ перечислимых типов:

\begin{lstlisting}
template <int I>
struct Int2Type
{
  enum { value = I };
};
\end{lstlisting}

Обратите внимание, что \lstinline!Int2Type<0>!, \lstinline!Int2Type<1>!, \lstinline!Int2Type<2>! и так далее являются разными типами, при этом каждый содержит в себе информацию о своем порядковом номере. Идею можно расширить до почти полноценных нумералов:

\begin{lstlisting}
template <int I>
struct Int2Type
{
  enum { value = I };
  typedef int value_type;
  typedef Int2Type<I> type;
  typedef Int2Type<I+1> next;
  typedef Int2Type<I-1> previous;
};
\end{lstlisting}

Простой пример использования это сортировка массива:

\begin{lstlisting}
template <typename T, unsigned int N>
class Array 
{
private:
  enum AlgoType { NOOP, INSERTION_SORT, QUICK_SORT };
  static const int algo = (N==0) ? NOOP : 
                          (N==1) ? NOOP :
                          (N<50) ? INSERTION_SORT : QUICK_SORT;
  void do_sort (Int2Type<INSERTION_SORT>) { /* INSERTION_SORT */ }
  void do_sort (Int2Type<QUICK_SORT>) { /* QUICK_SORT */ }
public:
  /* ... all array-related stuff ... */
  void sort()
  {
    do_sort (Int2Type<algo>());
  }
};
\end{lstlisting}

Здесь пользователь вызывает только функцию \lstinline!sort!, которая, в зависимости от длины массива, сама решает какой алгоритм сортировки ей применить.

\subsubsection{Параметризация шаблонов указателями}

Понять каким образом происходит параметризация шаблонов указателями, поможет несколько синтетическая задача сопоставить каждой глобальной переменной в программе уникальное имя:

\begin{lstlisting}
template <int *foo>
class VariableNamer {
public:
  static const char *name;
};

int baz = 7;
int bar = 42;

template<>
const char * VariableNamer< &baz >::name = "baz";

template<>
const char * VariableNamer< &bar >::name = "bar";

template <int *foo> void
detect_global (void)
{
  printf ("called with: %s = %d\n", VariableNamer<foo>::name, *foo);
}

int
main( int argc, char ** argv )
{
  baz = baz / 2;
  bar = bar + baz;
  detect_global <&bar> ();
  detect_global <&baz> ();
  return 0;
}
\end{lstlisting}

Шаблонный класс \lstinline!VariableNamer! здесь позволяет создать уникальный тип для каждой глобальной переменной и сохранить внутри присвоенное ей символьное имя. Пользующийся им шаблон \lstinline!detect_global! печатает имя переданной ему глобальной переменной и её значение.

В этом коде есть ряд недочетов, скажем его нельзя расширить для трэкинга локальных переменных, сложно обобщить на указатели на произвольный тип и так далее.

\textbf{Домашняя наработка:} подумайте как существенно улучшить \lstinline!VariableNamer!, не бойтесь при этом использовать препроцессор.

\subsubsection{Шаблонные шаблонные параметры\index{template template parameters}}

Представьте, что вы используете CRTP для предоставления ``интерфейса'' к набору дочерних шаблонов, при этом как родитель, так и потомки параметризованы:

\begin{lstlisting}
template <typename derived, typename value> class interface {
    void do_something(value v) {
        static_cast<derived*>(this)->do_something(v);
    }
};

template <typename value> class derived : public interface<derived<value>, value> {
    void do_something(VALUE v) { ... }
};

typedef interface<derived<int>, int> derived_t;
\end{lstlisting}

Строчка, определяющая \lstinline!derived_t! содержит неприятное дублирование типа  \lstinline!int!, который на самом деле один и тот же и для потомка и для предка. Мало того это даёт возможность ошибки при опечатке. Чтобы явно отобразить, что шаблон параметризуется зависимым параметризованным типом:

\begin{lstlisting}
template <template <typename> class derived, typename value> class interface {
    void do_something(value v) {
        static_cast<derived<value>*>(this)->do_something(v);
    }
};

template <typename value> class derived : public interface<derived, value> {
    void do_something(value v) { ... }
};

typedef interface<derived, int> derived_t;
\end{lstlisting}

Обратите внимание на \lstinline!template <typename> class derived! -- именно такой синтаксис внутри списка аргументов показывает, что \lstinline!derived! это шаблонный тип, специфицированный неким зависимым. Александреску\cite{mcpp} использует шаблонные шаблонные параметры для реализации policy-классов

\begin{lstlisting}
template <template <typename> class CreationPolicy>
class WidgetManager : public CreationPolicy<Widget>
{
   ...
};
\end{lstlisting}

Считается, что \lstinline!WidgetManager! ``знает'' о том, что ему нужна \lstinline!CreationPolicy! именно для \lstinline!Widget!. При этом нужно понимать, что если шаблонный шаблонный класс параметризован более чем одним зависимым аргументом, это должно быть явно указано:

\begin{lstlisting}
template <template <typename, typename> class CreationPolicyEx>
class WidgetManager : public CreationPolicyEx<Widget, WidgetPattern>
{
   ...
};
\end{lstlisting}

Разумеется, явно может быть указано сколько угодно зависимых типов.

\subsubsection{CRTP с закрытой базой и ещё немного дружбы}

При использовании CRTP с закрытой базой (являющейся специализацией шаблонного шаблонного параметра), бывает полезно объявить закрытую базу другом, чтобы дать ей доступ к своей закрытой части.

\begin{lstlisting}
/* Transport<service> is implementation detail */
template<template<typename> class Transport>
class service : private Transport<service> {
    /* since we derive privately, make the transport layer a friend of us, 
       so that it can cast its this pointer down to us */
    friend class Transport<service>;
public:
    typedef Transport<service> transport_type;
    /* common code */
    void do_something() { 
        this->send(....);
    }
};

template<typename Service>
class tcp {
public:
    void send(....) {

    }
};

template<typename Service>
class udp {
public:
    void send(....) {

    }
};

typedef service<tcp> service_tcp;
typedef service<udp> service_udp;
\end{lstlisting}

И вот теперь, когда разминка с шаблонами закончена, можно переходить к серьёзным вещам.

\subsection{Метапрограммы\index{Metaprogramming}}

Шаблонное метапрограммирование было открыто в 1994-м году. Эрвин Анрух (Erwin Unruh) на заседании комитета по стандартизации сделал доклад, из которого следовало, что шаблоны могут быть использованы для вычисления на этапе компиляции и продемонстрировал генератор простых чисел, который на этапе компиляции выводил в виде сообщений об ошибках простые числа от 2 до заранее заданного настраиваемого предела. Но этот генератор довольно сложен. Кроме того, метапрограммирование использует несколько иной подход к вычислениям, с которого и следует начать.

\subsubsection{Две модели вычислений}

Представьте простую функцию, вычисляющую факториал числа. Человек с опытом на C написал бы её в итеративном стиле:

\begin{lstlisting}
int
fact_0 (int x)
{
  int i, res = 1;
  for (i = 2; i <= x; ++i)
    res *= i;

  return res;
}
\end{lstlisting}

Здесь для того, чтобы вычислить факториал понадобились две ячейки памяти -- изменяемые переменные \lstinline!i! и \lstinline!res!. Математик Алан Тьюринг в 1936-м году опубликовал статью из которой следовало, что очень сложные вычислительные процессы можно произвести, имея в своем распоряжении:

\begin{itemize}
\item ветвления (скажем оператор \lstinline!if! или тернарный оператор)
\item переходы (хороший пример -- любой цикл или простое \lstinline!goto!)
\item последовательное линейное исполнение инструкций
\item достаточное количество изменяемой памяти
\end{itemize}

Факториал переписанный в более Тьюринг-стиле, но все ещё на C показывает некий минимализм выразительных средств:

\begin{lstlisting}
int memory[3];

/* memory[0] is input and result */
fact_0:
  memory[1] = 1;
  memory[2] = 1;
  label t, fin;
t:
  memory[1] += 1;
  memory[2] *= memory[1];
  if (memory[1] > memory[0]) 
    goto fin;
  goto t;
fin:
  memory[0] = memory[2];
\end{lstlisting}

Некоторое время спустя, Алонсо Черч обнаружил, что очень сложные вычислительные процессы можно произвести, имея в своем распоряжении:

\begin{itemize}
\item ветвления (скажем оператор \lstinline!if! или тернарный оператор)
\item вызовы функций с передачей аргументов
\end{itemize}

В этом случае вообще не требуется изменяемых переменных.

И правда, факториал можно записать иначе:

\begin{lstlisting}
int
fact_1 (int x)
{
  if (x < 2)
    return x;
  else
    return fact_1 (x - 1);
}
\end{lstlisting}

Порождаемый таким образом рекурсивный процесс вычислительно не слишком эффективен, но аккумулятор тоже можно сымитировать, изменив факториал:

\begin{lstlisting}
int
fact_2_1 (int x, int idx, int product)
{
  if (idx > x)
    return product;
  else
    return fact_2_1 (x, idx + 1, product * idx);
}

int
fact_2 (int x)
{
  return fact_2_1 (x, 1, 1);
}

\end{lstlisting}

Интересно, что обычные программы на C++ больше похожи на подсахаренные машины Тьюринга (с поправкой на структурное программирование, взрослые циклы и вызовы функций). Но вот шаблоны... шаблоны больше похожи на подход Черча, который также называется функциональным стилем.

\subsubsection{Простая рекурсия и арифметика}

Однако, шаблоны. Начать следует с простой рекурсии и арифметики. 

\textbf{Задача:} вычислить N-ю степень числа 3

Пока что ведь неочевидно, что на шаблонах во время компиляции можно даже это. Всегда первый шаг: переписать в функциональном стиле

\begin{lstlisting}
int
three_to_n (int n)
{
  if (n == 0)
    return 1;
  else
    return 3 * three_to_n (n - 1);
}
\end{lstlisting}

Теперь вычислить N-ю степень числа 3 на этапе компиляции довольно просто:

\begin{lstlisting}
/* primary template to compute 3 to the Nth */
template<int N> 
struct Pow3 { 
  enum { result=3*Pow3<N-1>::result }; 
}; 

/* full specialization to end the recursion */
template<> 
struct Pow3<0> { 
  enum { result = 1 }; 
}; 

int main() 
{ 
    std::cout << "Pow3<7>::result = " << Pow3<7>::result 
              << '\n'; 
} 
\end{lstlisting}

Здесь значение \lstinline!Pow3<7>::result! будет вычислено до выполнения программы на этапе компиляции и впечатано в генерированный ассемблер как число. Давайте посмотрим по пунктам как это работает.

\begin{enumerate}
\item
\lstinline!Pow3<7>::result! раскрывается как \lstinline!3*Pow3<6>::result! и так далее до \lstinline!3*3*3*3*3*3*3*Pow3<0>::result!
\item
Для \lstinline!Pow3<0>::result! срабатывает частичная специализация и он превращается в \lstinline!1!
\item
Итого, в код будет после раскрытия шаблонов записано:
\begin{lstlisting}
int main() 
{ 
    std::cout << "Pow3<7>::result = " << 3*3*3*3*3*3*3*1                                         
              << '\n'; 
} 
\end{lstlisting}
\end{enumerate}

Это и выведет тривиально правильный результат. Пример специально подобран так, что написать в коде \lstinline!Pow3<7>::result! занимает столько же символов, сколько итоговая строчка. Выгода здесь в читабельности кода (общий смех). 

Вопрос к студентам: теперь кто напишет факториал?

Ответ:

\begin{lstlisting}
template <int n>
struct factorial 
{
  enum { value = n * factorial<n - 1>::value };
};
 
template <>
struct factorial<0> {
  enum { value = 1 };
};
\end{lstlisting}

Очень хорошо. Пора получить в руки пушку помощней.

\subsubsection{Ветвления и пример квадратного корня}

Обычная шаблонная специализация позволяет проверять только равенство. В метапрограммах можно делать также ветвления if-then-else\index{if-then-else template} с любыми, сколь угодно сложными условиями. Напишем простой шаблон:

\begin{lstlisting}
/* primary template: yield second or third argument depending on first argument */
template<bool C, typename Ta, typename Tb> 
struct IfThenElse; 

/* partial specialization: true yields second argument */
template<typename Ta, typename Tb> 
struct IfThenElse<true, Ta, Tb> 
{ 
  typedef Ta ResultT; 
}; 

/* partial specialization: false yields third argument */
template<typename Ta, typename Tb> 
struct IfThenElse<false, Ta, Tb> 
{ 
  typedef Tb ResultT; 
}; 
\end{lstlisting}

С помощью этого шаблона теперь можно легко написать, например, вычисление целочисленного квадратного корня во время компиляции.
И опять первый шаг: прикинуть код на C++ в функциональном стиле:

\begin{lstlisting}
int
isqrt (int N, int lo = 1, int hi = N)
{
  int mid = (lo + hi + 1) / 2;

  if (lo == hi)
    return lo;
  else
    {
      if (N < mid * mid)
        return isqrt (N, lo, mid - 1);
      else
        return isqrt (N, mid, hi);
    }
}
\end{lstlisting}

Теперь его можно перевести на шаблоны

\begin{lstlisting}
/* primary template for main recursive step */
template <int N, int LO = 1, int HI = N> 
struct Sqrt 
{ 
  /* compute the midpoint, rounded up */
  enum { mid = (LO+HI+1)/2 }; 

  /* search a not too large value in a halved interval */
  typedef typename IfThenElse<(N<mid*mid), 
                               Sqrt<N,LO,mid-1>, 
                               Sqrt<N,mid,HI> >::ResultT 
          SubT; 
  enum { result = SubT::result }; 
}; 

/* partial specialization for end of recursion criterion */
template <int N, int S> 
struct Sqrt <N, S, S> 
{ 
  enum { result = S }; 
}; 
\end{lstlisting}

Рассмотренные примеры показывают, что мы можем делать в метапрограммах ветвления и циклы (через рекурсию), хранить промежуточные данные и нам доступна целочисленная арифметика. Всего этого достаточно для того, чтобы доказать Тьюринг-полноту шаблонов C++\index{Turing completeness of templates}.

\subsubsection{Простые числа}

Благодаря вложенным классам, можно устраивать некую модульность в вычислениях и даже писать нечто, похожее на ``метаподпрограммы''. Большой пример с простыми числами сильно отличается от базового кода Анруха (его всегда можно найти в интернетах), но он несколько полезней, так как результаты печатаются не в виде ошибок, а доступны для использования.

\begin{lstlisting}
template <int i>
struct NthPrime
{
  template <int p>
  struct is_prime
  {
    template <int n>
    struct n_divisors
    {
      template <int N, int M>
      struct is_divisor
      {
        enum { val = is_divisor <N, M - 1>::val + ((N % M) == 0) };
      };

      template <int N>
      struct is_divisor <N, 1>
      {
        enum { val = 0 };
      };

      enum { val = is_divisor <n, n - 1>::val };
    };
    enum { val = (n_divisors <p>::val == 0) };
  };

  template <int n, int m>
  struct search_step
  {
    enum { val = search_step <n - (is_prime <m>::val), m + 1>::val };
  };

  template <int m>
  struct search_step <1, m>
  {
    enum { val = m - 1 };
  };

  enum { val = search_step <i, 3>::val };
};
\end{lstlisting}

Использование очевидно:

\begin{lstlisting}
int main(int argc, char* argv[])
{
  printf("Prime 6: %i\n", NthPrime<6>::val);
  return 0;
}
\end{lstlisting}

\textbf{Домашняя наработка:} коды Грея на шаблонах

\subsection{Мелкие детали шаблонов C++}

\begin{enumerate}
\item
Трюк с прокси-данными позволяет динамически выбрать зависимый тип для вложенных в шаблон данных

\begin{lstlisting}
template<typename T, template<typename> class C>
struct A {
  typename C<T>::type data;  /* trick to use a proxy */
};
\end{lstlisting}
\end{enumerate}

\pagebreak
\subsection{Домашняя наработка по шаблонам}

\begin{enumerate}

\item
Реализовать поиск подпоследовательности в последовательности (алгоритм Кнута-Морриса-Прата) как обобщённую функцию

\item
В разделе (\ref{ConstVsDef}) был приведен совет (исходно принадлежащий Скотту Майерсу) использовать где возможно \lstinline!const! вместо \lstinline!#define!. Нам могут возразить, что в этом случае простая проверка времени компиляции по значениям констант становится невозможной:
\begin{lstlisting}
#define T1 2
#define T2 3

/* compile-time check here */
#if T1!=T2
#error "T1 and T2 are inequal"
#endif
\end{lstlisting}

Как реализовать такую же проверку, определив T1 и T2 как статические константы, а не как макроопределения?

\item
Реализовать обобщённый класс \lstinline!Stack<T>! с конструктором копирования, оператором присваивания и функцией \lstinline!splice!

\item
Реализовать обобщённый класс \lstinline!BinaryTree<T>! с конструктором копирования и оператором присваивания

\item
Реализовать обобщённый класс \lstinline!Vector<T>! для хранения произвольных элементов и его специализацию \lstinline!Vector<bool>! для более компактного (суб-байтного) хранения нулей и единиц.

\item
Частично специализировать класс \lstinline!Stack<T*>! для указателей. Какие изменения это вызовет в дизайне класса.

\item
Написать аллокатор \lstinline!Allocator<T>! для произвольного класса и унаследовать от него через CRTP классы \lstinline!Stack!, \lstinline!Vector!, \lstinline!BinaryTree!

\item
Сделать иерархию обёрток сокетов (как минимум TCP и UDP) имеющей общий полиморфный шаблонный интерфейс. Продемонстрировать использование неким сервисом.

\item
Доработать обёрточный класс \lstinline!CFile! сделав его шаблонным

\item
Написать на шаблонах метапрограмму, генерирующую простые числа

\item
Написать на шаблонах метапрограмму, генерирующую числа Каталана

\item
Написать на шаблонах метапрограмму, генерирующую числа Бернулли 

\item
Написать на шаблонах метапрограмму, генерирующую числа Фибоначчи

\end{enumerate}

\pagebreak
\section{Правила для исключений\index{exceptions}}

Управляющие конструкции в программе делятся на local flow\index{local flow} -- обычные управляющие конструкции, такие как \lstinline!if!, \lstinline!for!, etc и non-local flow\index{non-local flow}. Последние пока не рассматривались, поскольку использование их в C-подмножестве C++ или даже при чистом объектно-ориентированном программировании, в том числе и с шаблонами, обычно не нужно и ведёт к проблемам. Но на этой лекции будет идти речь в основном о нелокальных техниках, таких как исключения C++. Давайте прежде перечислим некоторые типы нелокальной передачи управления:

\begin{itemize}
\item
Нелокальный GOTO (для C и для C++ это \lstinline!setjmp! и \lstinline!longjmp!)
\item
Continuations (более структурная форма GOTO, в C и C++ можно имитировать передачей указателя на функцию-continuation), 
\item
Исключения (для C++ это C++ exceptions)
\item
Coroutines, сопрограммы (популярны в Lua, но и в C++ после выхода нового стандарта есть экспериментальная библиотека Boost.Coroutine о которой мы возможно в будущем поговорим)
\item
Генераторы в стиле Python (являющиеся на самом деле подвидом coroutines, в C++ реализуемы через input iterators, о них мы тоже поговорим позднее)
\item
Экзотические вещи, такие как нотификации (обобщение исключений, реализованное в Lisp, не встречается в C++, но в принципе реализуемо через rethrow exceptions)
\item
Возможности операционной системы, такие как fibers (кооперативные легковесные нити исполнения)
\end{itemize}

Среди всех нелокальных управляющих конструкций, исключения выделяются своей особой ролью при обработке исключительных ситуаций, возникающих во время работы программы. Собственно от этого они и получили своё имя. Важно понимать, что является и что не является исключительной ситуацией чтобы не использовать исключения там где их не нужно использовать и наоборот не отказываться от использования исключений там, где они упрощают жизнь.

\begin{itemize}
\item
Исключительной ситуацией не является ошибка пользователя, такая как ввод неверно форматированного числа в ячейку электронной таблицы или попытка открыть файл неверного формата. Это нормальная ошибочная ситуация, которая может быть обработана локально.
\item
Исключительной ситуацией не является ошибка времени выполнения, такая как деление на ноль или assertion failure в программе. Лучшее что можно сделать с такой ошибкой это завершить выполнение и сбросить трассу.
\item
Исключительные ситуации характеризуются тем, что после них консистентное состояние программы восстановимо. Всегда лучше завершить программу, чем оставить её и её данные неконсистентными, но если у нас произошло переполнение стека, исчерпание памяти, не хватает прав на создание временного файла -- всё это обрабатываемые и потенциально устранимые проблемы.
\item
Исключительную ситуацию как правило нельзя обработать на том уровне, где она возникла. Глупо ожидать, что программа сортировки массива, столкнувшаяся с нехваткой памяти, обработает эту нехватку где-то между разбиением массива и рекурсивным вызовом на каждую из получившихся частей. Скорее всего она должна будет вернуть (возможно через неопределённое число уровней рекурсивного возврата) управление программе-драйверу, которая знает что делать (может быть захочет отсортировать тот же массив менее оптимальным алгоритмом но без использования дополнительной памяти).
\end{itemize}

Верный навык отличать где и как использовать исключения требует времени и внимания к деталям.

\pagebreak
\subsection{Исключения в C++\index{C++ exceptions}}

Поддержка исключений в C++ средствами языка проста и интуитивна. Код, обнаруживший исключение, генерирует объект исключения инструкцией \lstinline!throw <anything>!. Объект исключения может быть объектом некоего класса или любой другой переменной, или даже константой или литералом -- язык ничем здесь не ограничивает пользователя (и это уникально, поскольку большинство других языков требуют чтобы объект исключения входил в некую иерархию). 

\subsubsection{Что такое stack unwinding\index{stack unwinding}}

Что выведет на экран исполнение следующего кода?

\begin{lstlisting}
struct UnwShow
{
  UnwShow () { printf ("ctor\n"); }
  ~UnwShow () { printf ("dtor\n"); }
};

void
foo (int n)
{
  UnwShow s;
  if (n == 0) throw 1;
  foo (n - 1);
}

/* ... */
foo (3);

\end{lstlisting}

Казалось бы здесь программа забирается глубоко в рекурсию и оттуда бросает исключение раньше чем какой-либо из созданных объектов выйдет из поля зрения. Тем не менее, на экране видны не только четыре конструктора, но и четыре деструктора! Что произошло? Произошедшее называется \textbf{stack unwinding} и по русски обозначается как \textbf{размотка} или \textbf{раскрутка} стека.

\begin{figure}[h!]
\centering
\includegraphics[width=1.0\textwidth]{illustrations/stack-unwind-crop.pdf}
\caption{Stack Unwinding}
\label{fig:stack_unwind}
\end{figure}

Довольно сложно показать на статичном рисунке динамический процесс раскрутки, но идея кажется ясной -- все объекты, созданные от места входа в обработку исключений (пока что можно считать что просто от начала программы) до обработчика удаляются со стека корректно -- то есть с вызовом деструкторов.

\subsubsection{Как правильно поймать исключение}

Можно ли обрабатывать исключение самостоятельно? Да, когда дело касается исключений языка C++. Фрагмент кода выражает своё желание обрабатывать исключение с помощью конструкции \lstinline!try!. Результатом \lstinline!throw! является раскрутка стека до тех пор, пока не будет найден подходящий \lstinline!catch!, которому и передаётся управление.

Ниже следует очень плохой пример, так не надо делать никогда:

\begin{lstlisting}
class MathErr {/* ... */};
class Overflow : public MathErr {/* ... */};

void foo()
{
  try {
    /* ... dangerous code here ... */
  }
  catch (MathErr) {
    /* ... dealing with other guys ... */
  }
  catch (Overflow) {
    /* ... dealing with overflow ... */
  }
}
\end{lstlisting}

В приведённом примере исключения перехватываются по значению. Это очень плохо и ведёт к проблеме срезки, рассмотренной в (\ref{Cutting}). Хорошо написанный код перехватывает исключения по константной ссылке или по указателю (если это конечно не исключения POD-типов, которые программист также имеет право возбуждать, их можно перехватывать по значению).

Важно понимать, что обработчики проверяются по порядку перечисления. Поэтому ставить обработчик \lstinline!MathErr! выше чем \lstinline!Overflow!, означает сделать последний чуть более чем бесполезным.

\pagebreak
\subsubsection{Иерархия обработки исключений в стандартной библиотеке}

Хороший тон это генерировать потомка \lstinline!std::exception! или одного из его потомков в иерархии стандартной библиотеки.

\begin{figure}[h!]
\centering
\includegraphics[width=1.0\textwidth]{illustrations/exc-hier-crop.pdf}
\caption{Иерархия стандартных исключений}
\label{fig:exc_hier}
\end{figure}

Слева зелеными обозначены те классы, которые могут быть выброшены в процессе работы со стандартной библиотекой. Справа -- два основных класса, от которых вам предлагается наследовать свои классы-обработчики.

\begin{lstlisting}
class MathErr : public runtime_error {/* ... */};
class Overflow : public MathErr {/* ... */};

void foo()
{
  try {
    /* ... dangerous code here ... */
  }
  catch (const Overflow &) {
    /* ... dealing with overflow ... */
  }
  catch (const MathErr &) {
    /* ... dealing with other guys ... */
  }
}
\end{lstlisting}

Такой вариант кода гораздо более правилен и плюс есть доступ к многочисленным полезным методам этих классов, которые уже там есть.

\subsubsection{Обработка всех возможных исключений}

Опасной, но иногда необходимой конструкцией является перехват всех возможных исключений:

\begin{lstlisting}
void foo()
{
  try {
    /* ... dangerous code here ... */
  }
  catch (...) {
    /* ... dealing with everything??? ... */
  }
}
\end{lstlisting}

Если в вашем коде вы вынуждены использовать такую конструкцию, значит у вас проблемы с проектированием. Единственное исключение -- если вы используете внутри \lstinline!catch (...)! конструкцию перевыброса исключения (\lstinline!throw! без дополнительных аргументов).

\begin{lstlisting}
void foo()
{
  try {
    /* ... critical resource usage here ... */
  }
  catch (...) {
    /* ... cleaning up critical resource ... */
    throw; /* and rethrow */
  }
}
\end{lstlisting}

Перевыброшенное исключение продолжит размотку стека пока не будет поймано кем-то, кто знает как его обработать. Если выброшенное исключение не нашло своего обработчика, оно инициирует вызов функции \lstinline!terminate! и аварийный выход из программы. Кроме перевыброса того же исключения (\lstinline!throw! без параметра, которое может встретиться только внутри \lstinline!catch!-блока) вы можете в любом месте использовать \lstinline!throw! с параметром, для того чтобы бросить произвольное исключение. 

Вообще освобождение ресурсов с помощью деструкторов предпочтительней использования для этой цели \lstinline!try!-блоков с перехватом всех исключений.

Иногда перехват всевозможных исключений срабатывает неожиданно

\begin{lstlisting}
struct my_exc1 : std::exception { char const* what() const throw(); };
struct my_exc2 : std::exception { char const* what() const throw(); };
struct your_exc3 : my_exc1, my_exc2 {};

int main()
{
   try { throw your_exc3(); }
   catch(std::exception const& e) {}
   catch(...) { printf("whoops!\n"); }
}
\end{lstlisting}

Вопрос к студентам: как избежать здесь whoops?

Правильный ответ: виртуальное наследование.

\subsection{Вопросы безопасности исключений}

Исключения, являясь частным случаем нелокальной управляющей конструкции, добавляют строчки в неявный контракт на каждый метод и добавляют неожиданные дуги возможного выхода в каждом месте вызова небезопасной с точки зрения генерации исключений функции. Поэтому при проектировании кода, серьёзно использующего исключения, программист несёт дополнительную интеллектуальную нагрузку. Он должен следить за тем, что называется безопасностью кода относительно исключений.

\subsubsection{Гарантии безопасности исключений\index{Exception Safety Guarantees}}

Существует три гарантии безопасности, которые может предоставлять код:

\begin{itemize}
\item
\textbf{Базовая гарантия} заключается в том, что сбой при выполнении операции может изменить состояние программы, но не вызывает утечек и оставляет все объекты в согласованном (но не обязательно предсказуемом) состоянии, т.е. пригодными к дальнейшему использованию.
\item
\textbf{Строгая гарантия} обеспечивает транзакционную семантику: при сбое операции гарантируется неизменность состояния программы относительно задействованных в операции объектов.
\item
\textbf{Гарантия бессбойности} означает, что функция не генерирует исключений.
\end{itemize}

При написании кода на C++ следует придерживаться хотя бы одной из этих гарантий и предпочитать идиому RAII, которая рассматривалась в (\ref{RAII}). Также исключения не должны генерироваться деструкторами, функциями, освобождающими ресурсы и функциями обмена.

\subsubsection{Безопасное копирование}

Вернемся к шаблонному классу стека и теперь попытаемся сделать его безопасным относительно исключений, в целом следуя изложению в \cite{exceptionalcpp}. На первый взгляд, интерфейс стека может выглядеть как-то вот таким образом:

\begin{lstlisting}
template <typename T> 
class Stack
{
public:
  Stack(): m_v(new T[10]), m_vsize(10), m_vused(0) {}
  ~Stack() { delete [] v; }
  Stack(const Stack&);
  Stack& operator= (const Stack&);
  void Push(const T&);
  T Pop();
private:
  T* m_v;
  size_t m_vsize;
  size_t m_vused;
};
\end{lstlisting}

Конструктор и деструктор уже тривиально безопасны (если исключения не выходят за \lstinline!delete[]!, но они и не должны за него выходить). Сложнее с копированием и копирующим присваиванием. Проще всего сделать безопасным копирующий конструктор, определив шаблон общей вспомогательной функции \lstinline!safe_copy!, копирующей буфер в заданный с перехватом всех возможных исключений и освобождением ресурсов.

\begin{lstlisting}
template <typename T>
T *safe_copy(const T* src, size_t srcsize, size_t destsize)
{
  size_t idx;
  T * dest;
  assert (destsize >= srcsize);
  dest = new T[destsize];
  try 
    {
       for (idx = 0; idx != srcsize, ++idx)
         dest[idx] = src[idx];
    }
  catch (...)
    {
       delete [] dest;
       throw;
    }
  return dest;
}
\end{lstlisting}

Вопрос к студентам: почему цикл, а не не \lstinline!memcpy!?

Правильный ответ: потому что должны быть вызваны операторы присваивания для \lstinline!T!.

Вопрос к студентам: где в этой функции могут быть сгенерированы исключения?

Внутри этой функции исключения могут быть сгенерированы:

\begin{itemize}
\item
В функции \lstinline!new!, переопределённым для \lstinline!T! оператором \lstinline!operator new! или конструктором  \lstinline!T! -- в этом случае никакой памяти выделено не будет и утечки не произойдёт, а исключения покинут  \lstinline!safe_copy!
\item
В функции  \lstinline!operator=! или  \lstinline!operator[]! типа  \lstinline!T! при копировании. В этом случае исключения будут перехвачены, ресурсы освобождены и исключения отпущены дальше.
\end{itemize}

Имея эту функцию, уже можно разработать симпатичный конструктор копирования

\begin{lstlisting}
template <typename T>
Stack<T>::Stack(const Stack& rhs) : m_v(safe_copy(rhs.m_v, rhs.m_vsize, rhs.m_vsize)), 
                                 m_vsize(rhs.m_vsize), 
                                 m_vused(rhs.m_vused) 
{
}
\end{lstlisting}

Единственный источник исключений здесь -- \lstinline!safe_copy!, в которой никакой утечки быть не может. Общий урок раздела заключается в том, что все места, где может быть сгенерировано исключение полезно собрать в одну вспомогательную функцию для использования безопасным образом.

\subsubsection{Безопасное присваивание и copy-and-swap idiom}

Теперь присваивание. Саттер рекомендует сделать присваивание следующим образом:

\begin{lstlisting}
template <typename T>
Stack<T>& Stack<T>::operator=(const Stack<T>& rhs)
{
  T *v_new;

  if (this == &rhs)
    return *this;

  v_new = safe_copy(rhs.m_v, rhs.m_vsize, rhs.m_vsize);
  delete [] m_v;
  m_v = v_new;
  m_vsize = rhs.m_vsize; 
  m_vused = rhs.m_vused;
  return *this;
}
\end{lstlisting}

Таким образом состояние остаётся неизменным и даже при генерации исключения, оно выходит наружу не нарушая консистентности объекта.

Но этот подход кажется несколько избыточным. Вместо него можно воспользоваться уже имеющимся конструктором копирования.

\begin{lstlisting}
/* Copy ctor reused on argument construction! */
template <typename T>
Stack<T>& Stack<T>::operator=(const Stack<T> rhs)
{
  std::swap (rhs.m_v, this->m_v);
  std::swap (rhs.m_vsize, this->m_vsize);
  std::swap (rhs.m_vused, this->m_vused);
}
\end{lstlisting}

Здесь \lstinline!swap! это обмен значениями из стандартной библиотеки (он никогда не кидает исключений т.к. работает с примитивными типами). Можно думать об этой функции как о стандартном варианте:

\begin{lstlisting}
template <typename T>
void swap(T& a, T& b)
{
  T temp(a);
  a = b;
  b = temp;
}
\end{lstlisting}

Но не стоит реализовать его таким образом самостоятельно, пока что лучше взять стандартный. В последующих лекциях будут рассмотрены гораздо лучшие варианты реализации обмена с помощью rvalue references.

Можно написать метод \lstinline!Stack<T>::swap! и тогда код присваивания упростится до одной строчки.

Этот подход называется copy-and-swap идиомой и содержит важный урок -- переиспользование кода не только облегчает его написание и понимание, но и помогает обеспечить безопасность исключений для этого кода.

\textbf{Домашняя наработка:} реализовать безопасное помещение в стек. Можно ли переиспользовать \lstinline!swap! или \lstinline!safe_copy!?

\subsubsection{Неявное копирование и безопасность исключений}

Проблемы, как обычно, подстерегают там, где их не ждали. Давайте рассмотрим метод \lstinline!Pop()!, который пока что остался не реализованным. К сожалению, его реализация только кажется простой.

\begin{lstlisting}
template <typename T>
T Stack<T>::Pop(void)
{
  T result;

  assert(m_vused > 0);
  result = m_v[m_vused - 1];
  m_vused -= 1;
  return result;
}
\end{lstlisting}

Вся проблема с этим кодом заключается в его возможном использовании:

\begin{lstlisting}
Stack<Sometype> s;
SomeType s2;
/* .. some code .. */
s2 = s.Pop();
\end{lstlisting}

В последней строчке происходит копирование возвращаемого \lstinline!SomeType! в место назначения. Если в этот момент возникнет исключение, то все побочные эффекты со стеком уже окажутся учтены -- элемент будет снят с верхушки, но он пропадёт безвозвратно. Именно поэтому в коде стандартной библиотеки и в любом безопасном относительно исключений коде, эти операции разделены:

\begin{lstlisting}
template <typename T> 
class Stack
{
public:
  Stack(): m_v(new T[10]), m_vsize(10), m_vused(10) {}
  ~Stack() { delete [] v; }
  Stack(const Stack&);
  Stack& operator= (const Stack&);
  void Push(const T&);
  T& Top();
  void Pop();
private:
  T* m_v;
  size_t m_vsize;
  size_t m_vused;
};
\end{lstlisting}

Метод \lstinline!Top()! даёт верхний элемент но не модифицирует стек, метод \lstinline!Pop()! модифицирует стек но не возвращает никакого значения, безопасность исключений соблюдена. Основной урок здесь состоит в том, что безопасность исключений действительно влияет на проектирование класса и думать о ней необходимо уже на этапе проектирования.

\subsubsection{Идиома PImpl\index{PImpl} для безопасного кода}

В \cite{exceptionalcpp} предложена элегантная идиома для написания безопасного относительно исключений кода -- \textbf{Pointer to Implementation} или сокращённо PImpl. Поскольку проблемы утечки ресурсов вызваны работой с ресурсами (в данном случае -- с памятью), эту работу можно инкапсулировать в специальный класс с изящным интерфейсом. Сначала необходимо написать две вспомогательные функции. Первая \lstinline!destroy! вызывает деструктор объекта, не освобождая его память

\begin{lstlisting}
template <class T> void
destroy(T* p)
{
  p->~T();
}
\end{lstlisting}

Вторая \lstinline!construct! создает объект в существующей памяти через placement new, который был рассмотрен в (\ref{PlacementNew}) (тут можно позвать кого-нибудь написать у доски).

\begin{lstlisting}
template <class T1, class T2> void
construct (T1 *p, const T2 &value)
{
  new (p) T1 (value);
}
\end{lstlisting}

И далее -- более сложная функция \lstinline!destroy! уничтожает содержимое обобщённого forward-итерируемого контейнера:

\begin{lstlisting}
template <typename FwdIter>
void destroy( FwdIter first, FwdIter last )
{
  while ( first != last )
    {
      destroy( &*first ); 
      ++first;
    }
}
\end{lstlisting}

Теперь код, прячущий за своим фасадом работу с ресурсами типа T, может быть реализован в терминах этих обобщённых функций:

\begin{lstlisting}
template <typename T>
class StackImpl
{
protected:
  StackImpl(size_t size = 0): m_v(operator new (sizeof(T) * size)), m_vsize(size), m_vused {}
  ~StackImpl() { destroy(m_v, m_v + m_vused); operator delete(m_v); }
  void Swap(StackImpl<T> &other) 
  {
    swap( m_v, other.m_v );
    swap( m_vsize, other.m_vsize );
    swap( m_vused, other.m_vused );
  }
  T *m_v;
  size_t m_vsize, m_vused;
private:
  StackImpl(const StackImpl &);
  StackImpl& operator= (const StackImpl &);
};
\end{lstlisting}

Используя этот класс, можно реализовать приватно наследующий от него стек

\begin{lstlisting}
template<typename T> 
class Stack : private StackImpl<T>
{
public:
  Stack( size_t size = 0 ) : StackImpl<T>(size) {}
  Stack( const Stack& other ) : StackImpl<T>(other.m_vused)
  {
    while( m_vused < other.m_vused )
      {
        construct (m_v + m_vused, other.m_v[m_vused]);
        m_vused += 1;
      }
  }

  Stack<T>& operator = (const Stack<T>& other)
  {
    Stack tmp(other);
    this->stack_swap(tmp);
    return *this;
  }
 
  size_t count() const { return m_vused; }

  void push( const T& value )
  {
    if( m_vused == m_vsize )
      {
        Stack tmp(2*m_vsize + 1);
        while (tmp.count() < m_vused)
          tmp.push (m_v[tmp.count()]);

        tmp.push (value);
        this->stack_swap (tmp);
      }
    else
      {
        construct( m_v + m_vused, value );
        ++m_vused;
      }
  }

  T& top() {return m_v[m_vused - 1];}

  void pop()
  {
    --m_vused;
    destroy (m_v + m_vused);
  }
};
\end{lstlisting}

Он удовлетворяет гарантии бессбойности -- самой строгой из трёх гарантий Абрамса -- ни одна из его функций не генерирует исключений и безопасна.

\subsubsection{Что нельзя деструкторам и можно нам}

В предыдущем разделе функция \lstinline!destroy! могла вызвать обоснованную критику: она очевидно не защищена от ситуации когда деструктор уничтожаемого объекта выбрасывает исключение. Программист мог бы попробовать переписать её в защищённом стиле:

\begin{lstlisting}
template <typename FwdIter>
void destroy( FwdIter first, FwdIter last )
{
  while ( first != last )
    {
      try 
        {
          destroy( &*first ); 
        }
      catch (...)
        {
          /* what to do here? */
        }
      ++first;
    }
}
\end{lstlisting}

Основная проблема -- что делать в обработчике. Есть три идеи и все три очень плохи.
\begin{enumerate}
\item
Можно снова генерировать в обработчике перехваченное исключение. Тогда функция удовлетворяет гарантии нейтральности... и, пожалуй, всё. При этом destroy не сможет сообщить о количестве корректно уничтоженных объектов и не уничтоженные останутся не уничтоженными, что вызовет утечку ресурсов
\item
Можно, перехватывая исключение, генерировать некое другое исключение. Тогда функция не удовлетворяет гарантии нейтральности и всё равно может вызвать утечку
\item
Можно, перехватывая исключения, как-то гасить их (может быть с некоторой обработкой). Но тогда функция не удовлетворяет гарантии нейтральности и, с точки зрения вызывающей функции, скрывает ошибки
\end{enumerate}

Итак, если деструктор \lstinline!T! может генерировать исключения, всё сведётся к написанию в лучшем случае небезопасного кода. Этой проблеме также подвержены невинно выглядящие \lstinline!new[]! и \lstinline!delete[]!, о которых шла речь в (\ref{newdelete}).

\begin{lstlisting}
T *arr = new T[10];
delete [] arr;
\end{lstlisting}

Вопрос к аудитории: как будет вести себя этот код, если предположить, что деструктор \lstinline!T! может генерировать исключения?

Вывод из этого довольно прост: никогда не пишите типы, деструкторы которых, могут сгенерировать исключения. Гораздо сложнее тема с генерацией исключений конструкторами, но её я склонен оставить на самостоятельное изучение по \cite{exceptionalcpp}

\subsection{Исключения под капотом\index{setjmp}\index{longjmp}}

Для того, чтобы лучше понимать исключения, бывает полезно попробовать реализовать их руками (как это было сделано с виртуальными функциями ранее). Пример заменяет тысячу слов. Допустим функция \lstinline!allocate! вызывает \lstinline!malloc! чтобы выделить n байт, и возвращает указатель, который вернул \lstinline!malloc!. Если же \lstinline!malloc! возвращает нулевой указатель, что индицирует нехватку памяти, \lstinline!allocate! делает нечто похожее на возбуждение исключения \lstinline!Allocate_Failed! (без размотки стека и вызова деструкторов пока что). Исключение само по себе имеет тип \lstinline!jmp_buf!, который определён в стандартном хедере \lstinline!setjmp.h!:

\begin{lstlisting}
#include <setjmp.h>

int Allocation_handled = 0;
jmp_buf Allocate_Failed;
\end{lstlisting}

\lstinline!Allocation_handled! ноль, пока обработчик не инстанциирован и \lstinline!allocate! проверяет \lstinline!Allocation_handled! прежде чем возбуждать исключение:

\begin{lstlisting}
void *allocate(unsigned n) {
  void *new = malloc(n);
  if (new)
    return new;
  if (Allocation_handled)
    longjmp(Allocate_Failed, 1);
  assert(0);
}
\end{lstlisting}

И теперь можно сделать практически \lstinline!try! и \lstinline!catch!:

\begin{lstlisting}
/* try { */
Allocation_handled = 1;
if (setjmp(Allocate_Failed)) {
  goto alloc_except_label;
}

/* ... here some code, calling somewhere allocate() */

/* } */
/* catch (...) { */
alloc_except_label:
/* ... here processing exception */
Allocation_handled = 0;
/* } */
\end{lstlisting}

Осталось добавить раскрутку стека и прочий сахар, который насыпан для этого в C++, но идея должна быть уже понятна.

\pagebreak
\subsection{Домашняя наработка по исключениям}

\begin{enumerate}

\item Разработайте безопасный относительно исключений шаблон \lstinline!Vector<T>! на основе идиомы PImpl. Функция \lstinline!push_back! или её аналог должна сообщать о нехватке памяти, выбрасывая исключение.

\item Предложите и реализуйте набор тестов для шаблона \lstinline!Stack<T>! для того, чтобы убедиться, что он поддерживает строгую транзакционную семантику.

\item Оцените где могут возникнуть исключения в следующем коде? Является ли он безопасным относительно исключений?

\begin{lstlisting}
std::vector <T>
bitvise_or (std::vector <T> a, std::vector <T> b)
{
  if ((a.size () == 0) || (b.size () == 0))
    std::cout << "Nothing to or with" << std::endl;
  else if (a.size () != b.size ())
    std::cout << "Can not process arrays of inequal size" << std::endl;
  else if (a.size () > 10)
    std::cout << "Arrays too large" << std::endl;
  else
    {
      std::vector <T> ret (a.size ());
      for (std::vector <T>::iterator i = a.begin (), j = b.begin (), k = ret.begin (); 
           i != a.end (); 
           i++, j++, k++)
        *k = *i | *j;
      return ret;
    }
}
\end{lstlisting}

Предложите как его улучшить.

\end{enumerate}

\pagebreak
\section{Два лица стандартной библиотеки}

Стандартная библиотека языка C++ имеет долгую и интересную историю. Идея стандартизировать библиотеку в языке C (из которой позже выросла стандартная библиотека C++) возникла не сразу. Первая стандартизация библиотеки языка C это стандарт ANSI C 1989-го и последовавший за ним ISO/IEC 9899-1990 \cite{stdc90}. Эта библиотека известна под названиями libc или crt (от C run-time support) и часто модифицировалась и подвергалась изменениям и расширениям. Стандартная библиотека C++-98, включает стандартную библиотеку C по нормативной ссылке, добавляя к ней свои части, известные ранее под общим названием STL и расширенные (и постоянно расширяемые в новых стандартах) комитетом по стандартизации.

Идея что включать и что не включать в стандартную библиотеку языка программирования не так тривиальна, как может показаться: 
\begin{itemize}
\item
Некоторые языки поставляются с библиотеками включающими всё, что может понадобиться когда бы то ни было, включая крайне высокоуровневые функции работы с XML, базами данных, сетевыми протоколами. Это философия таких языков как Python, Java, C\#, которые идут ``с батарейками внутри''.
\item
Стандартная библиотека языка С (и некоторых других) придерживается, наоборот, философии минимальной поддержки, включая только те функции, которые могут пригодиться каждому разработчику (и некоторые функции, которые вызвали слезы няшного умиления у комитета стандартизации и оставлены, хотя не нужны, пожалуй, вообще никому, например strcspn).
\item
Язык C++ занимает промежуточную позицию. По своей задумке его библиотека придерживается второго подхода, но по факту от стандарта к стандарту асимптотически сходится к первому.
\end{itemize}

Этот раздел посвящен рассмотрению стандартной библиотеки C++ как составного, ``двуединого'' целого из унаследованной стандартной библиотеки C и добавленных к ней средств, таких, как шаблонные контейнеры, итераторы, алгоритмы, потоковый ввод и вывод и так далее. При этом две её части находятся в диалектическом конфликте (знакомом каждому, кто хоть раз пробовал смешивать их средства), но и в диалектическом единстве взаимной поддержки. Начать, впрочем, следует с некоторого обновления предыдущего материала.

\subsection{Перегрузка операции вызова}

В разделе (\ref{OperatorOverloading}) уже рассматривались несколько интересных частных случаев переопределения операторов. Но к этому разделу остался один из наиболее важных и удивительных случаев перегрузки -- перегрузка вызова. Эта перегрузка позволяет объекту быть вызванным как функция (с круглыми скобками и передачей аргументов).

\begin{lstlisting}
class LessThan
{
public:
  explicit LessThan(int x = 0) : m_x(x) {}
  bool operator()(int y) const { return y < m_x; }
private:
  int m_x;
}
\end{lstlisting}

Определённый таким образом класс, позволяет иметь сразу несколько функцие-подобных объектов (также они называются \textbf{функторы}\index{Functor}), выражающих предикаты ``меньше x'' для разных \lstinline!x!.

\begin{lstlisting}
LessThan ltthree(3), ltfour(4), ltfive(5);

assert(ltthree(2));
assert(!ltthree(4));
\end{lstlisting}

И вызывать их по необходимости (необходимость станет очевидной ниже).

К сожалению, функторы \textbf{не являются} взаимозаменяемыми с указателями на функции. Если некая функция ждёт указатель, передать ей функтор даже с той же сигнатурой -- нельзя. К счастью, при работе с неявными шаблонными интерфейсами, требование к типу быть выполнимым-как-функция позволяет прозрачно передавать и функторы и указатели на функции в качестве такого типа.
 
\begin{lstlisting}
template <typename FuncType>
int filtered_sum(int numbers[], int len, FuncType pred)
{
  int i, a = 0;

  for (i = 0; i != len; ++i)
    if (pred(numbers[i]) { a += numbers[i]; }

  return a;
}
\end{lstlisting}

Суть и сердце библиотеки C++ это абстрактные алгоритмы над обобщёнными контейнерами. Переопределение вызова и создание функцие-подобных объектов позволяет писать обобщённый код, прекрасным примером которого является алгоритм \lstinline!for_each!, определённый примерно так:

\begin{lstlisting}
template <typename Iterator, typename Operation>
Operation for_each(Iterator act, Iterator end, Operation op)
{
  while(act != end)
    {
       op(*act);
       ++act;
    }
  return op;
}
\end{lstlisting}

Если третий параметр является обычной функцией, она будет вызвана для каждого разыменованного \lstinline!act!. Операторы разыменования и инкремента, разумеется, тоже могут быть переопределены (причём пред и постинкремент могут быть переопределены отдельно).

\textbf{Домашняя наработка:} проработайте самостоятельно переопределение операций размыенования и разыменования по указателю. Возникли ли у вас какие-нибудь вопросы?

\pagebreak
\subsection{Контейнеры}

Контейнеры STL отражают абстракцию структур данных. Все практически важные структуры уже представлены или могут быть представлены контейнерами. Наиболее известны следующие контейнеры:

\begin{itemize}
\item \textbf{vector} -- массив с гарантиями непрерывной области памяти и динамическим ростом с одной стороны
\item \textbf{deque} -- массив со странично организованной памятью и ростом с двух сторон.
\item \textbf{list} -- связный список с быстрой вставкой и удалением элементов
\item \textbf{map} -- ассоциативный массив (обычно сделанный в виде красно-чёрного дерева)
\end{itemize}

Все контейнеры STL поддерживают общие операции: \lstinline!size()!, \lstinline!empty()!, \lstinline!max_size()!, операторы сравнения, \lstinline!swap()!, \lstinline!begin()!, \lstinline!end()!, \lstinline!rbegin()!, \lstinline!rend()!, \lstinline!insert()!, \lstinline!erase()!, \lstinline!clear()! и некоторые другие, которые в совокупности можно считать шаблонным интерфейсом, имплементируя который любой класс так же может называться контейнером STL.

Любой контейнер содержит конструктор по умолчанию, копирующий конструктор и открытый невиртуальный деструктор. Последнее крайне важно. Стандарт, нормы коммьюнити, а иногда даже и сообщения компилятора прямо и недвусмысленно \textbf{запрещают} наследование от шаблонных контейнеров стандартной библиотеки. Как мы помним из \ref{virtdestr}, наличие невиртуального деструктора в классе -- достаточное основание никогда ничего от него не наследовать.

\subsubsection{Требования к элементам контейнеров STL}

Контейнеры STL являются шаблонами, а все шаблонные интерфейсы являются неявными. Поэтому программист должен хорошо знать неявные требования, предъявляемые к элементам контейнеров, как к чему-то, что может быть помещено в данный контейнер.

\begin{itemize}
\item \textbf{Копируемость} -- у объекта должен быть определён стандартный или пользовательский копирующий конструктор, который должен действительно копировать объект
\item \textbf{Изменяемость} -- объект должен быть lvalue с действительным оператором присваивания
\item \textbf{Конструируемость} -- хотя бы один из конструкторов и хотя бы один из деструкторов объекта должны быть открытыми
\end{itemize}

Некоторые контейнеры определяют дополнительные неявные требования, такие как наличие критерия сортировки (для упорядоченных конструкций) или конструктора по умолчанию.

\subsubsection{От массивов к \lstinline!std::vector!}\label{vectorarrs}

Одной из главных проблем, которые красной нитью проходили через все лекции была проблема управления памятью. Правильно спаривать \lstinline!new! и \lstinline!delete!, использовать RAII для управления ресурсами, управлять памятью в безопасном для исключений стиле -- всё это важные и нужные навыки. Но внутри стандартной библиотеки содержится контейнер, который для большинства практических случаев позволяет в принципе избегать явного использования динамической памяти. Это класс \lstinline!vector!. Он определён в заголовке \lstinline!<vector>! стандартной библиотеки как:

\begin{lstlisting}
template <typename T, typename Allocator = allocator<T> >
class vector;
\end{lstlisting}

Таким образом вместо

\begin{lstlisting}
int *n = new int[10];
n[5] = 5;
\end{lstlisting}

Можно писать

\begin{lstlisting}
std::vector<int> n(10);
n[5] = 5;
\end{lstlisting}

Для достижения такого эффекта, вектор использует переопределение оператора квадратных скобок. Это похоже на переопределение оператора круглых скобок, рассмотренное ранее.

Вектора в C++ также поддерживают операцию \lstinline!push_back!, для динамического роста. К сожалению, это убивает детерминированность в работе вектора с памятью, поэтому аккуратный программист всегда использует резервирование памяти для того, чтобы исключить перераспределение при добавлении пары элементов

\begin{lstlisting}
std::vector<int> n;
n.reserve(80); /* place for 80 ints */
\end{lstlisting}

Но зарезервированное место ещё не распределено, поэтому вызывать квадратные скобки можно только с реальным индексом -- не превосходящим \lstinline!n.size()!.

Использовать вектор всегда предпочтительней, чем работать с массивами напрямую. Например, представьте код:

\begin{lstlisting}
template <typename T>
T foo (int n)
{
  T *t = new T[n], ret = 0;

  init_t (t, n); /* <--- exception here inside init */
  
  for (int i = 0; i < n; ++i)
    {
      if (!check_legal(t[i])
        {
          delete [] t; /* <--- dont forget to free memory here */
          throw std::runtime_error("Illegal element");
        }

      ret += t[i]; /* <--- exception here in operator += for T */
    }

  delete [] t;

  return ret;
}
\end{lstlisting}

Он изобилует проблемами и местами, где возможна утечка. К тому же его элементарно сложно читать. Давайте посмотрим как этот код магически трансформируется в нечто гораздо более прозрачное и безопасное.

\begin{lstlisting}
template <typename T>
T foo (int n)
{
  std::vector<T> t(n);
  typedef std::vector<T>::iterator iter_t;

  T ret = 0;

  init_t (&t[0], n); /* legal! vector in memory laid out continously */

  for (iter_t a = t.begin(); a != t.end(); ++a)
    {
      if (!check_legal(*a))
        throw std::runtime_error("Illegal element");

      ret += t[i];
    }

  return ret;  
}
\end{lstlisting}

При выбросе исключения, память под вектором будет корректно освобождена. Явный цикл теперь не подвержен ошибкам индексов и по сути является циклом \lstinline!for_each!. И главное, программа стала невероятно C++-стильной и сразу выдаёт в вас чуть более крутого разработчика, чем раньше. Впрочем, тут ещё есть, что улучшать. Когда разговор зайдёт про алгоритмы, это будет сделано и вы увидите космос.

\subsubsection{От обработки строк в стиле C к \lstinline!std::string!}\label{CStringToStdString}

Стандартная библиотека языка C и все её возможности по ссылке включены в стандарт C++ и могут использоваться, как обычно. Но добавленный также класс \lstinline!basic_string! и его специализации \lstinline!string! и \lstinline!wstring! позволяют делать то же самое гораздо безопаснее и во многом проще (иногда ценой производительности).

Представим каноническую задачу -- заменить в строке все подстроки данного вида. Скажем в строке \lstinline!"Hello, $username, how are you doing, $username?"! заменить все вхождения \lstinline!$username! на \lstinline!Eric, the Bloody Axe!.

Попросить студентов написать это на C++ без \lstinline!std::string!

Задача, как видите, непроста и требует некоторого размышления. Между тем на современном C++ она решается очень просто (даже не используя алгоритмов стандартной билиотеки, просто с помощью встроенных средств типа string)

\begin{lstlisting}
void
replace_all (std::string& str,
             const std::string& from,
             const std::string& to)
{
  size_t start_pos = 0;

  if(from.empty())
    return;

  while((start_pos = str.find(from, start_pos)) != std::string::npos)
    {
      str.replace(start_pos, from.length(), to);
      start_pos += to.length(); // In case 'to' contains 'from', like replacing 'x' with 'yx'
    }
}
\end{lstlisting}

Как использовать эту функцию?

\begin{lstlisting}
int
main (void)
{
  std::string str = "Hello, $username, how are you doing, $username?";
  std::string from = "$username";
  std::string to = "Eric, the Bloody Axe";

  replace_all (str, from, to);

  std::fprintf (stderr, "%s\n", str.c_str());

  return 0;
}
\end{lstlisting}

Обратите особое внимание на метод \lstinline!c_str()!, позволяющий получить C-строку для использования в функциях, где нужно C API (скажем \lstinline!fprintf!).

\pagebreak
\subsection{Итераторы}

Итератор является обобщением понятия указателя, с которым к этому моменту уже не должно возникать проблем. Какие два свойства можно выделить у указателя, которые делают его полезным при обходе массива?

\begin{enumerate}
\item Указатель может быть использован для доступа к тому элементу на который он указывает
\item При инкременте, указатель позволяет перейти от данного элемента к следующему (в каком бы смысле не понималось отношение последования)
\item Указатель может иметь специальное значение (например NULL), позволяющая проверить, что дальнейший переход невозможен
\end{enumerate}

Все те же свойства можно отнести к итератору, который, разумеется, может быть объектом гораздо более сложной структуры, чем указатель. Важно то, что если указатель не слишком изолирует от реальности лежащих под ним данных, то итератор в общем случае независимо от того какие данные он ``указывает'' позволяет работать с ними прозрачным образом.

У каждого контейнера стандартной библиотеки может быть получен типизированный итератор в положении начала контейнера \lstinline!begin()! и конца контейнера \lstinline!end()!

\subsubsection{От указателей к итераторам}\label{PointersToIterators}

Допустим, есть массив и функция, которая обходит этот массив и что-то на нем выполняет:

\begin{lstlisting}
template <typename F>
int process_arr(int *arr, int key, F cmp)
{
  while (arr != 0)
    {
      if (F (*arr, key)) 
        return (*arr);
      arr += 1; 
    }  
}
\end{lstlisting}

Теперь допустим есть не массив а список:

\begin{lstlisting}
template <typename F>
int process_list(list_t *list, int key, F cmp)
{
  while (list != 0)
    {
      if (F (list->data, key)) 
        return (list->data);
      list = list->next;
    }  
}
\end{lstlisting}

Этот код очень похож, но при попытке его обобщить возникают проблемы. Для обобщения нужен общий интерфейс. Если договорится, что и массив и список предоставляют такой интерфейс, то можно написать общий код:

\begin{lstlisting}
template <typename T, typename F>
int process_list(const T& t, int key, F cmp)
{
  typename T::iterator i = t.begin();
  while (i != t.end())
    {
      if (F (*i, key)) 
        return (*i);
      i++;
    }  
}
\end{lstlisting}

В этом коде тип \lstinline!T! удовляетворяет трём условиям: он содержит зависимый тип итератора \lstinline!T::iterator!, а также функцию \lstinline!begin()! для возврата итератора на своё начало и \lstinline!end()! для итераторая на свой конец

\subsubsection{Какие бывают итераторы}

Настало время узнать про итераторы больше. 

По cv-квалификации и направлению доступа различают:

\begin{itemize}
\item \lstinline!iterator!
\item \lstinline!const_iterator!
\item \lstinline!reverse_iterator!
\item \lstinline!const_reverse_iterator!
\end{itemize}

Каждый совместимый контейнер должен определять все четыре зависимых типа для итераторов:

\begin{lstlisting}
for(vector<int>::iterator i = randomData.begin() ; i != randomData.end() ; ++i)
{
/* modify *i */
}

for(vector<int>::const_iterator i = randomData.begin() ; i!= randomData.end() ; ++i) 
{
/* *i is readonly */;
}
\end{lstlisting}

По способу доступа к элементам контейнера, итераторы делятся на:

\begin {itemize}
\item output
\item input
\item forward
\item bidirectional
\item random access
\end {itemize}

Увы, это деление (в отличии от предыдущего) ничем формально не подкреплено. Имея некий неясный контекст, нельзя определенно сказать ``здесь forward iterator, здесь прыгай'' (по крайней мере пока не доделают концепты).

Можно ввести некоторые свойства перенумеровав их для наглядности:

\begin {enumerate}
\item
Поддержка создания по умолчанию, копирующего конструктора и присваивания, а также деструктора

\begin{lstlisting}
X a;
X b(a);
b = a;
\end{lstlisting}

\item
Возможность разыменования как rvalue и доступа к полям по указателю

\begin{lstlisting}
x = *a;
y = a->t;
\end{lstlisting}

\item
Возможность разыменования как lvalue

\begin{lstlisting}
*a = t;
\end{lstlisting}

\item
Поддержка инкремента и постинкремента

\begin{lstlisting}
++a;
a++;
\end{lstlisting}

\item
Сравнимость на равенство/неравенство

\begin{lstlisting}
a == b
a != b
\end{lstlisting}

\item
Поддержка декремента и постдекремента

\begin{lstlisting}
--a;
a--;
\end{lstlisting}

\end {enumerate}

Тогда сопоставляя наборы свойств, имеем:

\begin {itemize}
\item output -- (1, 3, 4)
\item input -- (1, 2, 4, 5)
\item forward -- тоже (1, 2, 4, 5) но при этом подытераторный тип должен поддерживать присваивание
\item bidirectional -- (1, 2, 4, 5, 6)
\item random access -- (1, 2, 4, 5, 6) а также поддержка \lstinline!operator []!, сложения с константой, вычитания константы и сравнения на больше и меньше.
\end {itemize}

Таким образом требование к чему-то ``быть forward итератором'' это аббревиатура к набору условий на этот тип.

\subsubsection{Линейный обход ассоциативных контейнеров}

Ассоциативные контейнеры включают в себя множества (set) отображения (map), мультимножества (multiset) и мультиотображения (multimap).

Типичный пример работы с \lstinline!map! -- программа для подсчёта слов во входном файле и выдачи их частот в процентах.

\begin{lstlisting}
const int MAXLEN = 128;

int main(int argc, char** argv)
{
  char buf[MAXLEN];
  std::map <std::string, int> words;
  int count = 0;
  FILE *f;

  assert (argc > 0);

  f = fopen (argv[1], "r");
  assert (f != 0);

  while (std::fscanf(f, "%s", buf) > 0)
    {
      std::string word = buf;
      words[word] += 1;
      count += 1;
    }

  for (std::map <std::string, int>::iterator cur = words.begin();
       cur != words.end();
       cur++)
    fprintf (stdout, "%s -- %.3f%%\n", cur->first.c_str(), ((double)cur->second / count) * 100.0);

  return 0;
}
\end{lstlisting}

Надо понимать, что внутреннее представление \lstinline!map! это скорее всего красно-черное дерево. Интерфейс \lstinline!map <std::string, int>::iterator! позволяет устроить линейный inorder обход узлов дерева.

\pagebreak
\subsection{Алгоритмы}

Пример \lstinline!process_list! приведенный в \ref{PointersToIterators} сам по себе является довольно обобщенным кодом, который благодаря механизму итераторов, способен выполнять некие нетривиальные действия над любым совместимым контейнером стандартной библиотеки. Но что если написать много такого кода для распространённых случаев и поместить его в стандартную библиотеку, не заставляя программиста раз за разом изобретать велосипеды? Это подводит к идее алгоритмов стандартной библиотеки.

\subsubsection{Жизнь без явных циклов}

Алгоритмы позволяют ``в один вызов'' делать многие вещи, для которых в противном случае пришлось бы писать явные циклы. В разделе (\ref{vectorarrs}) рассматривался листинг невероятно полезной функции foo, которая выделяет вектор, инициализирует его и подсчитывает сумму его элементов. Подсчёт суммы элементов осуществлялся циклом. А как же иначе, спросите вы? Листинг ниже может показаться написанным очень непривычно:

\begin{lstlisting}
template <typename T>
T accum_op (T init, T elem)
{
  if (!check_legal(elem))
    throw std::runtime_error("Illegal element");
  return init + elem;
}

template <typename T>
T foo (int n)
{
  std::vector<T> t(n);
  init_t (&t[0], n);
  return std::accumulate (t.begin(), t.end(), 0, accum_op);
}
\end{lstlisting}

Собственно, если приглядеться к функции \lstinline!foo()!, можно заметить в ней старую добрую функцию \lstinline!init()!, которая, скорее всего, внутри себя использует некий старый добрый цикл. Пусть она в ваших руках. Тогда переписав её на генератор \lstinline!init_elem!, который делает то же что и \lstinline!init()!, но для каждого элемента наособицу, можно переписать функцию \lstinline!foo()!, сделав явной генерацию элементов вектора. Поскольку её смысл становится совершенно явным, можно даже прекратить называть её \lstinline!foo()!, приведя крутизну её имени в соответствие с крутизной содержания. Итак встречайте обобщённый алгоритм \lstinline!generate_and_accumulate!.

\begin{lstlisting}
template <typename T, typename Acc, typename Gen>
T generate_and_accumulate (int n, T init_val, Acc accum_op, Gen init_op)
{
  std::vector<T> t(n);
  std::generate (t.begin(), t.end(), init_op);
  return std::accumulate (t.begin(), t.end(), init_val, accum_op);
}
\end{lstlisting}

Вот теперь это выглядит действительно круто.

Очевидно, что старая \lstinline!foo()! лишь её малозначащий частный случай:

\begin{lstlisting}
template <typename T> T init_op (void) { /* ... */ };
template <typename T> T accum_op (T init, T elem) { /* ... */ };

template <typename T> 
T foo (int n)
{
  return generate_and_accumulate (n, 0, accum_op, init_op);
}
\end{lstlisting}

Никаких явных циклов, никаких проблем с выделением и освобождением памяти и безопасностью исключений. Всё скрыто за средствами стандартной библиотеки и вы можете почувствовать себя программистом на Java. До первого подводного камня, конечно. Но чувство все равно сладко и приятно.

\subsubsection{Пары итераторов для обозначения диапазона}

Обратите внимание что оба использованных выше алгоритма \lstinline!std::generate! и \lstinline!std::accumulate! для обозначения диапазона генерирования и аккумуляции, берут на вход пару итераторов. Это часто встречающаяся идиома и её истоки стоит рассмотреть подробней. Допустим, при написании класса \lstinline!vector!, появилась необходимость дать пользователю возможность сконструировать его из самых разных классов:

\begin{lstlisting}
template <class T>
class vector
{
  public:
    vector (const list<T> &); 
    vector (const set<T> &); 
    vector (const T * pod_array, int n); /* ! */
};
\end{lstlisting}

Следует обратить внимание, что в итоге получился разный интерфейс для конструирования из списка, который знает свою длину и из POD-массива, который свою длину не знает. Кроме того, конструкторов получилось слишком много. Пара итераторов здесь позволяет естественным образом обобщить идею ``диапазона'' в одном конструкторе:

\begin{lstlisting}
template <class T>
class vector
{
  public:
    /* Iterator-pair constructor */
    template <class InputIterator>
    vector (InputIterator begin, InputIterator end) 
};
\end{lstlisting}

Теперь любой список и множество могут сообщить вектору свои начало и конец, а POD-массив -- использовать для этого обычные указатели.

\subsubsection{Идиома erase-remove}

Удаление элементов из контейнера при работе с итераторами имеет свои контринтуитивные особенности. Формально для удаления служит алгоритм \lstinline!std::remove! и здесь может возникнуть искушение воспользоваться им что называется ``в лоб''.

\begin{lstlisting}
std::vector<int>& vec = myNumbers;
std::remove(vec.begin(), vec.end(), number_in);
\end{lstlisting}

Увы это не работает и не может работать. Ни у какого алгоритма не может быть достаточно информации чтобы по паре входных итераторов произвести честное удаление из обобщенного контейнера, потому что это потребовало бы от них по сути прямого управления памятью контейнера. Что происходит на самом деле проиллюстрировано ниже:

\begin{figure}[h!]
\centering
\includegraphics[width=0.9\textwidth]{illustrations/erase-remove-crop.pdf}
\caption{Идиома erase-remove}
\label{fig:erase_remove}
\end{figure}

Произошел сдвиг всех элементов, попадающих под условие удаления в хвост контейнера. Далее чтобы действительно очистить контейнер, нужно вызвать его метод \lstinline!erase! например так:

\begin{lstlisting}
std::vector<int>& vec = myNumbers;
vec.erase(std::remove(vec.begin(), vec.end(), number_in), vec.end());
\end{lstlisting}

Этот код записывается слитно очень часто, так что такие паттерны, как использование этой идиомы, опытный разработчик должен распознавать в коде ``на лету''.

\subsection{Память своими руками}

Интересной идеей в стандартной библиотеке C++ является идея аллокатора. Аллокатором называется класс, инкапсулирующий в себе стратегию выделения и освобождения памяти. Большинство стандартных контейнеров используют аллокаторы. Скажем полное определение уже знакомого нам класса \lstinline!vector! на самом деле выглядит вот так:

\begin{lstlisting}
template <class T, class Allocator = allocator<T> > class vector;
\end{lstlisting}

Поэтому каждый раз, когда создается вектор, у него на самом деле пропускается один параметр:

\begin{lstlisting}
std::vector <int> myvec; /* brief form */
std::vector <int, allocator<int> > myvec; /* full form */
\end{lstlisting}

В связи с этим полезно знать что такое аллокаторы и как они работают.

\subsubsection{Пользовательские аллокаторы}

Аллокатор это шаблон для того типа, для которого он аллоцирует:

\begin{lstlisting}
template<typename T>
class Allocator {
\end{lstlisting}

В открытой части аллокатор должен определять несколько стандартных имён, например так:

\begin{lstlisting}
    typedef T value_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;
\end{lstlisting}

Шаблонная вложенная структура \lstinline!rebind! обрабатывает случаи, когда на самом деле созданию подлежат иные типы, чем \lstinline!T!. Скажем \lstinline!list<int>! создаёт не целые числа, а узлы списка. Это внутреннее превращение и называется rebinding:

\begin{lstlisting}
    template<typename U>
    struct rebind {
        typedef Allocator<U> other;
    };
\end{lstlisting}

Стандартная функция \lstinline!address! должна возвращать \lstinline!pointer! или \lstinline!const_pointer!.

\begin{lstlisting}
    inline pointer address(reference r) { return &r; }
    inline const_pointer address(const_reference r) { return &r; }
\end{lstlisting}

Сердце аллокатора: функции выделения и освобождения памяти. Именно здесь можно развернуться с гениальными стратегиями.

\begin{lstlisting}
    inline pointer allocate(size_type cnt, 
       typename std::allocator<void>::const_pointer = 0) { 
      return reinterpret_cast<pointer>(::operator new(cnt * sizeof (T))); 
    }
    inline void deallocate(pointer p, size_type) { 
        ::operator delete(p); 
    }
\end{lstlisting}

Бывает полезно ограничить размер доступной памяти (если, например, речь о выделении из статического буфера).

\begin{lstlisting}
    inline size_type max_size() const { 
        return std::numeric_limits<size_type>::max() / sizeof(T);
    }
\end{lstlisting}

Считается, что пользовательские \lstinline!construct! и \lstinline!destroy! могут очень сильно отличаться от стандартного размещающего \lstinline!new!.

\begin{lstlisting}
    inline void construct(pointer p, const T& t) { new(p) T(t); }
    inline void destroy(pointer p) { p->~T(); }
\end{lstlisting}

Как ни странно, аллокаторы чтобы быть совместимыми требуют сравнения на рвенство и неравенство.

\begin{lstlisting}
    inline bool operator==(Allocator const&) { return true; }
    inline bool operator!=(Allocator const& a) { return !operator==(a); }
\end{lstlisting}

Кода вы разрабатываете свой аллокатор, вы должны быть уверены, что знаете что вы делаете и зачем вам это нужно. В библиотеке Intel Threading Building Blocks например реализовал собственный аллокатор и утверждается, что производительность вектора в многопоточном приложении можно существенно улучшить, объявив его как:

\begin{lstlisting}
std::vector<T,tbb::scalable_allocator<T> >
\end{lstlisting}

Ещё примеры -- аллокаторы рассчитанные на ограниченное количество памяти в EASTL, собственные аллокаторы из файла. Скорее всего вам никогда не придется все это писать.

\subsection{Умные и слишком умные указатели}

Идиома RAII уже рассматривалась в (\ref{RAII}), и там же была сделана наивная попытка завернуть в класс для управления ресурсами такой классический разделяемый ресурс как дисковый файл. Конечно, идея обобщить RAII для любого \lstinline!T!, используя шаблоны -- приходит на ум почти сразу после знакомства с шаблонами. Паттерн обертки, осуществляющей управление временем жизни объекта умнее, чем это делается через обычный указатель, называется ``smart pointer'' или умный указатель. Таким образом это не какой-то класс, это общая концепция для целого семейства от крайне простых до крайне сложных и интересных классов.

\subsubsection{Первая попытка -- не слишком умный указатель}

Первая попытка написать не слишком сложную обертку для управления ресурсами, может выглядеть как-то так:

\begin{lstlisting}
template <typename T> 
class NotSoSmartP
{
private:
  T* pData; /* Generic pointer to be stored */
public:
  SP(T* pValue) : pData(pValue) {}
  ~SP() { delete pData; }
  T& operator* () { return *pData; }
  T* operator-> () { return pData; }
};
\end{lstlisting}

Самое главное здесь это перегрузка двух интересных операторов -- \lstinline!operator*! который называется \textbf{dereferencing} т.е. разыменование и \lstinline!operator->! который называется \textbf{indirection} т.е. косвенный доступ. Но далее они часто будут называться просто ``звёздочка'' и ``стрелочка''.

Пусть есть класс \lstinline!Polynom! определенный как-то так:

\begin{lstlisting}
class Polynom
{
public:
  Polynom (int size, ...);
  Polynom (const Polynom & rhs);
  ~Polynom ();
  void display ();
  /* ... */
}
\end{lstlisting}

Его можно использовать вместе с умным указателем как-то так:

\begin{lstlisting}
  NotSoSmartP<Polynom> p(new Polynom(5, 1, 2, 3, 4, 5));
  p->display();
  /* no need to delete */
\end{lstlisting}

Особое внимание следует обратить, что метод умного указателя вызывается так, как если бы действительно вызывался метод класса \lstinline!Polynom! по указателю на него.

Но первая проблема обнаруживается сразу же:

\begin{lstlisting}
  NotSoSmartP<Polynom> p(new Polynom(5, 1, 2, 3, 4, 5));
  NotSoSmartP<Polynom> q = p;
  p->display();
  /* boom! */
\end{lstlisting}

И действительно -- обычное копирование или создание по образцу такого указателя приведет к ошибке двойного удаления. Что тут можно сделать? Самый простой способ -- запретить копирование и присваивание. Эта стратегия называется ``scoped pointer'' и именно так устроен и работает класс \lstinline!boost::scoped_ptr!. Но это все ещё не самая умная стратегия. Очевидно есть две более разумные вещи -- обеспечить уникальность владения объектом и передачу владения при некоторых обстоятельствах или обеспечить безопасное совместное владение объектом и -- в той или иной форме -- подсчет ссылок.

\subsubsection{Стандартные умные указатели}

Исторически первым 

\subsubsection{Проблема COAP и небольшая экскурсия в новый стандарт}

\subsubsection{Ещё более умные указатели}

\subsection{Потоки ввода/вывода}

Потоки ввода-вывода -- довольно спорная тема и именно поэтому они оставлены ``напоследок'' среди всех тем стандартной библиотеки. Их обзорное знание -- хороший тон, но стоит ли реально ими пользоваться -- большой вопрос (особенно учитывая, что стандарт C++11 предоставляет возможность соорудить безопасный относительно типов printf на variadic templates). В большинстве языков, спроектированных \textbf{позже} C++, ввод и вывод больше похожи на printf и scanf, чем на cin и cout. Например в предельно объектно ориентированном C\# это выглядит так

TODO: пример

Это произошло от того, что в целом коммьюнити разочаровалось в потоках ввода-вывода и поэтому эти лекции не разделяют общего апологетического тона книг по C++ на эту тему. Но сначала -- общий обзор.

\subsubsection{Виды и иерархия потоков}

В программах на C привычными потоками (имеющими тип FILE*)

\subsubsection{Итераторы потоков ввода-вывода}

\begin{lstlisting}
const int N = 10;

/* function generator: */
int RandomNumber (void) { return (std::rand() % 20); }

/* less than class */
template <typename T>
class less_than_X
{
public:
  less_than_X(T x): m_x(x) {}

  bool operator() (const T &x) const
    {
      return (x < m_x);
    }
private:
  T m_x;
};

int main() 
{
  vector<int> v1(N), v2;
  less_than_X<int> pred(10); /* less than 10 instance */

  /* prefer generators to immediate fill */
  generate (v1.begin(), v1.end(), RandomNumber);

  /* some output to look at v1 */
  copy(v1.begin(), v1.end(), std::ostream_iterator<int>(cout, " "));
  cout << std::endl;

  remove_copy_if(v1.begin(), v1.end(), inserter(v2,v2.end()), pred);

  /* some output to be sure v2 contain more than 10 */
  copy(v2.begin(), v2.end(), std::ostream_iterator<int>(cout, " "));
  cout << std::endl;

  return 0;
}
\end{lstlisting}

\subsubsection{Форматированный ввод и вывод}

Для обеспечения форматированного ввода и вывода у потоков в стандартной библиотеке есть форматные модификаторы

\pagebreak
\subsection{Домашняя наработка по стандартной библиотеке}

\pagebreak
\section{Новые горизонты}

Новый стандарт C++ предлагает много нововведений. Часть из них относится к тому, чего все давно ждали и успели освоить, что перекочевало из библиотеки boost или из technical reports к C++98. Но есть и такие, при работе с которыми требуется оперировать совершенно новыми понятиями и заставлять себя мыслить иначе, мыслить в духе действительно новых возможностей.

\subsection{Type inference}

Вывод типов это базовое и очень впечатляющее усовершенствование, которое легко понять и легко использовать. Кроме того, некоторый навык работы с системой типов, в особенности с новыми type traits несомненно нужен для понимания нового стандарта. Поэтому с него имеет смысл начать.

\subsubsection{Auto и Decltype}

При работе со стандартной библиотекой C++, каждому программисту знакомы невероятные обозначения типов, как в левой части следующего выражения:

\begin{lstlisting}
map<int,list<string>>::iterator i = m.begin(); 
map<int,list<string>>::iterator j = i++; 
\end{lstlisting}

Самое обидное, что компилятор и так знает всё о статическом типе правой части (по крайней мере, грубая ошибка в левой части вызовет ошибку компиляции), так что необходимость писать столько букв выглядит напрасной. Новый стандарт позволяет мягко хлопнуть компилятор по плечу и сказать ему, чтобы он попробовал догадаться о типе сам:

\begin{lstlisting}
auto i = m.begin(); 
auto j = i++;
\end{lstlisting}

Если компилятор может взять тип выражения, логично, что это должен уметь и пользователь. Предыдущий кусок кода может быть переписан так:

\begin{lstlisting}
auto i = m.begin(); 
decltype(i) j = i++;
\end{lstlisting}

Здесь на второй строчке объявлено ``сделать j такого же типа, как i''. Иногда \lstinline!decltype! может быть сопряжен с некоторыми концептуальными проблемами:

\begin{lstlisting}
struct Point { int x, y; }
/* ... */
const Point &p;
decltype(p.x) x; /* int or const int? */
\end{lstlisting}

Для их разрешения, стандарт вводит (5.1.2.18) форму \lstinline!decltype! с двумя круглыми скобками:

\begin{lstlisting}
decltype(p.x) x; /* const int */
decltype((p.x)) x; /* int */
\end{lstlisting}

Это кажется некоторым переусложнением, но это на самом деле единственный разумный выход из ситуации.

Вывод типов в C++ работает гораздо более приблизительно, чем их прямая аннотация, поэтому \lstinline!auto! часто выводит первый попавшийся (на самом деле -- наименее общий о чем см. далее) тип, а вот \lstinline!decltype! всегда старается сохранить даже cv-квалификацию

\begin{lstlisting}
const int i;
auto j = i; /* typeof(j) == int */
decltype (i) k = i; /* typeof (k) == const int */
\end{lstlisting}

Разумное применение этих средств позволяет существенно улучшить читаемость вашего кода и сделать гораздо меньше тонких ошибок и опечаток в сложных именах типов.

Разные правила для \lstinline!decltype! и \lstinline!auto! привели в стандарте C++14 к введению идиомы \lstinline!decltype(auto)! которая позволяет вывести

\begin{lstlisting}
const int i;
auto j = i; /* typeof(j) == int */
decltype (auto) k = i; /* typeof (k) == const int */
\end{lstlisting}

Очень интересный случай это выражение справа от \lstinline!decltype!, заключенное в круглые скобки.

\begin{lstlisting}
int i;
auto x4a = (i); /* decltype(x4a) is int */
decltype(auto) x4d = (i); /* decltype(x4d) is int& */
\end{lstlisting}

Таким образом моделируется поведение двух круглых скобок у \lstinline!decltype((t))! с конкретным \lstinline!t!.

\subsubsection{Расширенный синтаксис функций}

Возможности автоматического вывода типов подразумевают построение абстракций с зависимыми типами. Пусть необходим статический шаблонный контракт на любой тип \lstinline!T!, поддерживающий функцию \lstinline!T::makeobject!, возвращающую некий свой тип. Нельзя просто взять и написать:

\begin{lstlisting}
template <typename T> auto /* Error! */
makeAndProcessObject (const T& builder)
{
    auto val = builder.makeObject();
    /* do stuff with val */
    return val;
}
\end{lstlisting}

Потому что компилятор в точке объявления функции не обладает информацией о типе, который вернет \lstinline!T::makeobject!. Точно так же не сработает вот такой выход:

\begin{lstlisting}
template <typename T> 
decltype(builder.makeObject()) /* Error again! */
makeAndProcessObject (const T& builder)
{
    auto val = builder.makeObject();
    /* do stuff with val */
    return val;
}
\end{lstlisting}

Потому что \lstinline!builder! не может быть использован до точки своего объявления (которой является список аргументов функции). Комитет по стандартизации решил эту проблему изящно, предложив расширенный синтаксис для обобщённых функций, возвращающих зависимые типы:

\begin{lstlisting}
template <typename T> auto
makeAndProcessObject (const T& builder) -> decltype (builder.makeObject())
{
    auto val = builder.makeObject();
    /* do stuff with val */
    return val;
}
\end{lstlisting}

Внутри скобок \lstinline!decltype! в данном случае вычисление выражения (в том числе вызов функции) не происходит -- происходит только вывод типа.

\subsubsection{Коррективы в вывод типов для C++14}

В некоторых простых случаях компилятору действительно не составляет проблем вывести тип функции: 

\begin{lstlisting}
auto isquare (int x) -> decltype (x) { return x*x; }
\end{lstlisting}

Здесь указание \lstinline!decltype! выглядит просто излишним и C++14 разрешает его убрать:

\begin{lstlisting}
auto isquare (int x) { return x*x; }
\end{lstlisting}

Для таких простых вариантов все хорошо, но как быть с рекурсией? Здесь возникает проблема: тип должен быть выведен до того, как рекурсивный вызов произошел:

\begin{lstlisting}
auto Correct(int i) {
  if (i == 1)
    return i; // return type deduced as int
  else
    return Correct(i-1)+i;  // ok to call it now
}
\end{lstlisting}

\subsubsection{Decaying и минимальные общие типы}

Decaying уже был рассмотрен, при рассмотрении деградации массивов в указатели (\ref{ArrDecaying}), но если в старом стандарте это была built-in особенность для одной конкретной пары типов, то новый стандарт предлагает интересные варианты обобщения этого понятия на любые типы. Простой случай:

\begin{lstlisting}
int foo (const int &s) 
{ 
  return s + 2; 
}
\end{lstlisting}

Здесь в выражении \lstinline!s + 2!, \lstinline!s! ведёт себя так, как будто его тип \lstinline!int!. Тогда можно сказать, что \lstinline!const int &! деградирует к \lstinline!int! в том же смысле, в каком массив деградирует к указателю, etc. Новый стандарт позволяет вручную ``деградировать'' тип:

\begin{lstlisting}
const int &i;
std::decay<decltype(i)>::type j; /* int j */
/* and btw */
auto k = i; /* int k = i; */
\end{lstlisting}

Поскольку \lstinline!auto! также осуществляет деградацию, можно считать \lstinline!decay! + \lstinline!decltype! способом вывести тот тип, который вывело бы \lstinline!auto!.

На механизме \lstinline!decay! неявно построен механизм \lstinline!common_type!, позволяющий вывести минимальный общий тип:

\begin{lstlisting}
int foo (int &i)
{
  const long j;
  /* long k */
  std::common_type<decltype(i), decltype(j)>::type k;
}
\end{lstlisting}

В качестве полезного примера, можно привести смешанную арифметику для числового класса:

\begin{lstlisting}
template <class T>
struct Number { T n; };
 
template <class T, class U>
Number<typename std::common_type<T, U>::type> 
operator+(const Number<T>& lhs,
          const Number<U>& rhs) 
{
    return {lhs.n + rhs.n};
}
 
int main()
{
    Number<int> i1 = {1}, i2 = {2};
    Number<double> d1 = {2.3}, d2 = {3.5};
    std::cout << "i1i2: " << (i1 + i2).n 
              << "\ni1d2: " << (i1 + d2).n 
              << "\nd1i2: " << (d1 + i2).n 
              << "\nd1d2: " << (d1 + d2).n 
              << '\n';
}
\end{lstlisting}

\textbf{Домашняя наработка:} проанализировать вывод этой программы и то, почему он ведет себя именно так.

\subsubsection{Стой, кто идёт?\index{Type traits}}\label{TypeTraits}

Новый стандарт предлагает большое количество удобных стандартных шаблонов для получения более детальной информации о типах на этапе выполнения. 

Большинство из них должны как-то сообщать ответы ``да'' и ``нет'' на вопросы ``является ли это тем-то и тем-то?'', скажем: ``является ли тип аргумента указателем на функцию-член класс?''. Чтобы закодировать ответы, используется обертка над интегральными константами времени компиляции:

\begin{lstlisting}
template< class T, T v >
struct integral_constant;
\end{lstlisting}

Теперь можно определить \lstinline!true_type! как \lstinline!integral_constant<bool, true>! и \lstinline!false_type! как \lstinline!std::integral_constant<bool, false>!.

Можно продемонстрировать создание пользовательских констант:

\begin{lstlisting}
typedef std::integral_constant<int, 2> two_t;
typedef std::integral_constant<int, 4> four_t;
static_assert(two_t::value*2 == four_t::value, "2*2 != 4");
\end{lstlisting}

Используя закодированные таким образом истину и ложь, простейший из определителей типов: является ли анализируемый тип интегральным (это такие типы как \lstinline!bool!, \lstinline!char!, \lstinline!short!, \lstinline!int!, \lstinline!long!, \lstinline!long long! и все их cv-квалификации).

\begin{lstlisting}
template <class T>
T f(T i)
{
    static_assert(std::is_integral<T>::value, 
                  "Integer required");
    return i;
}
\end{lstlisting}

\textbf{Домашняя наработка:} как могла бы выглядеть реализация \lstinline!is_integral! и \lstinline!is_floating_point!?

Имея два определителя, можно скомбинировать из них производные, скажем:

\begin{lstlisting}
template< class T >
struct is_arithmetic : std::integral_constant<bool,
  std::is_integral<T>::value ||
  std::is_floating_point<T>::value> {};
\end{lstlisting}

Можно потренироваться и определить является ли нечто указателем:

\begin{lstlisting}
template< class T > struct is_pointer_helper     : std::false_type {};
template< class T > struct is_pointer_helper<T*> : std::true_type {};
template< class T > struct is_pointer : is_pointer_helper<typename std::remove_cv<T>::type> {};
\end{lstlisting}

Обратите внимание на использование \lstinline!remove_cv!, который сам является композитным хелпером из \lstinline!remove_const! и \lstinline!remove_volatile! которые по отдельности тоже не составляют проблем.

Вопрос к студентам: как бы вы реализовали \lstinline!remove_const!? 

Правильный ответ:

\begin{lstlisting}
template< class T > struct remove_const          { typedef T type; };
template< class T > struct remove_const<const T> { typedef T type; };
\end{lstlisting}

Полное рассмотрение всех возможных traits не нужно -- они перечислены в стандарте и их несложно конструировать по мере необходимости. Можно запомнить (это примерно столь же полезная для запоминания информация как первый 21 знак числа пи), что все что угодно, что встречается в корректной программе на C++14 может быть отнесено к одному из 14 базовых классов traits и только к нему одному. И кстати 14 это первые две цифры номера стандарта. Совпадение? Не думаю.

\subsubsection{Ваш третий лучший друг}\label{FriendUsing}

До сих пор двумя лучшими (воображаемыми) друзьями программиста были \lstinline!typedef! (\ref{FriendTypedef}) и \lstinline!typename! (\ref{FriendTypename}). Но теперь оказывается, что в новом стандарте у \lstinline!typename! есть младший братик \lstinline!using!

\begin{lstlisting}
typedef int MyInt;
using MyInt = int;
\end{lstlisting}

Эти две строчки совершенно эквивалентны. Зачем же нужно было вводить новое ключевое слово? Потому что \lstinline!using! умеет больше:

\begin{lstlisting}
template< class T > using MyType = AnotherType< T, MyAllocatorType >; 
template<class T> using ptr = T*;
...
MyType<int> a;
ptr<int> x;
\end{lstlisting}

Таким образом, использовать с новым стандартом \lstinline!using! это правильно.

\subsection{Rvalue references}

Ссылки (references) это то, что наиболее сложно воспринимается при переходе с C на C++. Человеку с опытом программирования на C, может быть непонятно, зачем они нужны, когда уже есть такие удобные и привычные указатели, которые позволяют делать всё то же самое только лучше... Подлинное осознание того, каким именно инструментом являются ссылки и как ими оперируют, приходит с опытом C++. При переходе на новый стандарт C++11, идея о том, что теперь есть ещё один вид ссылок -- ссылки на rvalue (rvalue references) кажется новаторской и неочевидной (особенно неочевидна её полезность). Скорее всего, многим придётся преодолеть внутреннее сопротивление, прежде чем rvalue references станут удобным и привычным инструментом. Но прежде, чем переходить к их описанию, есть смысл немного вспомнить о том, что такое rvalue и lvalue.

\subsubsection{Ещё раз rvalue и lvalue}

Термин lvalue был, прежде чем перейти в C++, документально зафиксирован в стандарте языка C, поэтому логично начать изложение с него. Для языка C, lvalue (от left hand side value) -- то, что может появиться слева в выражении присваивания. Формально (6.3.2.1 стандарта C99), ``An lvalue is an expression with an object type or an incomplete type other than void'' (под object type в стандарте понимаются все типы, не являющиеся function type или incomplete type).

\begin{lstlisting}
int c = a * b;
a * b = 42;
foo() = 42;
\end{lstlisting}

Собственно, в стандарте языка C90 и последовавшем за ним C99 нет термина rvalue. В C99 есть оговорка ``What is sometimes called ``rvalue'' is in this International Standard described as the ``value of an expression'''', позволяющая предположить, что к этому времени этот термин существовал и использовался, но фиксировать его строго в случае языка C было не нужно.

Всё изменилось с приходом языка C++, который принёс с собой references. Выражение из прошлого примера:

\begin{lstlisting}
foo() = 42;
\end{lstlisting}

может быть ошибкой если foo возвращает значение, но совершенно корректно, если foo возвращает ссылку. Чтобы разрешить эту неоднозначность, стандарт C++ 98 объявляет (3.10.1) два термина -- lvalue и rvalue, причём каждое выражение языка C++98 является либо тем, либо другим. При этом определение в (3.10.2) гласило ``An lvalue refers to an object or function''.

То есть lvalue это не первоклассный объект как в C, а просто некое выражение ссылающееся на область памяти. Таким образом в качестве главного различия выступает возможность взять адрес, а не отношение к операции равенства.

\begin{lstlisting}
int& foo();
foo() = 42;
int* p1 = &foo();
int foobar();
int* p2 = &foobar();
\end{lstlisting}

В некотором смысле, lvalue в C++98 содержательно становится locator value (а не left hand side value). Так, например если есть указатель \lstinline!int *val!, то выражение \lstinline!val+1! можно разыменовать, но нельзя взять его адрес.

\begin{lstlisting}
int *val;
int correct = *(val + 1);
int **wrong = &(val + 1);
\end{lstlisting}

Cтандарт С++11 объявляет (3.10) пять терминов: lvalue, rvalue, xvalue, а также glvalue (обобщение lvalue и xvalue) и prvalue (более узкая специализация rvalue). Базовыми терминами являются знакомые нам lvalue, rvalue и новый xvalue (от expiring value). Забегая вперёд -- например xvalue является результат функции возвращающей rvalue ссылку. То, что понималось под rvalue в C++98, в C++11 стало prvalue (в то время как rvalue обобщает xvalue и prvalue), а новый термин glvalue обобщает lvalue и xvalue. 

\begin{figure}[h!]
\centering
\includegraphics[width=1.0\textwidth]{illustrations/value-cat-crop.pdf}
\caption{Виды значений в C++11}
\label{fig:val_category}
\end{figure}

Более точно в новом стандарте регламентировано, что:

\begin{itemize}
\item \textbf{lvalue} -- выражение, идентифицирующее постоянный объект или свободную функцию. Должны быть доступны: взятие адреса, использование в левой части выражения (при неконстантности) и инициализация таким выражением левой ссылки:
\begin{lstlisting}
int lval;
int *t = &++lval;
lval = 2;
int &lref = lval;
\end{lstlisting}
Ещё говорят, что у lvalues есть identity (прописка) -- то есть каждый такой объект можно как-то отличить от любого другого (взять адрес, etc)
\item \textbf{xvalue} -- выражение, идентифицирующее объект с истекающим временем жизни. Это очень странные объекты, которые были введены именно для поддержки rvalue ссылок. Большая часть исследуемых в этом разделе объектов будет xvalue.
\item \textbf{prvalue} -- выражение, идентифицирующее временный объект или значение не ассоциированное ни с каким объектом. В частности это литералы, вызовы функций которые возвращают не ссылку, и все остальное, что раньше называлось rvalue
\item \textbf{glvalue} -- то, что раньше называлось lvalue -- обобщение lvalue и xvalue. При этом glvalue может быть полиморфным объектом, его динамический тип не обязан совпадать со статическим.
\item \textbf{rvalue} -- отрицание lvalue. Это не адресуемый, не используемый в левой части объект. Им можно инициализировать константные левые ссылки
\end{itemize}

Первые три категории являются базовыми. Чуть ниже будет предъявлен способ различить к какой категории относится объект на этапе выполнения, но чтобы это сделать, сначала необходимо поговорить о том, чем же все таки являются правые ссылки.

\subsubsection{Отличаем rvalue refernces от lvalue references}

В C++11, если X это тип, то \lstinline!X&! это lvalue reference, а \lstinline!X&&! это rvalue reference для этого типа (8.3.2.2). При этом важно понимать -- \lstinline!X&, X&&! -- это разные типы, но семантически они эквивалентны и о них можно вместе говорить как о ``ссылках вообще''. Тем не менее, поскольку это разные типы, для них работает перегрузка:

\begin{lstlisting}
int a, b;
foo(int &x);
foo(int &&x);
foo(a * b); /* calls foo (int &&x) */
foo(a);     /* calls foo (int &x) */
\end{lstlisting}

При этом сама по себе rvalue reference может быть lvalue (и является им, если она именована).

\begin{lstlisting}
int &&x = a * b;
foo(x); /* calls foo (int &x) !!! */
\end{lstlisting}

Это очень важное правило, потому что представьте ситуацию, в которой объявлен класс Base и в нём есть необходимость определить конструкторы:

\begin{lstlisting}
Base(Base const & rhs);
Base(Base&& rhs);
\end{lstlisting}

Теперь в наследуемом от него классе Derived, есть необходимость эти конструкторы переопределить:

\begin{lstlisting}
Derived(Derived const & rhs) : Base(rhs) {};
Derived(Derived&& rhs) : Base(rhs) {};
\end{lstlisting}

Перемещающий конструктор переопределён неверно -- поскольку rhs имеет имя, оно есть lvalue, а значит \lstinline!Base(rhs)! в данном случае вызовет снова \lstinline!Base(Base const & rhs)!, что, вероятно, не желательно. Вместо этого следует писать

\begin{lstlisting}
Derived(Derived&& rhs) : Base(std::move(rhs)) {};
\end{lstlisting}

Сюрпризы подобные этому ожидают, казалось бы, в очевидных вещах. Ccылка на ссылку -- невозможна. Это все знают и тысячу раз отвечали на собеседованиях. Что же, этот ответ всё ещё верен и стандарт C++11 (8.3.2.5) запрещает ссылки на ссылки, указатели на ссылки и массивы ссылок. Но как быть, когда в шаблоне или при \lstinline!typedef! получается смесь правых и левых ссылочных типов? Это способно поставить в тупик.

\subsubsection{Свёртка ссылочных типов}\label{ReferenceConvolution}

Стандарт (8.3.2.6) определяет следующие правила свёртки ссылок, применимые для определений typedef и decltype, а также параметров шаблонов:

\lstinline!A& &! становится \lstinline!A&!
\lstinline!A& &&! становится \lstinline!A&!
\lstinline!A&& &! становится \lstinline!A&!
\lstinline!A&& &&! становится \lstinline!A&&!

Пусть определён шаблон

\begin{lstlisting}
template<typename T>
void foo(T&& t);
\end{lstlisting}

Пусть теперь \lstinline!foo! вызвана с аргументом \lstinline!x! типа \lstinline!X!, причём \lstinline!x! является \lstinline!lvalue!. Тогда \lstinline!T! разрешается в \lstinline!X&!, а реальным типом аргумента t будет \lstinline!X& &&!, то есть (см. выше правила свёртки) \lstinline!X&!. Если же \lstinline!x! является \lstinline!rvalue!, то \lstinline!T! разрешается в \lstinline!X! и реальным типом аргумента \lstinline!t! будет \lstinline!X&&!.

Стандарт также определяет функтор \lstinline!remove_reference! (20.9.7.2), который позволяет получить не-ссылочный тип из ссылочного. Он работает похоже на \lstinline!static_cast! и прочие привычные вещи. Аналогично (но наоборот) работает пара \lstinline!add_lvalue_reference!/\lstinline!add_rvalue_reference!.

\begin{lstlisting}
int *p = (std::remove_reference<int&>::type *)0;
\end{lstlisting}

(Я надеюсь, никто никогда не напишет такую строчку в реальном коде).

Пара функторов \lstinline!is_lvalue_reference! и \lstinline!is_rvalue_reference! позволяют определять на этапе исполнения к какой базовой категории относится конкретный тип \lstinline!T! (для этого надо применить к нему \lstinline!std::remove_reference! и проверить получившийся тип): lvalue если сработало условие \lstinline!is_lvalue_reference!, xvalue если сработало условие \lstinline!is_rvalue_reference!, или prvalue, если не сработало ни одно из них.

Вопрос к студентам: как определить glvalue и prvalue?

Теперь настала пора посмотреть зачем же комитетом по стандартизации были введены все эти сложности.

\subsubsection{Обмен выражениями и перемещение}

В условной реализации С++11, удовлетворяющая стандарту реализация библиотечной функции std::swap (20.2.2) может выглядеть, например, так:

\begin{lstlisting}
template<class T> 
void swap(T& a, T& b) 
{ 
  T tmp(std::move(a));
  a = std::move(b); 
  b = std::move(tmp);
} 
\end{lstlisting}

В этой реализации нет операций копирования (без которых не обойтись в C++98). Функция std::move позволяет здесь реализовать семантику перемещения, поскольку она работает так: из любого аргумента, \lstinline!std::move! делает rvalue reference. Эта функция в свою очередь, в удовлетворящем стандарту (20.2.3) виде может быть определена так:

\begin{lstlisting}
template<class T> 
typename remove_reference<T>::type&&
std::move(T&& a) noexcept
{
  typedef typename remove_reference<T>::type&& RvalRef;
  return static_cast<RvalRef>(a);
} 
\end{lstlisting}

Методологически полезно проследить, что будет если вызвать std::move с аргументом, имеющим тип X и являющимся lvalue.

1) T будет разрешено в \lstinline!X&!
2) тип аргумента \lstinline!X& &&! a будет свёрнут в \lstinline!X&! a
3) \lstinline!remove_reference<X&>::type&&! будет означать \lstinline!X&&!, который и будет значением RvalRef

Итак, получим эквивалент:

\begin{lstlisting}
X&& std::move(X& a) noexcept
{  
  return static_cast<X&&>(a);
}
\end{lstlisting}

Что и требовалось.

Сама идея, что теперь обмен значениями может быть семантически выражен как обмен значениями, а не копирование (а значит и соптимизирован соответствующим образом) после её осознания, приводит людей в лёгкую эйфорию. В конце концов стремление к максимальной эффективности -- нормальное стремление. Тем не менее, с функцией \lstinline!std::move! следует быть осторожным. Часто идея вернуть \lstinline!std::move(x)! вместо \lstinline!x!, когда реально нужно rvalue и хочется избежать лишних копирований, приводит к отключению оптимизаций возвращаемого значения (\ref{RVO}) в компиляторе и результат ухудшается. Большинство таких трансформаций на современных компиляторах требует замеров и не должны выполняться preliminary:

\begin{lstlisting}
X foo()
{
  X x;
  return std::move(x);
}
\end{lstlisting}

Итак, rvalue references позволяют (совместно с \lstinline!std::move!) по новому взглянуть на ссылки и открывают простор к более тонкому различию таких терминов естественного языка как ``копирование'', ``присваивание значения'', ``присваивание результата'' на языке C++, что открывает как простор к оптимизациям, так и возможности более аккуратного выражения старых идиом (хороший пример блестящего использования правых ссылок это \lstinline!std::unique_ptr! который в новом стандарте пришёл на смену печально известному \lstinline!auto_ptr!). Их освоение -- важная черта отличающая программиста на C++11.

\subsubsection{Universal references}\index{Universal references}\label{UniversalReferences}

Благодаря свертке ссылочных типов (\ref{ReferenceConvolution}) двойные амперсанды в объявлении типов и аргументах шаблонов имеют два разных значения:

\begin{lstlisting}
  /* rvalue references */
  Widget&& var1 = someWidget; 
  template<typename T> void f(std::vector<T>&& param);
     
  /* NOT rvalue references */
  auto&& var2 = var1; 
  template<typename T> void g(T&& param);
\end{lstlisting}

В первых двух случаях \lstinline!var1! и параметр функции \lstinline!f! это честные rvalue references. Во вторых двух случаях они зависят от вывода (в том числе -- свертки) типов.

\begin{lstlisting}
  int t;
  auto&& var2 = t; /* typeof (var2) == int&
\end{lstlisting}

В этом контексте \lstinline!var2! это левая а не правая ссылка по правилам свертки типов. Поскольку \lstinline!var2! может разрешиться в любую ссылку -- как в левую, так и в правую, она называется \textbf{универсальной} ссылкой.

Но важно понимать, что свертка типов происходит только в контекстах чистого автоматического вывода. Даже следующий простой пример:

\begin{lstlisting}
template<typename T> void f(const T&& param);
\end{lstlisting}

Означает обязательно правую, ни в коем случае не универсальную ссылку. Хуже того, универсальной ссылка не может быть, если тип полностью разрешен и вывод типа не включается:

\begin{lstlisting}
template <class T, class Allocator = allocator<T>>
class vector 
{
  public:
  /* rvalue reference! */  
  void push_back(T&& x);
};
\end{lstlisting}

Здесь также видна существенная разница между \lstinline!auto! и \lstinline!decltype!, поскольку механизм \lstinline!decltype! зависит только от вывода типа внутри выражения:

\begin{lstlisting}
Widget w1, w2;
auto&& v1 = w1; /* Ok, v1 is Widget& */
decltype(w1)&& v2 = w2; /* Error! */
decltype(w1)&& v2 = std::move(w2); /* Ok, v2 is Widget&& */
\end{lstlisting}

Таким образом, универсальные ссылки в контексте \lstinline!decltype! невозможны.

Вопрос к студентам:

\begin{lstlisting}
template <typename T> void f(T &a);  /* (1) */
template <typename T> void f(T &&a); /* (2) */

int a;
f(a); /* ? */
f(1); /* ? */
\end{lstlisting}

Знание об универсальных ссылках теперь должно подсказать правильный ответ: оба раза будет вызвана вторая функция.

\subsubsection{Perfect forwarding}\label{PerfectForw}

Важной проблемой относительно правых ссылок является проброс правой ссылки (с присущей ей move-семантикой) через цепочку функций. Наивная попытка такого проброса может выглядеть как-то так:

\begin{lstlisting}
void g(int &&t); /* 1 */
void g(int &t);  /* 2 */

void h(int &&t) { g(t); } /* always 2 */

h(1);
\end{lstlisting}

Увы, это не работает. Даже менее наивная попытка с использованием универсальных ссылок (\ref{UniversalReferences}) проваливается:

\begin{lstlisting}
template <typename T>
void h2(T &&t) { g(t); } /* always 2 */
\end{lstlisting}

Конечно можно выйти из положения с явным \lstinline!std::move! следующим образом:

\begin{lstlisting}
template <typename T>
void h3(T &&t) { g(std::move(t)); } /* always 1 */
\end{lstlisting}

Но увы, это решение шатает в другую крайность -- теперь даже вызовы с lvalue будут идти по rvalue маршруту. Решение проблемы является использование \lstinline!std::forward<T>!

\begin{lstlisting}
template <typename T>
void h4(T &&t) { g(std::forward<T>(t)); }
\end{lstlisting}

Теперь наконец-то можно различить что и по какой ветке было вызвано

\begin{lstlisting}
int x = 0;
h4(1); /* calls 1 */
h4(x); /* calls 2 */
\end{lstlisting}

Название это техники perfect forwarding способно сбивать с толку. Он не столь уж и perfect в том смысле, что, например, не способен решить проблему перегрузки универсальной ссылки.

\textbf{Домашняя наработка:} как все-таки решить проблему перегрузки универсальной ссылки из раздела (\ref{UniversalReferences})?

\subsection{Lambda expressions}

Ещё одной непросто воспринимаемой для программиста с опытом С++ концепцией являются lambda expressions. С одной стороны понять их кажется чуть проще, в конце концов все когда-нибудь писали функторы. С другой стороны, настоящее осознание мощи и гибкости этого инструмента также приходит только с опытом. 

Следующий код с первого взгляда немного шокирует:

\begin{lstlisting}
int main()
{
  auto func = [] () -> int { std::cout << "Hello world"; return 0; };
  return func(); 
}
\end{lstlisting}

Здесь, согласно стандарту (5.1.2): 
\lstinline![]! -- capture specificator, определяет lambda-выражение, внутри этих скобок также можно задать захватываемый контекст.
\lstinline!()! -- argument list, здесь можно задать список параметров
\lstinline!-> int! -- означает что возвращаемое значение имеет тип int.
Внутри \lstinline!{}! -- тело lambda-выражения.

Отдельно следует остановиться на спецификаторе auto (7.1.6.4). Его употребление вместо типа переменной означает, что тип переменной должен быть выведен из инициализирующего её выражения (есть также специальное назначение \lstinline!auto!, когда он употребляется как тип функции, который должен быть в этом случае выведен из выражения, стоящего под \lstinline!return!).

\begin{lstlisting}
auto x = new auto('a');
\end{lstlisting}

Каким будет выведен тип func, пока не так существенно. Рассмотренный пример использования lambda-выражения, может быть переписан несколько проще.

\begin{lstlisting}
int main()
{
  auto func = [] { std::cout << "Hello world"; return 0; };
  return func(); 
}
\end{lstlisting}

По стандарту, если список аргументов не указан, то он пуст (5.1.2.4) и возвращаемый тип выражения выводится из \lstinline!return! в его теле, если он указан и единственный (там же).

Лямбда-выражения в их простейшем виде хороши для объявления на месте несложных функторов. Стандарт (5.1.2.1) приводит простой пример:

\begin{lstlisting}
void abssort(float *x, unsigned N)
{
  std::sort(x, 
            x + N,
            [] (float a, float b) { return std::abs(a) < std::abs(b); });
}
\end{lstlisting}

Тем не менее, в лямбда-выражениях есть и более интересные детали для рассмотрения, одна из которых -- возможность захвата контекста.

\subsubsection{Захват контекста}

Список для захвата контекста пишется в квадратных скобках. Правила формирования списка для захвата контекста регулируются стандартом (5.1.2.8). Существует два специальных символа -- \lstinline!=! и \lstinline!&!. Переменные захватываемые по значению, входят в список без модификаторов, захватываемые по lvalue reference -- с модификатором \lstinline!&!

\begin{lstlisting}
[foo, &bar]
\end{lstlisting}

Употребление \lstinline!&! означает, что ``может быть захвачена по ссылке любая переменная из контекста'', тогда захватываемая переменная не должна предваряться \lstinline!&! и всё равно будет захвачена по ссылке (по ссылке значит по lvalue ссылке, говоря точно).

\begin{lstlisting}
[&, foo]
\end{lstlisting}

Употребление \lstinline!=! означает, что если имя захватываемой переменной не предварено символом \lstinline!&!, то она будет захвачена по значению, а не по ссылке (5.1.2.14). 

Кроме того, употребление любого из спецсимволов отдельно, означает, что \lstinline!захвачен this!, тогда захватываемая переменная из контекста класса или структуры не должна предваряться \lstinline!this->!. В случае \lstinline!=!, упоминание \lstinline!this! -- ошибка (5.1.2.8)  Такая неоднозначность может несколько запутывать.

Важно помнить, что захват по ссылке это по умолчанию захват по константной ссылке и нужно ключевое слово mutable чтобы это изменить (5.1.2.5). При этом круглые скобки списка параметров если используется \lstinline!mutable! опускать нельзя:

\begin{lstlisting}
class Foo
{
    int m_x;
  public:
    Foo () : m_x( 3 ) {}
    void func ()
      {
        int x = 0;

        /* by-copy x, error: x is readonly */
        [x] { x += 3; } ();
        
        /* by-copy x, ok */
        [x] () mutable { x += 3; } ();

        /* error: non-variable by-copy */
        [m_x] () mutable { m_x += 3; } (); 

        /* by-ref x, ok */
        [&x] () { x += 3; } ();

        /* ok, x and this captured by ref */
        [&] () { x += m_x; } ();

        /* error: capture of non-variable m_x */
        [&m_x] () mutable { std::cout << m_x; } (); 

        /* error: by-ref x, but this not captured */
        [&x] () mutable { x += m_x; } (); 

        /* ok: by-ref x, this->mx used */
        [=, &x] { x += m_x; } ();

        /* ok: this->m_x used */
        [=] () { std::cout << m_x; } ();
      }
};
\end{lstlisting}

Кроме простых правил захвата контекста, которые следует знать, есть и несколько более сложные, знание которых также полезно.

\subsubsection{Элементы высшего пилотажа}

Внутри lambda-выражения может быть использован тип переменной из контекста, для чего нет необходимости делать отдельно захват (5.2.1.18):

\begin{lstlisting}
void f(float x) 
{
  [=] { decltype(x) y1 = x; std::cout << y1; } ();
}
\end{lstlisting}

Также lambda-выражения могут быть вложенными. Это довольно странно, учитывая, что в C++ до сих пор нет вложенных функций, но тут можно выдвинуть такой аргумент, что lambda-выражение представляется скорее классом, чем функцией (см. связанный контекст), а вложенные классы в C++ есть.

\begin{lstlisting}
int main()
{
  auto nested = [] (int x) 
                  { 
                    return [](int y) { return y * 2; }(x) + 3; 
                  };

  std::cout << m << endl;
}
\end{lstlisting}

Поскольку lambda-выражения типизированы, их можно использовать вместе с шаблонами C++

\begin{lstlisting}
template <typename T> 
void negate_all(std::vector<T>& v)
{
  for_each(v.begin(), v.end(), [] (T& n) { n = -n; } );
}
\end{lstlisting}

Отдельной и интересной темой является обработка исключений внутри lambda-выражений. Мне не удалось набрать достаточно материала чтобы делать выводы, но это место выглядит достаточно error-prone и мне кажется здесь надо соблюдать существенную осторожность (пока Герб Саттер не порадует нас книгой на эту тему, я надеюсь).

Теперь пришло время разобраться с тем, как же типизированы lambda-выражения.

\subsubsection{Осваиваем \lstinline!std::function!}

lambda-выражение с пустой спецификацией считается обычной функцией и может присваиваться указателям на функции в стиле C:

\begin{lstlisting}
int test(void)
{
  typedef int (*fptr_t)();
  fptr_t fptr = [] { return 2; };
  return fptr();
}
\end{lstlisting}

Пусть теперь есть необходимость создать lambda-выражение с захватом контекста. Можно создать его использовав auto переменную:

\begin{lstlisting}
int one_more_test(int x, int y)
{
  auto f1 = [&x, &y] { return x + y; };
  return f1(); 
}
\end{lstlisting}

Но что если есть необходимость вернуть не результат вычисления lamda-выражения, а его само, чтобы использовать его (со связанным контекстом) где-то ещё? Это можно сделать использовав \lstinline!auto! на результат функции, но можно выразить эту же идею более явно через \lstinline!std::function! (20.8)
 
\begin{lstlisting}
std::function<int ()> harder_test(int x, int y)
{
  return [&x, &y] { return x + y; };
}
\end{lstlisting}

С помощью \lstinline!std::function!, есть возможность даже реализовать на C++ функции высшего порядка. Функция высшего порядка это функция, которая берёт на вход lambda-выражение и возвращает lambda-выражение.

\begin{lstlisting}
int main()
{
  auto g = [](int x) -> function<int (int)> 
     { return [=](int y) { return x + y; }; };

  auto h = [](const function<int (int)>& f, int z) 
     { return f(z) + 1; };

  auto a = h(g(7), 8);

  std::cout << a << endl;
}
\end{lstlisting}

Итак, lambda-expressions позволяют (совместно с \lstinline!std::function!) привнести в C++ некоторые полезные особенности функциональных языков, предоставляют удобный синтаксис для объявление функторов и использования алгоритмов стандартной билиотеки, и даже частично совместимы со старыми указателями на функции. Освоение lambda-выражений позволяет сделать код короче, выразительней и проще для поддержки.

\subsubsection{Generic lambdas}

Первое приближение к lambda-функциям в стандарте C++11 позволяло спсики инициализации только с конкретными типами аргументов:

\begin{lstlisting}
auto ifunc = [](int input) { return input * input; };
auto dfunc = [](double input) { return input * input; };
/* ... */
\end{lstlisting}

Но простое программирование на шаблонах оказывалось в некотором смысле более мощным, так как позволяло создать обобщенную (type-generic) функцию (или функтор) и сделать это совсем несложно:

\begin{lstlisting}
template <typename T>
T func(T z) 
{
  return z * z;
}
\end{lstlisting}

Для того, чтобы lambda-выражения не уступали в выразительной мощности, в стандарте C++14 появились обобщенные lambda-expressions.

\begin{lstlisting}
auto func = [](auto input) { return input * input; };
/* ... */
std::cout << func(2) << std::endl;
std::cout << func(2.0) << std::endl;
std::cout << func(std::complex<double>(2.0, 1.0)) << std::endl;
\end{lstlisting}

Они особенно удобны для создания функторов при использовании вместе с алгоритмами стандартной библиотеки.

\subsection{Multithreading}

Многопоточность всегда оставалась за кадром стандартных возможностей C++ и была отдана на откуп API конкретных библиотек и операционной системы. Это порождало различных уродцев, когда заказчик хотел видеть программу портабельной и для Windows и для Unix и программист был вынужден либо сам увешивать свой код условной компиляцией, либо использовать библиотеки, которые уже сделали это за него. Зачастую разные. Зачастую с кривым и несовместимым интерфейсом. В стандарте C++11 решено было наконец покончить с этой вольницей и урегулировать работу с потоками, стандартизовав её и предоставив простые и логичные механизмы для распараллеливания и синхронизации в программах на C++.

\subsubsection{Привет, поток}

Как обычно, разбор следует начинать с Hello world -- это позволит быстро ввести в курс дела и посмотреть как себя ведут простейшие потоки.

\begin{lstlisting}
#include <thread>
#include <cstdio>

using namespace std;

void 
my_thread_func (void)
{
  printf ("%s", "Hello, world\n");
}

int 
main (void)
{
  std::thread t(my_thread_func);
  t.join();
  return 0;
}
\end{lstlisting}

Итак, основной тип данных здесь это \lstinline!std::thread!. В момент создания поток t запускается и начинает выполнение функции \lstinline!my_thread_func!, переданной ему в качестве аргумента. Чтобы точно дождаться завершения потока используется метод \lstinline!join()! после которого поток гарантированно завершает исполнение.

Следует немного сказать о компиляции этого примера. GCC 4.8.1, использованный для этого мной, потребовал передачи в явном виде опции \lstinline!--std=c++11! а также опции \lstinline!-pthread! чтобы включить многопоточность. Как правило, подобный набор опций требуется и на более иных компиляторах.

Немного усложнив Hello world, можно продемонстрировать передачу аргументов в функцию потока

\begin{lstlisting}
#include <thread>
#include <cstdio>

using namespace std;

void 
my_thread_func (const char *msg)
{
  printf ("%s\n", msg);
}

void 
increment(int& i)
{
  ++i;
}

int 
main (void)
{
  int x = 42;

  std::thread t1 (my_thread_func, "Hello, world!");
  t1.join ();

  std::thread t2 (increment, std::ref (x));
  t2.join ();

  printf ("x value is %d\n", x);

  return 0;
}
\end{lstlisting}

Обратите особое внимание на использование \lstinline!std::ref! для передачи в поток по ссылке и дальнейшее использование возвращенного из потока значения.

\subsubsection{Немножко синхронизации}

Разумеется, в жизни довольно редко можно встретить поток, который занят печатью Hello World. Чаще потоки работают с данными и хорошим тоном многопоточного программирования является синхронизация данных. Базовый механизм синхронизации в C++11 называется mutex и работа с ним осуществляется через класс \lstinline!lock_guard!, являющийся красивой иллюстрацией механизма RAII.

\begin{lstlisting}
#include <mutex>
#include <cstdio>

std::mutex m;
unsigned counter = 0;

unsigned increment (void)
{
  std::lock_guard<std::mutex> lk(m);
  return ++counter;
} /* release m */

unsigned query (void)
{
  std::lock_guard<std::mutex> lk(m);
  return counter;
} /* release m */

int
main (void)
{
  increment ();
  printf ("querying: %d\n", query ());
  return 0;
}
\end{lstlisting}

Альтернативным примитивом синхронизации, предоставляемым стандартной библиотекой, являются \lstinline!condition_variable! обычно использующиеся вместе с классом \lstinline!unique_lock! и мьютексами. Они позволяют делать полноценное ожидание условия, которое происходит внутри запущенного потока:

\begin{lstlisting}
#include <thread>
#include <mutex>
#include <condition_variable>

std::condition_variable c;
std::mutex mu;

void thread_func()
{
  /* ... */
  std::unique_lock<std::mutex> lock(mu);
  /* ... */
  printf ("Notification issued\n");
  c.notify_one(); /* It also releases the unique lock */
  /* ... */
}

int
main (void)
{
  std::unique_lock<std::mutex> lock(mu); /* Lock the mutex */
  std::thread t1(thread_func);

  printf ("Waiting started\n");

  c.wait(lock); /* This unlocks the mutex mu and allows thread_func to lock it */

  printf ("Waiting complete\n");

  /* ... */

  t1.join();
  return 0;
}
\end{lstlisting}

Многие другие интересные возможности синхронизации оставлены за кадром и предлагаются на самостоятельное изучение.
Но лучше всего в модели асинхронного исполнения C++ то, что часто синхронизация вручную оказывается вообще не нужна и работа с распараллеливанием может быть выполнена гораздо, гораздо проще. 

\subsubsection{Как давать и выполнять обещания}

C++11 предоставляет программисту полезную абстракцию "асинхронный провайдер -- асинхронный результат". В этой абстракции асинхронный провайдер это объект, который обещает выполнить некоторую задачу, не конкретизируя как именно она будет выполнена. Это обещание называется \lstinline!std::promise!. В свою очередь асинхронный результат хранится как отдельный объект и может быть запрошен тогда, когда он действительно нужен. Такой результат называется \lstinline!std::future!. Посмотрим на иллюcтративный Hello, World.

\begin{lstlisting}
#include <utility>
#include <thread>
#include <future>
#include <iostream>

int
main (void)
{
  auto promise = std::promise<std::string>();

  auto producer = std::thread([&]
    {
      promise.set_value("Hello World\n");
    });

  auto future = promise.get_future();

  auto consumer = std::thread([&]
    {
      std::cout << future.get();
    });

  producer.join();
  consumer.join();

  return 0;
}
\end{lstlisting}

Здесь запущены два потока. Поток producer обещает, что он подготовит данные для вывода. Когда поток consumer готов их вывести, он запрашивает эти данные через \lstinline!future.get()! и выводит их.

Несколько граничных случаев работы с \lstinline!future! и \lstinline!promise! помогут лучше понять как это работает:

\begin{itemize}
\item Неактивное обещание
\begin{lstlisting}
int test()
{
    std::promise<int> pr;
    return 0;
}
\end{lstlisting}

Здесь все хорошо, никаких проблем

\item Неиспользованное обещание
\begin{lstlisting}
int test()
{
    std::promise<int> pr;
    auto fut = pr.get_future();
    return 0;
}
\end{lstlisting}

Все хорошо, но \lstinline!fut.get()! будет заблокировано на неопределенное время. Пока оно не вызвано -- нет проблем.

\item Множественные будущие
\begin{lstlisting}
int test()
{
    std::promise<int> pr;
    auto fut1 = pr.get_future();
    auto fut2 = pr.get_future();  /*   Error: "Future already retrieved" */
    return 0;
}
\end{lstlisting}

Ошибка, объект асинхронного результата уже получен.

\item Переданное обещание
\begin{lstlisting}
int test()
{
  std::promise<int> pr;
  auto fut = pr.get_future();

  {
    std::promise<int> pr2(std::move(pr));
    pr2.set_value(10);
  }

  return fut.get();
}
\end{lstlisting}

Все хорошо, вернет 10.

\item Слишком много результатов
\begin{lstlisting}
int test()
{
    std::promise<int> pr;
    auto fut = pr.get_future();

    {
        std::promise<int> pr2(std::move(pr));
        pr2.set_value(10);
        pr2.set_value(10);  /* Error: "Promise already satisfied" */
    }

    return fut.get();
}
\end{lstlisting}

Ошибка. Данные для асинхронного результата уже предоставлены.

\item Нарушенное обещание
\begin{lstlisting}
int test()
{
  std::promise<int> pr;
  auto fut = pr.get_future();

  {
    std::promise<int> pr2(std::move(pr));
  } // Error: "broken promise"

  return fut.get();
}
\end{lstlisting}

\end{itemize}

Механизм future/promise сам по себе достаточно удобен, но реально прозрачно его оборачивает механизм \lstinline!std::async!

\subsubsection{Утрачивая синхронность}

Предположим, что у нас есть долгое и сложное вычисление, которое хочется запустить в два параллельных потока. Нет ничего проще!

\begin{lstlisting}
#include <future>
#include <iostream>

class EquationSolver
{
public:
  void runMultiThread ();
private:
  int calculate (int from, int to);  
};

int 
EquationSolver::calculate (int from, int to)
{
  return (from + to) / 2;
}

void 
EquationSolver::runMultiThread()
{
  std::future<int> f1 = std::async (&EquationSolver::calculate, this,  0, 10);
  std::future<int> f2 = std::async (&EquationSolver::calculate, this, 11, 20);

  int res1 = f1.get ();
  int res2 = f2.get ();

  std::cout << res1 << " " << res2 << std::endl;
}

int
main (void)
{
  EquationSolver t;
  t.runMultiThread ();
  return 0;
}
\end{lstlisting}

Как видно из примера, \lstinline!std::async! принимает те же аргументы, что и \lstinline!std::thread!. После чего возвращает результат в виде \lstinline!std::future! когда он запрошен. Как именно будет выполнена асинхронная задача -- детали реализации. Скорее всего она будет запущена в несколько потоков.
Этот пример рекомендуется к изучению и экспериментам.

\subsection{Вариабельные шаблоны}

Вариабельные шаблоны расширяют идею шаблонов C++, подобно тому, как функции с произвольным числом аргументов расширяют возможности обычных функций. Прежде, чем рассматривать в деталях это новшество, следует сделать обзор использования троеточий (ellipsis) в C и C++, чтобы поместить новую информацию в контекст.

\subsubsection{Поговорим о <<\texttt{...}>>}

Троеточия (ellipsis) впервые появились в языке C для таких функций, как \lstinline!printf! и \lstinline!scanf! 

\begin{lstlisting}
int printf (const char* format, ... );
\end{lstlisting}

Были придуманы общеизвестные приемы работы с ними -- список актуально переданных аргументов, получаемый через \lstinline!va_list! однонаправленно итерировался с помощью \lstinline!va_arg!, причем никакой информации о типах не сохранялось и они были полностью отданы на откуп программиста (обычно использовалась та или иная форма дедуцирования из форматного списка). Это приводило к крайне тяжелым последствиям. Скажем простая строчка:

\begin{lstlisting}
printf(name);
\end{lstlisting}

позволяла хакеру при её вызове со строчкой вроде \lstinline!name = %f%f%f%x(%s)! распечатать содержимое рантайм-стека и вывести на экран некие хранящиеся там приватные для программы сведения. А наличие таких легальных возможностей, как форматный модификатор \lstinline!%n!, позволявший модификацию переменных:

\begin{lstlisting}
int i;
printf("12345%n6789\n", &i);
assert (i == 5);
\end{lstlisting}

Делала такие функции любимым оружием злоумышленников. 

Тем не менее, плюсы перевешивали минусы, а на атаки находились защиты. Впоследствии переменное число аргументов было распространено на макросы:

\begin{lstlisting}
#define eprintf(...) fprintf (stderr, __VA_ARGS__)
\end{lstlisting}

В C++ всё это было сохранено, и, более того, сверху было добавлено использование троеточия в обработке исключений:

\begin{lstlisting}
try{
    // Try block.
}
catch(...){
    // Catch block.
}
\end{lstlisting}

Систематически прослеживается обращение с троеточием как с заменой слов ``все что угодно''.

\subsubsection{Вариабельные шаблоны функций}

Синтаксис вариабельного шаблоны выглядит несколько необычно:

\begin{lstlisting}
template<typename... Arguments>
\end{lstlisting}

При этом он может вначале иметь и не-вариабельную часть:

\begin{lstlisting}
template<typename Arg, typename... Arguments>
\end{lstlisting}

В данном случае параметр \lstinline!Arguments...! это тип для использования в выражениях особого вида. Можно рассматривать его как ``все остальные аргументы'', а первый тип как ``верхний аргумент списка''. Интересно, что 

\begin{lstlisting}
template<typename T> void
bar(T &&t)
{
  std::cout << "b: " << t << "\n";
}

/* recursion end */
void foo() {}

template<typename Arg, typename ... Args> void 
foo(Arg &&arg, Args &&... args)
{
    bar(std::forward<Arg>(arg));
    foo(std::forward<Args>(args)...);
}

int 
main()
{
  foo (1, 2, 3, "3");
  return 0;
}
\end{lstlisting}

Используя эти возможности, можно соорудить безопасный относительно типов \lstinline!printf! не подверженный, рассматривавшимся выше атакам. Основной шаг рекурсии контролирует наличие спецификатора для каждого из поданных аргументов

\begin{lstlisting}
template<typename T, typename... Args>
void printf(const char* s, const T& value, const Args&... args) 
{ 
  while (*s) 
    { 
      if (*s == '%' && *++s != '%') 
        {
          /* ignore the character that follows the '%': we already know the type! */
          std::cout << value;
          return printf(++s, args...);
        }
      std::cout << *s++;
    }
  throw std::runtime error("extra arguments provided to printf");
}
\end{lstlisting}

Завершение рекурсии содержит контроль наличия всех необходимых аргументов.

\begin{lstlisting}
void printf(const char* s) {
  while (*s) {
    if (*s == '%' && *++s != '%') 
      throw std::runtime_error("invalid format string: missing arguments");
    std::cout << *s++;
  }
}
\end{lstlisting}

Следует обратить особое внимание на то, что обе потенциально ошибочные ситуации явно возбуждают исключения. Также замена простого троеточия на более интересную конструкцию \lstinline!const Args&... args! позволяет иметь не просто любое количество аргументов, но любое количество типизированных аргументов (что совсем другой разговор).

\subsubsection{Слияние ежа и ужа}

Вариабельные шаблоны в некотором смысле ``объединяют'' аргументы разных типов, вводя в C++ возможность сделать кортежи. В отличии от структур имеющих именованные поля разных типов и массивов, имеющих неименованные поля одного типа, кортежи это такой вид синтаксического клея, который позволяет склеивать неименованные поля разных типов. Можно сказать, что это структура которая ведет себя как массив. Механическое склеивание разнотипных полей можно проиллюстрировать через шаблон \lstinline!ctmap! с переопределенным оператором, скажем \lstinline!operator^! для доступа к полю:

\begin{lstlisting}
  auto person = ctmap (age, last_name);
  person^last_name = "Smith";
  person^age = 50;
\end{lstlisting}

Чтобы реализовать такой шаблон, потребуется простая структура с описанием поля и переопределенным оператором доступа:

\begin{lstlisting}
template <typename T>
struct Field {
  typename T::value_type storage;

  typename T::value_type &operator^(const T &) {
    return storage;
  }
};
\end{lstlisting}

Все возможные типы, которые может склеить шаблон (тут может быть любой список) описываются тэгами:

\begin{lstlisting}
template<typename T>
struct tag{using value_type=T;};

static struct:tag<int>{} age;
static struct:tag<std::string>{} last_name;
/* ... */
\end{lstlisting}

После такой подготовки, сам шаблон выглядит довольно просто

\begin{lstlisting}
template<typename... Fields>
struct ctmap_t : public Field<typename std::decay<Fields>::type>... {
};
\end{lstlisting}

И его создание с помощью выделенной для этого функции:

\begin{lstlisting}
template<class...Fields>
ctmap_t<Fields...> ctmap( Fields&&... ) { return {}; }
\end{lstlisting}

Делегирование значений полей через правые ссылки -- обычная практика в таких случаях.

\subsubsection{Стандартные кортежи и их применения}

Стандартная библиотека определяет стандартный класс \lstinline!std::tuple!

\begin{lstlisting}
std::tuple<int, double, int> t(1, 2.0, 3);
\end{lstlisting}

Доступ к трем полям осуществляется рекурсивно через \lstinline!base! и \lstinline!head_!

\begin{lstlisting}
assert (t.head_ == 1);
assert (t.base.head_ == 2.0);
assert (t.base.base.head_ == 3);
\end{lstlisting}

Кроме того, можно обращаться к полям по индексу, используя стандартную функцию \lstinline!std::get!

\begin{lstlisting}
assert (get<0>(t) == 1);
assert (get<1>(t) == 2.0);
assert (get<2>(t) == 3);
\end{lstlisting}

В стандарте C++14 добавлена возможность обращаться к полям по типу:

\begin{lstlisting}
assert (get<double>(t) == 2.0);
\end{lstlisting}

Но попытка получить нечто по типу \lstinline!int! в данном случае приведет к ошибке компиляции из-за неоднозначности.

Посредством функции \lstinline!std::tie! удобно распаковать кортеж, например чтобы обработать возвращамые из функции несколько аргументов:

\begin{lstlisting}
std::tuple<int,int> foo();

/* ... */

int a;
int b;
std::tie(a,b)=foo();
\end{lstlisting}

Ещё одна интересная задача: создание отложенного исполнения 

\begin{lstlisting}
template<int ...> struct seq {};
template<int N, int ...S> struct gens : gens<N-1, N-1, S...> {};
template<int ...S> struct gens<0, S...>{ typedef seq<S...> type; };
\end{lstlisting}

Обертка для сохранения элемента отложенного исполнения:

\begin{lstlisting}
template <typename ...Args>
struct save_it_for_later
{
  std::tuple<Args...> params;
  double (*func)(Args...);

  double delayed_dispatch()
  {
    return callFunc(typename gens<sizeof...(Args)>::type());
  }

  template<int ...S>
  double callFunc(seq<S...>)
  {
    return func(std::get<S>(params) ...);
  }
};
\end{lstlisting}

Для примера какой-нибудь простой функции:

\begin{lstlisting}
double foo(int x, float y, double z)
{
  return x + y + z;
}
\end{lstlisting}

Её отложенное исполнение.

\begin{lstlisting}
std::tuple<int, float, double> t = std::make_tuple(1, 1.2, 5);
save_it_for_later<int,float, double> saved = {t, foo};
/* ... */
auto x = saved.delayed_dispatch();
\end{lstlisting}

Здесь функция \lstinline!std::make_tuple! исполняет ту же роль, что и \lstinline!ctmap! в прошлом примере (только создает стандартный кортеж, а не самописный \lstinline!ctmap_t!).

Стандартная функция \lstinline!std::tuple_cat! позволяет конкатенировать произвольное количество кортежей в один кортеж

\begin{lstlisting}
std::tuple<int, std::string, float> t1(10, "Test", 3.14);
int n = 7;
auto t2 = std::tuple_cat(t1, std::make_pair("Foo", "bar"), t1, std::tie(n));
\end{lstlisting}

Следует обратить внимание на запись \lstinline!std::make_pair! -- единственный способ создать нечто похожее на кортеж в C++98 вполне принимается как способ создать кортеж в C++14.

\subsubsection{Вариабельные шаблоны для метапрограммирования}

Выше (\ref{TypeTraits}) были упомянуты определители типов из стандартной библиотеки. Довольно легко определить (и не надо определять, так как он есть в стандарте) простой шаблон \lstinline!is_same! определяющий одинаковые ли типы переданы ему на вход:

\begin{lstlisting}
template<class T, class U>
struct is_same : std::false_type {};
 
template<class T>
struct is_same<T, T> : std::true_type {};
\end{lstlisting}

Но вариабельные шаблоны предлагают большие возможности. Например с их помощью можно сделать определитель \lstinline!is_one_of! определяющий равенство данного типа одному из типов данного списка. Идея проста как правда:

\begin{lstlisting}
template<class T, class... List>
struct is_one_of;

template<class T>
struct is_one_of<T> : false_type {};

template<class T, class... Tail>
struct is_one_of<T, T, Tail...> : true_type {};
\end{lstlisting}

Самое сложное и изящное это рекурсивный вызов:

\begin{lstlisting}
template<class T, class Head, class... Tail>
struct is_one_of<T, Head, Tail...> : is_one_of<Head, Tail...> {};
\end{lstlisting}

Таким образом вариабельные шаблоны позволяют рекурсию по списку типов гораздо изящней, чем это позволяли делать обычные шаблоны.

\subsection{Вычисления времени компиляции}

Вычисления времени компиляции до выхода стандарта C++11 велись исключительно с помощью особой шаблонной магии, рассмотренной выше. В новом стандарте появился способ сделать это по человечески. Новое ключевое слово constexpr контролирует время выполнения выражения. Это позволяет создавать настоящие константы и константные выражения, заниматься метапрограммированием и многое другое. Здесь будут систематично рассмотрены все перечисленные возможности.

\subsubsection{Ещё раз о константности}

Уже рассматривавшийся выше модификатор const служит для того, чтобы объявить некие данные неизменяемыми. Но когда этим не изменяемым данным будет в первый раз присвоено их (в дальнейшем окончательное) значение? It depends.

\begin{lstlisting}
const int MAXSIZE = numeric_limits<int>::max();
int arr[MAXSIZE]; /* not legal in C++ */
\end{lstlisting}

В этом примере значение максимального возможного целого будет присвоено MAXSIZE только в динамике. В результате на этапе компиляции, размер arr всё ещё неизвестен и строго соответсвующие стандарту C++ компиляторы могут выразить этим свое неудовольствие (такие массивы возможны в C и часто для C++ это включают как расширение).

Те же проблемы испытывают статические данные в классах и структурах:

\begin{lstlisting}
struct S 
{
  static const int sz;
};

const int page_sz = 4 * S::sz; /* dynamic init */

const int S::sz = 256; /* too late */
\end{lstlisting}

Это законная запись. Инициализатор статической константы, как и было рассмотрено ранее, должен появиться вне класса. Далее \lstinline!page_sz! будет инициализирвоана верным значением, но потребует инициализации времени выполнения. Как ни странно, но совсем немного отличающийся код уже пройдет инициадизацию на этапе компиляции:

\begin{lstlisting}
struct S 
{
  static const int sz = 256;
};

const int page_sz = 4 * S::sz; /* static init */

const int S::sz; /* ok */
\end{lstlisting}

Это довольно грустно и требует от программиста помнить все тонкие правила константности, что, конечно, нереально. Именно этим и было мотивировано введение в стандарт ключевого слова, делающего известность на этапе компиляции явной.

\subsubsection{Константно-выраженные функции}

Как вообще могла бы быть объявлена функция \lstinline!numeric_limits<int>::max()!? Например так:

\begin{lstlisting}
#define INT_MAX (2147483647)

class numeric_limits<int>
{
public:
  static inline int max () { return INT_MAX; }
};
\end{lstlisting}

Эта функция -- прекрасный кандидат на формирование константного выражения. Она:
\begin{itemize}
\item не \lstinline!void!, то есть возвращает какое-то значение
\item состоит из одного \lstinline!return! -- то есть не заводит локальных переменных и не использует стек
\end{itemize}

Именно в таких двух условиях, функция в C++11 может быть сделана \lstinline!constexpr!

\begin{lstlisting}
class numeric_limits<int>
{
public:
  static constexpr int max () { return INT_MAX; }
};
\end{lstlisting}

Более интересный пример:

\begin{lstlisting}
constexpr int square(int x) { return x * x; }
/* ... */
const int res = square(5);
\end{lstlisting}

Здесь res будет известен на этапе компиляции. Но при этом в таком виде:

\begin{lstlisting}
int
foo (int y)
{
  return square(y);
}
\end{lstlisting}

Функция square (даже объявленная \lstinline!constexpr!) ведёт себя как самая обычная функция. Это позволяет иметь её одну, не заводя зоопарк \lstinline!constexpr! и не-\lstinline!constexpr! зверюшек.

В стандарте C++14 ослаблены ограничения. Начиная с этого стандарта, в такой функции могут содержаться:

\begin{itemize}
\item Все объявления, кроме \lstinline!static! и \lstinline!thread_local! переменных, а также неинициализированных переменных
\item Условные операции \lstinline!if! и \lstinline!switch!
\end{itemize}

Это делает написание таких функций гораздо более удобным. Например легальной становится следующая конструкция:

\begin{lstlisting}
constexpr int 
g(int x, int n) 
{ 
  int r = 1;
  while (--n > 0) r *= x;
  return r;
}
\end{lstlisting}

Конечно это увеличивает работу для компилятора.

\subsubsection{Аннотация данных}

Чтобы отличать обычные данные от известных на этапе компиляции, данные и даже члены классов тоже можно аннотировать \lstinline!constexpr!

\begin{lstlisting}
struct S
{
private:
  static constexpr int sz; // constexpr variable
public:
  constexpr int two(); //constexpr function
};

constexpr int S::sz = 256;
enum DataPacket
{
  Small=S::two(), //error. S::two() called before it was defined
  Big=1024
};

constexpr int S::two() { return sz*2; }
constexptr S s;

int arr[s.two()]; //OK, s.two() called after its definition
\end{lstlisting}

Видно, что по существу они мало чем отличаются от обычных данных. Но компилятор имеет насчёт них точную гарантию что их значения при компиляции уже известны.

Но тогда возникает вопрос. Неужели у нас могут быть \lstinline!constexpr! данные типов \lstinline!int! или \lstinline!float!, но не может быть \lstinline!constexpr! данных пользовательских типов? Конечно могут.

\subsubsection{Темные чудеса шаблонных переменных}

В отличии от C++11, в C++14 разрешено делать шаблонными не только 

\begin{lstlisting}
template<typename T> T n = T(5);

int 
main()
{
    n<int> = 10;
    std::cout << n<int> << " ";    // 10
    std::cout << n<double> << " "; // 5
}
\end{lstlisting}

Вместе с \lstinline!constexpr! аннотацией переменных, это позволяет вводить гораздо более симпатичные определители типов, рассмотренные в (\ref{TypeTraits}).

\begin{lstlisting}
template <class T> constexpr bool is_void_v = is_void<T>::value;
\end{lstlisting}

Записывать \lstinline!is_void_v<T>! конечно гораздо проще и приятней, чем \lstinline!is_void<T>::value! (общий смех).

\subsubsection{Аннотация конструкторов}

Если у вас есть необходимость, чтобы ваш тип мог вести себя как compile-time константа, для него можно написать constexpr-коснтруктор:

\begin{lstlisting}
struct complex
{
public:
  constexpr complex(double r, double i) : re(r), im(i) { }
  constexpr double real() { return re;}
  constexpr double imag() { return im;}
private:
 double re;
 double im;
};

constexpr complex c(0.0, 1.0);
\end{lstlisting}

Тело такого конструктора обязано быть пустым, вся инициализация производится в списке инициализации.

\subsubsection{Пользовательские литералы}

Наличие constexpr конструкторов специального вида, позволяет определять пользовательские литералы.

\begin{lstlisting}
#include <cstdio>
#include <utility>

struct Complex
{
public:
  constexpr Complex(double r = 0.0, double i = 0.0) : re(r), im(i) { }

  class Imaginary {}; /* tag */
  explicit constexpr Complex(Imaginary, double i) : re (0.0), im (i) {}

  constexpr double real() { return re;}
  constexpr double imag() { return im;}

  friend constexpr Complex operator+ (const Complex lhs, const Complex rhs);

private:
  double re;
  double im;
};

constexpr Complex operator+ (const Complex lhs, const Complex rhs)
{
  return Complex(lhs.re+rhs.re, lhs.im+rhs.im);
}

constexpr Complex operator "" _i( long double i )
{
  return Complex{Complex::Imaginary{}, static_cast<double>(i)};
}

int
main (void)
{
  constexpr Complex c = 0.0 + 1.0_i;

  std::printf ("c: (%g, %g)\n", c.real(), c.imag());
  return 0;
}
\end{lstlisting}

Ключевой строчкой в это машинерии является \lstinline!constexpr Complex c = 0.0 + 1.0_i! что достигается с помощью переопределения \lstinline!constexpr Complex operator "" _i! и разумеется пользователь может переопределять любые литералы.

\textbf{Домашняя наработка:} добейтесь работы строчки \lstinline!constexpr Kilogramm mass = 5_kg + 3_lb!, где lb это фунты, на этапе компиляции строящей преобразование фунтов в килограммы.

\pagebreak
\section{За пределами беспредельного}

C++ не ограничивается стандартным C++. Конечно, все мы стремимся писать стандартные и переносимые программы. Но полезно также ориентироваться в почти бесконечном мире его ответвлений, диалектов и расширений -- иногда это позволяет сэкономить массу времени и сил.

\subsection{Что такое technical report}

Между 98-м годом когда вышел первый стандарт C++ и 2011-м, когда вышел второй, прошло довольно много времени.

\subsection{Обзор boost}

Разумеется, Boost -- слишком большая библиотека чтобы рассмотреть тут его весь. Но общий обзор и примеры некоторых полезных библиотек помогут сориентироваться.

\subsection{Расширения GNU}

Почти каждая реализация компилятора C++ реализует своё надмножество языка, с некоторыми расширениями специфичными для конкретного компилятора. Например вместе с MSVS идёт так называемая Secure CRT и много майкрософт-специфичных вещей, вместе с ICC предоставляются расширения для Intel-специфичного кода. Здесь как пример будут рассмотрены самые полезные из расширений GCC -- как наиболее знакомого автору этих лекций компилятора. Кроме того, многие из расширений GCC один в один доступны на других компиляторах (скажем на LLVM/Clang).

\subsubsection{Атрибуты}

Здесь нечто про атрибуты в целом и примеры noinline, packed, прочих

\subsubsection{Зависимость от архитектуры}

Архитектурно-зависимая перегрузка функций

\subsubsection{Арифметика}

Здесь нечто про длинные int и float, а также про fixed point типы

\subsubsection{Inline-ассемблер}

Здесь про взаимодействие с GNU AS из C/C++

\pagebreak
\addcontentsline{toc}{section}{Список иллюстраций}
\listoffigures

\pagebreak
\addcontentsline{toc}{section}{Список литературы}
\begin{thebibliography}{99}
%Standards
\bibitem{stdcpp98} ISO/IEC, \textit{<<International Standard, Programming Languages>>}, ISO/IEC 14882:1998, 1998
\bibitem{stdc90} ISO/IEC, \textit{<<International Standard, Programming Languages>>}, ISO/IEC 9899:1990, 1990
\bibitem{stdc99} ISO/IEC, \textit{<<International Standard, Programming Languages>>}, ISO/IEC 9899:1999, 1999
\bibitem{stdc11} ISO/IEC, \textit{<<International Standard, Programming Languages>>}, ISO/IEC 9899:2011, 2011
\bibitem{stdcpp11} ISO/IEC, \textit{<<International Standard, Programming Languages>>}, ISO/IEC 14882:2011, 2011
%Books
\bibitem{linden} Peter van der Linden, \textit{<<Expert C Programming: Deep C Secrets>>}, Prentice Hall, 1994
\bibitem{stroustrup} Bjarne Stroustrup, \textit{<<The C++ Programming Language, The Special Edition>>}. Reading, MA: Addison-Wesley, 2001.
\bibitem{effcpp3d} Scott Meyers. \textit{<<Effective C++ : 55 Specific Ways to Improve Your Programs and Designs (3rd Edition)>>}, MA: Addison-Wesley, 2005
\bibitem{effectivestl} Scott Meyers. \textit{<<Effective STL>>}. Addison Welsey Longman, 2001
\bibitem{vandervoord} Davide Vandevoorde, Nicolai M. Josuttis. \textit{<<C++ Templates. The Complete Guide>>}, Boston, Pearson Education, Inc., 2003.
\bibitem{booch} Grady Booch. \textit{<<Object-Oriented Analysis and Design with Applications (2nd Edition)>>}
\bibitem{exceptionalcpp} Herb Sutter. \textit{<<Exceptional C++: 47 Engineering Puzzles, Programming Problems, and Solutions>>}. Reading, MA: Addison-Wesley, 2000
\bibitem{mcpp} A. Alexandrescu. \textit{<<Modern C++ Design. Generic programming and design patterns applied>>}, Addison-Wesley Longman, 2001
%Papers
\bibitem{LSP} Liskov, Barbara. \textit{<<Data Abstraction and Hierarchy>>}, Addendum to the Proceedings on Object-oriented Programming Systems, Languages and Applications, 1987
\bibitem{ISP} Martin, Robert. \textit{<<The Interface Segregation Principle>>}
\end{thebibliography}

\pagebreak
\addcontentsline{toc}{section}{Индекс}
\printindex

\end{document}
