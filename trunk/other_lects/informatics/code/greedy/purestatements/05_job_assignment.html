<head>Problem JA: распределение работы</head>
<body>
<p>У вас есть totaltime дней и n заказов, каждый из которых займёт один день. У каждого заказа есть номер, стоимость и дедлайн. Каждый заказ можно начинать в любой день до делайна, одновременно можно делать только один</p>
<p>Вы должны выбрать наилучшее по максимальной стоимости выполнимое подмножество заказов</p>
<pre>
// описание заказа
struct order_t { int number; int cost; int deadline; };

// массив номеров выбранных заказов и его размер
struct answer_t { int norders; int *numbers; };

struct answer_t 
betforjobs(struct order_t * orders, int n, int totaltime) {
  // TODO: your code here
}
</pre>
<p>Вы не должны полагаться на то, что входной массив как-то отсортирован</p>
<p>Может оказаться так, что существует несколько оптимальных решений. Просто верните любое из них</p>
<p>Обратите внимание: результирующий массив numbers должен быть выделен в динамической памяти</p>
<p><br/>Пример</p>
<table border="1">
   <tr>
    <th>number</th>
    <th>deadline</th>
    <th>cost</th>
   </tr>
   <tr><td>1</td><td>2</td><td>100</td></tr>
   <tr><td>2</td><td>1</td><td>27</td></tr>
   <tr><td>3</td><td>2</td><td>25</td></tr>
   <tr><td>4</td><td>1</td><td>19</td></tr>
   <tr><td>5</td><td>3</td><td>25</td></tr>
</table>
<p>В этом примере вы должны вернуть {3, 1, 5}</p>
<p>Совершенно не важно в каком порядке будут идти эти номера в результирующем массиве</p>
</body>
